{"version":3,"file":"index.mjs","sources":["../src/core/lib/errors.ts","../src/core/lib/hashCode.ts","../src/core/lib/peek.ts","../src/core/BufferParser.ts","../src/core/lib/math.ts","../src/core/lib/scalar.ts","../src/core/lib/bitmask.ts","../src/core/lib/utf8.ts","../src/core/lib/coders.ts","../src/core/config.ts","../src/core/lib/float16.ts","../src/core/lib/BufferWriter.ts","../src/core/lib/BufferReader.ts","../src/core/Type.ts","../src/core/BufferFormat.ts"],"sourcesContent":["export class TinybufError extends Error {}\n\nexport class EncodeError extends TinybufError {\n  public constructor(message: string)\n  public constructor(expectedType: string, value: any, path: string)\n  public constructor(a: string, b?: any, c?: string) {\n    super(`Failed to encode ${b} as '${a}'${c ? ` (path: '${c}')` : ''}`);\n  }\n}\n\nexport class DecodeError extends TinybufError {\n  public constructor(\n    summary: string,\n    public readonly cause: Error,\n  ) {\n    super(`${summary}: ${cause.message}`);\n    this.stack = cause.stack;\n  }\n}\n","/**\n * DJB2 hash algorithm (modified for 16-bit uints).\n *\n * DJB2 is a simple and widely used non-cryptographic\n * hash function created by Daniel J. Bernstein.\n *\n * @returns 16-bit unsigned integer\n */\nexport function $hashCode(str: string): number {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = (hash * 33) ^ str.charCodeAt(i);\n  }\n  return hash & 0xFFFF; // Ensure the result is a Uint16\n}\n\n/**\n * Returns an unsigned 16-bit integer hashcode for some string.\n * Prefers 2 character string.\n *\n * @returns A UInt16 between 0 and 65535 (inclusive).\n */\nexport function $strToHashCode(str: string): number {\n  if (str.length !== 2) return $hashCode(str);\n  return str.charCodeAt(0) * 256 + str.charCodeAt(1);\n}\n\n/**\n * Convert a UInt16 hashcode to a 2-byte string.\n */\nexport function $hashCodeToStr(hashCode: number): string {\n  return String.fromCharCode(Math.floor(hashCode / 256)) + String.fromCharCode(hashCode % 256);\n}\n","import { $hashCodeToStr } from \"./hashCode\";\n\n\n/**\n * Read the header bytes of a buffer as a number.\n *\n * @throws {RangeError} if buffer size < 2\n */\nexport function peekHeader(b: ArrayBuffer | ArrayBufferView): number {\n  return new DataView(b instanceof ArrayBuffer ? b : b.buffer).getUint16(0, false);\n}\n\n/**\n * Read the header bytes of a buffer as a string.\n *\n * @throws {RangeError} if buffer length < 2\n */\nexport function peekHeaderStr(b: ArrayBuffer | ArrayBufferView): string {\n  return $hashCodeToStr(peekHeader(b));\n}\n","import { BufferFormat } from \"./BufferFormat\";\nimport { EncoderDefinition, InferredDecodedType } from \"./Type\";\nimport { DecodeError, TinybufError } from \"./lib/errors\";\nimport { $hashCodeToStr, $strToHashCode } from \"./lib/hashCode\";\nimport { peekHeader } from \"./lib/peek\";\n\ntype AnyFormat = BufferFormat<any, any>;\ntype Uint16FormatHeader = number;\n\n/**\n * Small utility for registering and processing format handlers.\n *\n * @example\n * const myHandler = bufferParser()\n *   .on(FormatA, aData => {})\n *   .on(FormatB, bData => {});\n *\n * myHandler.processBuffer(bytes);\n */\nexport const bufferParser = (): BufferParser => new BufferParser();\n\nexport class BufferParser {\n  /** @internal */\n  private _$formats = new Map<Uint16FormatHeader, [AnyFormat, (data: any) => any]>();\n\n  /**\n   * Decode an array buffer and trigger the relevant data handler.\n   *\n   * When passed an ArrayBufferView, accesses the underlying 'buffer' instance directly.\n   *\n   * @throws {TinybufError} if fails to decode, or no handler is registered\n   */\n  public processBuffer(b: ArrayBuffer | ArrayBufferView): void {\n    let f: any, data: any, cb: (data: any) => any;\n\n    try {\n      const header = peekHeader(b);\n\n      if (!this._$formats.has(header)) {\n        throw new TinybufError(`Unknown format: ${header} '${$hashCodeToStr(header)}')`);\n      }\n\n      [f, cb] = this._$formats.get(header);\n      data = f.decode(b);\n    }\n    catch (e) {\n      throw new DecodeError('Failed to decode', e);\n    }\n\n    cb(data);\n  }\n\n  /**\n   * Register a format handler.\n   */\n  public on<EncoderType extends EncoderDefinition, DecodedType = InferredDecodedType<EncoderType>>(\n    format: BufferFormat<EncoderType, string | number>,\n    callback: (data: DecodedType) => any,\n    overwritePrevious: boolean = false,\n  ): this {\n    if (format.header == null) {\n      throw new TinybufError('Format requires header');\n    }\n\n    const header = typeof format.header === 'string' ? $strToHashCode(format.header) : format.header;\n\n    if (this._$formats.has(header) && !overwritePrevious) {\n      throw new TinybufError(`Format header collision: ${format.header}`);\n    }\n\n    this._$formats.set(header, [format, callback]);\n\n    return this;\n  }\n\n  /** Register a format (or formats) that are recognized. */\n  public ignore(...format: AnyFormat[]): this {\n    format.forEach(f => this.on(f, () => {}, true));\n    return this;\n  }\n\n  /** Clears all registered formats and handlers. */\n  public clear(): void {\n    this._$formats.clear();\n  }\n}\n","export const $floor = Math.floor,\n  $ceil = Math.ceil;\n\n/** Clamp a number to a range. */\nexport const $clamp = (value: number, min: number, max: number): number =>\n  value > max ? max : value < min ? min : value;\n\n/** Round toward zero */\nexport const $roundTowardZero = (x: number): number => x < 0 ? $ceil(x) : $floor(x);\n\n/** Round away zero */\nexport const $roundAwayFromZero = (x: number): number =>\n  x < 0 ? $floor(x) : $ceil(x);\n","import { $clamp, $roundTowardZero, $roundAwayFromZero } from \"./math\";\n\n/**\n * Quantize a number to an 8-bit scalar between 0.0 and 1.0.\n *\n * @returns A number (double) in its closest signed scalar representation.\n */\nexport function uscalround(x: number): number {\n  return $fromuscal8($touscal8(x));\n}\n\n/**\n * Quantize a number to an 8-bit signed scalar between -1.0 and 1.0.\n *\n * @returns A number (double) in its closest signed scalar representation.\n */\nexport function scalround(x: number): number {\n  return $fromscal8($toscal8(x));\n}\n\n/** @returns A UInt8 bitmask representation. */\nexport function $touscal8(x: number): number {\n  return $clamp(127 + $roundTowardZero(x * 254 - 127), 0, 254);\n}\n\n/** @returns A UInt8 bitmask representation. */\nexport function $toscal8(x: number): number {\n  return $clamp($roundTowardZero(x * 127), -127, 127) + 127;\n}\n\n/** @returns An unsigned scalar between 0.0 and 1.0. */\nexport function $fromuscal8(x: number): number {\n  // Make symmetric: (0.5 + round((uint8 - 127) / 254 * 100)) / 100\n  return $clamp(($roundAwayFromZero((x - 127) * 0.3937007874015748) + 50) * 0.01, 0, 1);\n}\n\n/** @returns A signed scalar between -1.0 and 1.0. */\nexport function $fromscal8(x: number): number {\n  // Make symmetric: round((uint8 - 127) / 127 * 100) / 100\n  return $clamp($roundAwayFromZero((x - 127) * 0.787401574803149) * 0.01, -1, 1);\n}\n","export const mask = (x: boolean[], pad = 0b1): number => {\n  return x.slice(0, 30).reduce((n, b: any) => (n << 1) | b, pad);\n};\n\nexport const unmask = (x: number, len = 31 - Math.clz32(x)): boolean[] => {\n  return Array.from({ length: len}, (_, i) => 1 === (x >> (len-1-i) & 1));\n};\n","const encoder = new TextEncoder();\nconst decoder = new TextDecoder('utf-8');\n\nexport const $utf8encode = (x?: string): Uint8Array => encoder.encode(x);\nexport const $utf8decode = (y: Uint8Array): string => decoder.decode(y);\n","import { BufferWriter } from './BufferWriter';\nimport { BufferReader } from './BufferReader';\nimport { $floor } from './math';\nimport {\n  $fromuscal8,\n  $fromscal8,\n  $touscal8,\n  $toscal8\n} from './scalar';\nimport { Type } from '../Type';\nimport { mask, unmask } from './bitmask';\nimport { $utf8decode, $utf8encode } from './utf8';\n\n// Pre-calculated constants\nconst MAX_VARUINT8 = 128,\n  MAX_VARUINT16 = 16_384,\n  MAX_VARUINT32 = 536_870_912,\n  MAX_VARINT8 = 64,\n  MAX_VARINT16 = 8_192,\n  MAX_VARINT32 = 268_435_456,\n  POW_32 = 0x100000000;\n\nexport interface BinaryTypeCoder<T, R = T> {\n  $write(value: T, data: BufferWriter, path?: string): void;\n  $read(state: BufferReader): R;\n}\n\n/**\n * Formats (big-endian):\n * 7b   0xxx xxxx\n * 14b  10xx xxxx  xxxx xxxx\n * 29b  110x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx\n * 61b  111x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx\n */\nexport const uintCoder: BinaryTypeCoder<number> = {\n  $write: (value, data) => {\n    if (value < MAX_VARUINT8) {\n      data.$writeUInt8(value);\n    }\n    else if (value < MAX_VARUINT16) {\n      data.$writeUInt16(value + 0x8000);\n    }\n    else if (value < MAX_VARUINT32) {\n      data.$writeUInt32(value + 0xc0000000);\n    }\n    else {\n      data.$writeUInt32($floor(value / POW_32) + 0b11100000000000000000000000000000);\n      data.$writeUInt32(value >>> 0);\n    }\n  },\n  $read: (state) => {\n    const firstByte = state.$peek();\n\n    if (!(firstByte & 0b10000000)) {\n      state.$skipByte();\n      return firstByte;\n    }\n    else if (!(firstByte & 0x40)) {\n      return state.$readUint16() - 0x8000;\n    }\n    else if (!(firstByte & 0x20)) {\n      return state.$readUint32() - 0xc0000000;\n    }\n    else {\n      return (state.$readUint32() - 0xe0000000) * POW_32 + state.$readUint32();\n    }\n  }\n};\n\nexport const uint8Coder: BinaryTypeCoder<number> = {\n  $write: (value, data, path) => {\n    data.$writeUInt8(value);\n  },\n  $read: (state) => {\n    return state.$readUint8();\n  }\n};\n\nexport const uint16Coder: BinaryTypeCoder<number> = {\n  $write: (value, data) => {\n    data.$writeUInt16(value);\n  },\n  $read: (state) => {\n    return state.$readUint16();\n  }\n};\n\nexport const uint32Coder: BinaryTypeCoder<number> = {\n  $write: (value, data) => {\n    data.$writeUInt32(value);\n  },\n  $read: (state) => {\n    return state.$readUint32();\n  }\n};\n\n/**\n * Same formats as uintCoder.\n *\n * @see {uintCoder}\n */\nexport const intCoder: BinaryTypeCoder<number> = {\n  $write: (value, data) => {\n    if (value >= -MAX_VARINT8 && value < MAX_VARINT8) {\n      data.$writeUInt8(value & 0x7f);\n    }\n    else if (value >= -MAX_VARINT16 && value < MAX_VARINT16) {\n      data.$writeUInt16((value & 0x3fff) + 0x8000);\n    }\n    else if (value >= -MAX_VARINT32 && value < MAX_VARINT32) {\n      data.$writeUInt32((value & 0x1fffffff) + 0xc0000000);\n    }\n    else {\n      const intValue = value;\n      // Split in two 32b uints\n      data.$writeUInt32(($floor(intValue / POW_32) & 0x1fffffff) + 0xe0000000);\n      data.$writeUInt32(intValue >>> 0);\n    }\n  },\n  $read: (state) => {\n    let firstByte = state.$peek(), i: number;\n\n    if (!(firstByte & 0x80)) {\n      state.$skipByte();\n      return (firstByte & 0x40) ? (firstByte | 0xffffff80) : firstByte;\n    }\n    else if (!(firstByte & 0x40)) {\n      i = state.$readUint16() - 0x8000;\n      return (i & 0x2000) ? (i | 0xffffc000) : i;\n    }\n    else if (!(firstByte & 0x20)) {\n      i = state.$readUint32() - 0xc0000000;\n      return (i & 0x10000000) ? (i | 0xe0000000) : i;\n    }\n    else {\n      i = state.$readUint32() - 0xe0000000;\n      i = (i & 0x10000000) ? (i | 0xe0000000) : i;\n      return i * POW_32 + state.$readUint32();\n    }\n  }\n};\n\nexport const int8Coder: BinaryTypeCoder<number> = {\n  $write: (value, data, path) => data.$writeInt8(value),\n  $read: (state) => state.$readInt8(),\n};\n\nexport const int16Coder: BinaryTypeCoder<number> = {\n  $write: (value, data, path) => data.$writeInt16(value),\n  $read: (state) => state.$readInt16(),\n};\n\nexport const int32Coder: BinaryTypeCoder<number> = {\n  $write: (value, data, path) => data.$writeInt32(value),\n  $read: (state) => state.$readInt32(),\n};\n\nexport const float16Coder: BinaryTypeCoder<number> = {\n  $write: (value, data, path) => data.$writeFloat16(value),\n  $read: (state) => state.$readFloat16(),\n};\n\nexport const float32Coder: BinaryTypeCoder<number> = {\n  $write: (value, data, path) => data.$writeFloat32(value),\n  $read: (state) => state.$readFloat32(),\n};\n\nexport const float64Coder: BinaryTypeCoder<number> = {\n  $write: (value, data, path) => data.$writeFloat64(value),\n  $read: (state) => state.$readFloat64(),\n};\n\nexport const uscalarCoder: BinaryTypeCoder<number> = {\n  $write: (value, data, path) => data.$writeUInt8($touscal8(value)),\n  $read: (state) => $fromuscal8(state.$readUint8()),\n};\n\nexport const scalarCoder: BinaryTypeCoder<number> = {\n  $write: (value, data, path) => data.$writeUInt8($toscal8(value)),\n  $read: (state) => $fromscal8(state.$readUint8()),\n};\n\nexport const dateCoder: BinaryTypeCoder<Date> = {\n  $write: (value, data, path) => intCoder.$write(value.getTime(), data, path),\n  $read: (state) => new Date(intCoder.$read(state)),\n};\n\nexport const stringCoder: BinaryTypeCoder<string> = {\n  $write: (value, data, path) => {\n    bufferCoder.$write($utf8encode(value), data, path);\n  },\n  $read: (state) => {\n    return $utf8decode(bufferCoder.$read(state));\n  }\n};\n\nexport const bufferCoder: BinaryTypeCoder<ArrayBuffer | ArrayBufferView, Uint8Array> = {\n  $write: (value, data, path) => {\n    uintCoder.$write(value.byteLength, data, path);\n    data.$writeBuffer(value);\n  },\n  $read: (state) => state.$readBuffer(uintCoder.$read(state)),\n};\n\nexport const boolCoder: BinaryTypeCoder<boolean> = {\n  $write: (value, data) => data.$writeUInt8(value ? 1 : 0),\n  $read: (state) => state.$readUint8() !== 0,\n};\n\nexport const boolsCoder: BinaryTypeCoder<boolean[]> = {\n  $write: (value, data) => uintCoder.$write(mask(value), data),\n  $read: (state) => unmask(uintCoder.$read(state)),\n};\n\nexport const jsonCoder: BinaryTypeCoder<any> = {\n  $write: (value, data, path) => stringCoder.$write(JSON.stringify(value), data, path),\n  $read: (state) => JSON.parse(stringCoder.$read(state)),\n};\n\nexport const regexCoder: BinaryTypeCoder<RegExp> = {\n  $write: (value, data, path) => {\n    data.$writeUInt8(mask([value.global, value.ignoreCase, value.multiline]));\n    stringCoder.$write(value.source, data, path);\n  },\n  $read: (state) => {\n    const [g, i, m] = unmask(state.$readUint8());\n    return new RegExp(stringCoder.$read(state), (g ? 'g' : '') + (i ? 'i' : '') + (m ? 'm' : ''));\n  }\n};\n\n/**\n * Array of coders, indexed by type\n */\nexport const CODERS: Record<Type, BinaryTypeCoder<any>> = [\n  uintCoder, // Type.UInt\n  uint8Coder, // Type.UInt8\n  uint16Coder, // Type.UInt16\n  uint32Coder, // Type.UInt32\n  intCoder, // Type.Int\n  int8Coder, // Type.Int8\n  int16Coder, // Type.Int16\n  int32Coder, // Type.Int32\n  float64Coder, // Type.Float64\n  float32Coder, // Type.Float32\n  float16Coder, // Type.Float16\n  scalarCoder, // Type.Scalar\n  uscalarCoder, // Type.UScalar\n  boolCoder, // Type.Bool\n  boolsCoder, // Type.Bools\n  stringCoder, // Type.String\n  bufferCoder, // Type.Buffer\n  jsonCoder, // Type.JSON\n  regexCoder, // Type.RegExp\n  dateCoder, // Type.Date\n];\n","/** Default maximum transmission unit in networking */\nconst MTU = 1500;\n\n/** Set Tinybuf global config */\nexport const setTinybufConfig = (c: Partial<TinybufConfig>): void => {\n  cfg = { ...cfg, ...c };\n};\n\nexport type TinybufConfig = {\n  /**\n   * (default: false)\n   * By default `BufferFormat.encode(…)` optimizes performance and memory by\n   * encoding data to a shared buffer, and returning a `Uint8Array` pointer\n   * to the encoded bytes.\n   *\n   * Subsequent calls to `encode(…)` are destructive, so this would be\n   * unsuitable for asyncronous usage (e.g. Promises, Web Workers).\n   *\n   * Set `safe` to true to copy bytes to a new buffer and return that.\n   */\n  safe: boolean,\n\n  /**\n   * (default: true)\n   * By default, format encoders share a global encoding buffer for performance\n   * and memory management reasons.\n   *\n   * When set to false, each format will be allocated its own resizable\n   * encoding buffer.\n   *\n   * Enable to maximise performance and memory re-use, just be cautious of\n   * possible race conditions.\n   */\n  useGlobalEncodingBuffer: boolean,\n\n  /**\n   * (default: 1500)\n   * The maximum bytes to allocate to an encoding buffer. If using the global\n   * encoding buffer, this is the size it is initialized to.\n   */\n  encodingBufferMaxSize: number,\n\n  /**\n   * (default: 256)\n   * Initial bytes to allocate to individual format encoding buffers, if used.\n   */\n  encodingBufferInitialSize: number,\n\n  /**\n   * (default: 256)\n   * Additional bytes when resizing individual format encoding buffers, if used.\n   */\n  encodingBufferIncrement: number,\n};\n\n/** @internal */\nexport let cfg: TinybufConfig = {\n  safe: false,\n  useGlobalEncodingBuffer: true,\n  encodingBufferMaxSize: MTU,\n  encodingBufferInitialSize: 256,\n  encodingBufferIncrement: 256,\n};\n","/**\n * Returns the nearest half precision float representation of a number.\n * @param x A numeric expression.\n */\nexport function f16round(x: number): number {\n  return $fromf16($tof16(x));\n}\n\n/**\n * Returns the nearest half precision float representation of a number as a 16-bit bitmask.\n */\nexport const $tof16 = (function() {\n  const x = new Float32Array(1);\n  const y = new Int32Array(x.buffer);\n\n  return function (f: number) {\n    x[0] = f;\n    let i = y[0]; // 32-bit int\n    let s = (i >> 16) & 0X8000; // sign\n    let z = (i & 0X7FFFFFFF) + 0X1000 | 0;\n\n    if (z >= 0X47800000) {\n      if ((i & 0X7FFFFFFF) < 0X47800000) return s | 0X7BFF;\n      if (z < 0X7F800000) return s | 0X7C00;\n      return s | 0X7C00 | (i & 0X007FFFFF) >> 13;\n    }\n    if (z >= 0X38800000) return s | z - 0X38000000 >> 13;\n    else if (z < 0X33000000) return s;\n    z = (i & 0X7FFFFFFF) >> 23;\n    return s | ((i & 0X7FFFFF | 0X800000)\n      + (0X800000 >>> z - 102)\n      >> 126 - z);\n  };\n}());\n\n/**\n * Returns the nearest half precision float value for a 16-bit bitmask.\n */\nexport const $fromf16 = (function() {\n  const x = Float64Array.from({ length: 32 }, (_, e) => Math.pow(2, e - 15)); // biased exponents\n  const y = Float64Array.from({ length: 1024 }, (_, m) => 1 + m / 1024); // normalized mantissas\n  const z = Math.pow(2, -24); // subnormal constant\n\n  return function (b: number): number {\n    const s = (b & 32768) === 32768 ? -1 : 1; // sign: 1 bit\n    const e = b & 31744; // exponent: 5 bits\n    const m = b & 1023; // mantissa: 10 bits\n\n    if (e === 0) return m === 0 ? s * 0 : s * z;\n    if (e === 31744) return m === 0 ? s * Infinity : NaN;\n    return s * x[e >> 10] * y[m];\n  };\n}());\n","import { cfg } from \"../config\";\nimport { EncodeError } from \"./errors\";\nimport { $tof16 } from \"./float16\";\n\n/**\n * Wraps a view into an underlying buffer, and can be dynamically resized.\n *\n * @internal\n */\nexport class BufferWriter {\n  public $byteOffset: number = 0;\n\n  private _$dataView: DataView;\n  private _$buf: ArrayBuffer;\n  private readonly _$autoResize: boolean;\n\n  public constructor(value: number | ArrayBuffer) {\n    if (value instanceof ArrayBuffer) {\n      this._$buf = value;\n      this._$autoResize = false;\n    }\n    else {\n      this._$buf = new ArrayBuffer(value);\n      this._$autoResize = true;\n    }\n\n    this._$dataView = new DataView(this._$buf, 0, this._$buf.byteLength);\n  }\n\n  public $asView(): Uint8Array {\n    return new Uint8Array(this._$dataView.buffer, 0, this.$byteOffset);\n  }\n\n  public $asCopy(): Uint8Array {\n    return new Uint8Array(this._$dataView.buffer.slice(0, this.$byteOffset));\n  }\n\n  // ----- Writers: -----\n\n  public $writeInt8(value: number): void {\n    this._$dataView.setInt8(this._$alloc(1), value);\n  }\n\n  public $writeInt16(value: number): void {\n    this._$dataView.setInt16(this._$alloc(2), value, true);\n  }\n\n  public $writeInt32(value: number): void {\n    this._$dataView.setInt32(this._$alloc(4), value, true);\n  }\n\n  public $writeUInt8(value: number): void {\n    this._$dataView.setUint8(this._$alloc(1), value);\n  }\n\n  public $writeUInt16(value: number): void {\n    this._$dataView.setUint16(this._$alloc(2), value); // big-endian\n  }\n\n  public $writeUInt32(value: number): void {\n    this._$dataView.setUint32(this._$alloc(4), value); // big-endian\n  }\n\n  public $writeFloat16(value: number): void {\n    this._$dataView.setUint16(this._$alloc(2), $tof16(value));\n  }\n\n  public $writeFloat32(value: number): void {\n    this._$dataView.setFloat32(this._$alloc(4), value, true);\n  }\n\n  public $writeFloat64(value: number): void {\n    this._$dataView.setFloat64(this._$alloc(8), value, true);\n  }\n\n  public $writeBuffer(b: ArrayBuffer | ArrayBufferView): void {\n    const byteOffset = this._$alloc(b.byteLength);\n    const readView = b instanceof Uint8Array ? b\n      : b instanceof ArrayBuffer ? new Uint8Array(b)\n        : new Uint8Array(b.buffer, b.byteOffset, b.byteLength);\n    new Uint8Array(this._$dataView.buffer, byteOffset, b.byteLength).set(readView);\n  }\n\n  // ----- Private methods: -----\n\n  /** Allocate the given number of bytes, and then return the current header position (byteOffset). */\n  private _$alloc(bytes: number): number {\n    if (this.$byteOffset + bytes <= this._$dataView.byteLength) {\n      const i = this.$byteOffset; // copy\n      this.$byteOffset += bytes;\n\n      return i;\n    }\n\n    const currentAlloc = this._$dataView.byteLength;\n    const minRequestedSize = currentAlloc + bytes;\n    if (!this._$autoResize || minRequestedSize > cfg.encodingBufferMaxSize) {\n      throw new EncodeError(`exceeded max encoding buffer size: ${cfg.encodingBufferMaxSize}`);\n    }\n\n    let newLength = this._$dataView.byteLength;\n    do {\n      newLength = Math.min(newLength + cfg.encodingBufferIncrement, cfg.encodingBufferMaxSize);\n    }\n    while (newLength < this.$byteOffset + bytes);\n\n    // copy bytes to new buffer\n    const newBuffer = new ArrayBuffer(newLength);\n    const currentData = new Uint8Array(this._$dataView.buffer, this._$dataView.byteOffset, currentAlloc);\n    new Uint8Array(newBuffer).set(currentData);\n\n    // update the view\n    this._$buf = newBuffer;\n    this._$dataView = new DataView(newBuffer);\n\n    // increment the pointer\n    const i = this.$byteOffset; // copy\n    this.$byteOffset += bytes;\n\n    return i;\n  }\n}\n","import { $fromf16 } from \"./float16\";\n\n/**\n * Wraps a buffer with a read head pointer.\n *\n * @internal\n */\nexport class BufferReader {\n  public i: number;\n  private _$dataView: DataView;\n\n  public constructor(b: Uint8Array | ArrayBufferView | ArrayBuffer, byteOffset?: number) {\n    this._$dataView = b instanceof ArrayBuffer ? new DataView(b) : new DataView(b.buffer, b.byteOffset, b.byteLength);\n    this.i = byteOffset ?? 0;\n  }\n\n  /** Read the next byte, without moving the read head pointer. */\n  public $peek(): number {\n    return this._$dataView.getUint8(this.i);\n  }\n\n  /** used to skip bytes for reading type headers. */\n  public $skipByte(): void {\n    this.i++;\n  }\n\n  // ----- Readers: -----\n\n  public $readUint8(): number {\n    return this._$dataView.getUint8(this.i++);\n  }\n\n  public $readUint16(): number {\n    const r = this._$dataView.getUint16(this.i); // big-endian\n    this.i += 2;\n    return r;\n  }\n\n  public $readUint32(): number {\n    const r = this._$dataView.getUint32(this.i); // big-endian\n    this.i += 4;\n    return r;\n  }\n\n  public $readInt8(): number {\n    return this._$dataView.getInt8(this.i++);\n  }\n\n  public $readInt16(): number {\n    const r = this._$dataView.getInt16(this.i, true);\n    this.i += 2;\n    return r;\n  }\n\n  public $readInt32(): number {\n    const r = this._$dataView.getInt32(this.i, true);\n    this.i += 4;\n    return r;\n  }\n\n  public $readFloat16(): number {\n    const r = this._$dataView.getUint16(this.i);\n    this.i += 2;\n    return $fromf16(r);\n  }\n\n  public $readFloat32(): number {\n    const r = this._$dataView.getFloat32(this.i, true);\n    this.i += 4;\n    return r;\n  }\n\n  public $readFloat64(): number {\n    const r = this._$dataView.getFloat64(this.i, true);\n    this.i += 8;\n    return r;\n  }\n\n  /** @throws RangeError if exceeds length */\n  public $readBuffer(bytes: number): Uint8Array {\n    if (this.i + bytes > this._$dataView.byteLength) {\n      throw new RangeError();\n    }\n\n    const view = new Uint8Array(this._$dataView.buffer, this.i, bytes);\n    this.i += bytes;\n\n    return view;\n  }\n}\n","/**\n * Field types for defining encoding formats.\n *\n * @see [Get started: Types](https://github.com/reececomo/tinybuf/blob/main/docs/get_started.md#types)\n */\nexport const enum Type {\n  /**\n   * Unsigned integer (1 - 8 bytes).\n   * - 0 → 127 = 1 byte\n   * - 128 → 16,384 = 2 bytes\n   * - 16,385 → 536,870,911 = 4 bytes\n   * - 536,870,912 → `Number.MAX_SAFE_INTEGER` = 8 bytes\n   */\n  UInt,\n\n  /** Unsigned 8-bit integer (between 0 and 255, 1 byte). */\n  UInt8,\n\n  /** Unsigned 16-bit integer (between 0 and 65,535, 2 bytes). */\n  UInt16,\n\n  /** Unsigned 32-bit integer (between 0 and 4,294,967,295, 4 bytes). */\n  UInt32,\n\n  /**\n   * Signed integer (1 - 8 bytes).\n   * - 0 → ±64 = 1 byte\n   * - ±65 → ±8,192 = 2 bytes\n   * - ±8,193 → ±268,435,456 = 4 bytes\n   * - ±268,435,457 → ±`Number.MAX_SAFE_INTEGER` = 8 bytes\n   */\n  Int,\n\n  /** Signed 1 byte integer (between -127 and 127). */\n  Int8,\n\n  /** Signed 2 byte integer (between -32,767 and 32,767). */\n  Int16,\n\n  /** Signed 4 byte integer (between -2,147,483,647 and 2,147,483,647). */\n  Int32,\n\n  /** Default JavaScript `number` type. Floating-point number (64-bit, double precision, 8 bytes). */\n  Float64,\n\n  /** Floating-point number (32-bit, single precision, 4 bytes). */\n  Float32,\n\n  /**\n   * Floating-point number (16-bit, half precision, 2 bytes).\n   *\n   * **Warning:** Low precision; maximum range: ±65,504.\n   */\n  Float16,\n\n  /** A signed scalar between -1.00 and 1.00 (1 byte). */\n  Scalar,\n\n  /** An unsigned scalar between 0.00 and 1.00 (1 byte). */\n  UScalar,\n\n  /**\n   * Boolean value (1 byte).\n   * @see {Bools} for packing multiple booleans into a single byte.\n   */\n  Bool,\n\n  /** Any array of booleans (1 bit overhead, encoded as UInt). */\n  Bools,\n\n  /** A string (1† byte header + string bytes). */\n  String,\n\n  /** Any Uint8Array, ArrayBuffer or ArrayBufferLike value (1† byte header + buffer bytes). */\n  Buffer,\n\n  /** Any JSON-serializable data. Encodes as a UTF-8 string. */\n  JSON,\n\n  /** JavaScript regular expression. */\n  RegExp,\n\n  /**\n   * JavaScript date object.\n   *\n   * Encoded as an 8 byte (64-bit) integer UTC timestamp from as the number\n   * of milliseconds since the Unix Epoch (January 1, 1970, 00:00:00 UTC).\n   *\n   * @see {Date}\n   */\n  Date,\n}\n\n/**\n * Mappings for the value types.\n */\nexport type ValueTypes = {\n  // Floats\n  [Type.Float16]: number;\n  [Type.Float32]: number;\n  [Type.Float64]: number;\n  // Integers\n  [Type.Int]: number;\n  [Type.Int8]: number;\n  [Type.Int16]: number;\n  [Type.Int32]: number;\n  [Type.UInt]: number;\n  [Type.UInt8]: number;\n  [Type.UInt16]: number;\n  [Type.UInt32]: number;\n  // Scalar\n  [Type.UScalar]: number;\n  [Type.Scalar]: number;\n  // Boolean\n  [Type.Bool]: boolean;\n  [Type.Bools]: boolean[];\n  // Other\n  [Type.String]: string;\n  [Type.Date]: Date;\n  [Type.RegExp]: RegExp;\n  [Type.JSON]: any;\n  [Type.Buffer]: Uint8Array | ArrayBuffer | ArrayBufferView;\n};\n\n/** @throws any error too */\nexport type ValidationFn<T> = (x: T) => undefined | boolean | Error;\nexport type TransformFn<T> = (x: T) => T;\nexport type Transforms<T> = TransformFn<T> | [preEncode: TransformFn<T>] | [preEncode: TransformFn<T> | undefined, postDecode: TransformFn<T> | undefined];\n\n/**\n * A wrapper around any Type definition that declares it as optional.\n */\nexport class OptionalType<T extends FieldDefinition> {\n  public constructor(public type: T) {}\n}\n\n/**\n * Wrap any definition as optional.\n */\nexport function optional<T extends FieldDefinition>(t: T): OptionalType<T> {\n  return new OptionalType(t);\n}\n\n/**\n * A definition for an object binary encoder.\n */\nexport type EncoderDefinition = {\n  [key: string]: FieldDefinition | OptionalType<FieldDefinition>;\n};\n\n/**\n * Definition for an object-field binary encoder.\n */\nexport type FieldDefinition = keyof ValueTypes | [keyof ValueTypes] | EncoderDefinition | [EncoderDefinition] | OptionalType<FieldDefinition>;\n\n/**\n * The resulting type of the decoded data, based on the encoder definition.\n */\nexport type InferredDecodedType<EncoderType extends EncoderDefinition> = {\n  [EKey in keyof EncoderType as EncoderType[EKey] extends OptionalType<any> ? never : EKey]: EncoderType[EKey] extends keyof ValueTypes\n      ? ValueTypes[EncoderType[EKey]]\n      : EncoderType[EKey] extends [keyof ValueTypes]\n        ? Array<ValueTypes[EncoderType[EKey][0]]>\n        : EncoderType[EKey] extends EncoderDefinition\n          ? InferredDecodedType<EncoderType[EKey]>\n          : EncoderType[EKey] extends [EncoderDefinition]\n            ? Array<InferredDecodedType<EncoderType[EKey][number]>>\n            : never;\n} & {\n  [EKey in keyof EncoderType as EncoderType[EKey] extends OptionalType<any> ? EKey : never]?: EncoderType[EKey] extends OptionalType<infer OptionalValue extends keyof ValueTypes>\n    ? ValueTypes[OptionalValue] | undefined\n    : EncoderType[EKey] extends OptionalType<infer OptionalValue extends [keyof ValueTypes]>\n      ? Array<ValueTypes[OptionalValue[0]]> | undefined\n      : EncoderType[EKey] extends OptionalType<infer OptionalValue extends EncoderDefinition>\n        ? InferredDecodedType<OptionalValue> | undefined\n        : never;\n};\n\nexport type InferredTransformConfig<EncoderType extends EncoderDefinition> = {\n [EKey in keyof EncoderType]?: EncoderType[EKey] extends keyof ValueTypes\n     ? Transforms<ValueTypes[EncoderType[EKey]]>\n     : EncoderType[EKey] extends [keyof ValueTypes]\n       ? Transforms<ValueTypes[EncoderType[EKey][0]]>\n       : EncoderType[EKey] extends EncoderDefinition\n         ? InferredTransformConfig<EncoderType[EKey]>\n         : EncoderType[EKey] extends [EncoderDefinition]\n           ? InferredTransformConfig<EncoderType[EKey][number]>\n           : EncoderType[EKey] extends OptionalType<infer OptionalValue extends keyof ValueTypes>\n            ? Transforms<ValueTypes[OptionalValue]>\n            : EncoderType[EKey] extends OptionalType<infer OptionalValue extends [keyof ValueTypes]>\n              ? Transforms<ValueTypes[OptionalValue[0]]>\n              : EncoderType[EKey] extends OptionalType<infer OptionalValue extends EncoderDefinition>\n                ? InferredTransformConfig<OptionalValue> | undefined\n                : never;\n};\n\nexport type InferredValidationConfig<EncoderType extends EncoderDefinition> = {\n [EKey in keyof EncoderType]?: EncoderType[EKey] extends keyof ValueTypes\n     ? ValidationFn<ValueTypes[EncoderType[EKey]]>\n     : EncoderType[EKey] extends [keyof ValueTypes]\n       ? ValidationFn<ValueTypes[EncoderType[EKey][0]]>\n       : EncoderType[EKey] extends EncoderDefinition\n         ? InferredValidationConfig<EncoderType[EKey]>\n         : EncoderType[EKey] extends [EncoderDefinition]\n           ? InferredValidationConfig<EncoderType[EKey][number]>\n           : EncoderType[EKey] extends OptionalType<infer OptionalValue extends keyof ValueTypes>\n            ? ValidationFn<ValueTypes[OptionalValue]>\n            : EncoderType[EKey] extends OptionalType<infer OptionalValue extends [keyof ValueTypes]>\n              ? ValidationFn<ValueTypes[OptionalValue[0]]>\n              : EncoderType[EKey] extends OptionalType<infer OptionalValue extends EncoderDefinition>\n                ? InferredValidationConfig<OptionalValue> | undefined\n                : never;\n};\n","import { CODERS } from './lib/coders';\nimport * as coders from './lib/coders';\nimport { $hashCode, $strToHashCode } from './lib/hashCode';\nimport { peekHeader, peekHeaderStr } from './lib/peek';\nimport { BufferWriter } from './lib/BufferWriter';\nimport { BufferReader } from './lib/BufferReader';\nimport {\n  InferredDecodedType,\n  EncoderDefinition,\n  Type,\n  OptionalType,\n  InferredTransformConfig,\n  InferredValidationConfig,\n  ValidationFn,\n  Transforms,\n  FieldDefinition\n} from './Type';\nimport { EncodeError } from './lib/errors';\nimport { cfg } from './config';\n\nexport type FormatHeader = string | number;\n\n/**\n * Decoded object types for a given binary format.\n * @example let onData = (data: Decoded<typeof MyBufferFormat>) => {...};\n */\nexport type Decoded<FromBufferFormat> = FromBufferFormat extends BufferFormat<infer EncoderType, any> ? InferredDecodedType<EncoderType> : never;\n\n/**\n * Defines a format for encoding/decoding binary buffers.\n *\n * Optionally customize the identifier, either as a 2-byte string, an unsigned integer (0 -> 65,535), or as `null` to disable entirely.\n *\n * @example\n * const MyFormat = defineFormat({ ... });\n * const MyFormat = defineFormat('ab', { ... });\n * const MyFormat = defineFormat(1234, { ... });\n * const MyFormat = defineFormat(null, { ... });\n */\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(def: T): BufferFormat<T, HeaderType>;\n/**\n * Defines a format for encoding/decoding binary buffers.\n *\n * Optionally customize the identifier, either as a 2-byte string, an unsigned integer (0 -> 65,535), or as `null` to disable entirely.\n *\n * @example\n * const MyFormat = defineFormat({ ... });\n * const MyFormat = defineFormat('ab', { ... });\n * const MyFormat = defineFormat(1234, { ... });\n * const MyFormat = defineFormat(null, { ... });\n */\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(h: HeaderType | null, def: T): BufferFormat<T, HeaderType>;\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(a?: HeaderType | T, b?: T): BufferFormat<T, HeaderType> {\n  return a !== null && typeof a === 'object'\n    ? new BufferFormat<T, HeaderType>(a as T)\n    : new BufferFormat<T, HeaderType>(b as T, a as HeaderType);\n}\n\nfunction isValidHeader(h: FormatHeader): boolean {\n  if (typeof h === 'number') return Number.isInteger(h) && h >= 0 && h <= 65_535;\n  if (typeof h === 'string') return new TextEncoder().encode(h).byteLength === 2;\n  return false;\n}\n\n/**\n * BufferFormat is a utility class for encoding and decoding binary data based\n * on a provided encoding format.\n *\n * @see {header}\n * @see {encode(data)}\n * @see {decode(binary)}\n */\nexport class BufferFormat<EncoderType extends EncoderDefinition, HeaderType extends FormatHeader = number> {\n  /** @internal */\n  private static _$globalEncodingBuffer?: ArrayBuffer;\n\n  /**\n   * A unique identifier encoded as the first 2 bytes (or `undefined` if headerless).\n   *\n   * @see {peekHeader(...)}\n   * @see {peekHeaderStr(...)}\n   */\n  public readonly header!: HeaderType;\n\n  /** @internal */\n  private readonly _$header!: number; // always uint16 vesion\n  /** @internal */\n  private readonly _$type!: Type;\n  /** @internal */\n  private readonly _$fields!: Field[];\n  /** @internal */\n  private readonly _$fieldsMap!: Map<string, Field>;\n\n  /** @internal */\n  private _$format?: string;\n  /** @internal */\n  private _$transforms?: Transforms<any> | undefined;\n  /** @internal */\n  private _$validate?: ValidationFn<any> | undefined;\n  /** @internal */\n  private _$hasValidationOrTransforms = false;\n  /** @internal */\n  private _$writer?: BufferWriter;\n\n  public constructor(\n    def: EncoderType,\n    header?: HeaderType | null,\n  ) {\n    // set definition\n    if (def instanceof OptionalType) {\n      throw new TypeError(\"Invalid encoding format: Root object cannot be optional.\");\n    }\n    else if (def !== undefined && typeof def === 'number') {\n      this._$type = def;\n    }\n    else if (def instanceof Object) {\n      this._$type = undefined; // object\n      this._$fieldsMap = new Map();\n      this._$fields = Object.keys(def).map((name) => {\n        const f = new Field(name, def[name]);\n        this._$fieldsMap.set(name, f);\n        return f;\n      });\n\n      // set headers\n      if (header === undefined) {\n        this.header = $hashCode(this.f) as HeaderType; // automatic\n        this._$header = this.header as number;\n      }\n      else if (header === null) {\n        this.header = undefined; // headerless\n        this._$header = undefined;\n      }\n      else if (isValidHeader(header)) {\n        this.header = header; // manual\n        this._$header = typeof header === 'number' ? header : $strToHashCode(header);\n      }\n      else {\n        throw new TypeError(`Header should be an integer between 0 and 65535, a 2-byte string, or null. Received: ${header}`);\n      }\n    }\n    else {\n      throw new TypeError(\"Invalid encoding format: Must be an object, or a known coder type.\");\n    }\n  }\n\n  // ----- Static methods: -----\n\n  /**\n   * Read the header of a buffer as a number.\n   *\n   * @see {header}\n   * @throws {RangeError} if buffer size < 2\n   */\n  public static peekHeader = peekHeader;\n\n  /**\n   * Read the header of a buffer as a string.\n   *\n   * @see {header}\n   * @throws {RangeError} if buffer size < 2\n   */\n  public static peekHeaderStr = peekHeaderStr;\n\n  // ----- Accessors: -----\n\n  /**\n   * @example \"{uint8,str[]?}\"\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  private get f(): string {\n    if (this._$format === undefined) {\n      this._$format = this._$fields !== undefined\n        ? `{${this._$fields.map(v => v.f).join(',')}}`\n        : `${this._$type}`;\n    }\n\n    return this._$format;\n  }\n\n  /** @internal */\n  private static _$initWriter(): BufferWriter {\n    if (cfg.useGlobalEncodingBuffer) {\n      if (!BufferFormat._$globalEncodingBuffer) {\n        // lazy init: global encoding buffer created at max size\n        BufferFormat._$globalEncodingBuffer = new ArrayBuffer(cfg.encodingBufferMaxSize);\n      }\n\n      return new BufferWriter(BufferFormat._$globalEncodingBuffer);\n    }\n\n    return new BufferWriter(cfg.encodingBufferInitialSize);\n  }\n\n  /**\n   * Encode an object to bytes.\n   *\n   * **Warning:** Returns an unsafe view into the encoding buffer. Pass this reference to preserve\n   * performance, and to minimize memory allocation and fragmentation.\n   *\n   * @param data - data to encode\n   * @param safe - (default: `setTinybufConfig().safe`) safely copy bytes, instead of returning a pointer to the encoded buffer\n   *\n   * @returns An Uint8Array view of the encoded bytes\n   * @throws if fails to encode value to schema\n   */\n  public encode<DecodedType extends InferredDecodedType<EncoderType>>(\n    data: DecodedType,\n    safe?: boolean,\n  ): Uint8Array {\n    // lazy init\n    if (!this._$writer) this._$writer = BufferFormat._$initWriter();\n    this._$writer.$byteOffset = 0; // reset\n    if (this._$hasValidationOrTransforms) data = this._$preprocess(data);\n    this._$write(data, this._$writer, '');\n\n    if (safe ?? cfg.safe) {\n      return this._$writer.$asCopy();\n    }\n\n    return this._$writer.$asView();\n  }\n\n  /**\n   * Decode binary data to an object.\n   * @throws if fails to decode bytes to schema.\n   */\n  public decode<DecodedType = InferredDecodedType<EncoderType>>(b: Uint8Array | ArrayBufferView | ArrayBuffer): DecodedType {\n    return this._$read(new BufferReader(b, this.header === undefined ? 0 : 2));\n  }\n\n  /**\n   * Set additional transform functions to apply before encoding and after decoding.\n   */\n  public setTransforms(transforms: InferredTransformConfig<EncoderType> | Transforms<any>): this {\n    this._$hasValidationOrTransforms = true;\n\n    if (transforms instanceof Function || (Array.isArray(transforms) && transforms[0] instanceof Function)) {\n      this._$transforms = transforms;\n    }\n    else {\n      for (const name of Object.keys(transforms)) {\n        const field = this._$fieldsMap.get(name);\n        if (!field) {\n          throw new TypeError(`Failed to set transforms for field '${name}'`);\n        }\n\n        // Set validation for object.\n        field.$coder.setTransforms(transforms[name]);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Set additional validation rules which are applied on encode() and decode().\n   *\n   * - Validation functions should throw an error, return an error, or return boolean false.\n   * - Anything else is treated as successfully passing validation.\n   */\n  public setValidation(validations: InferredValidationConfig<EncoderType> | ValidationFn<any>): this {\n    this._$hasValidationOrTransforms = true;\n\n    if (validations instanceof Function) {\n      this._$validate = validations;\n    }\n    else {\n      for (const name of Object.keys(validations)) {\n        const field = this._$fieldsMap.get(name);\n        if (!field) {\n          throw new TypeError(`Failed to set validation function for field '${name}'`);\n        }\n\n        field.$coder.setValidation(validations[name]);\n      }\n    }\n\n    return this;\n  }\n\n  // ----- Implementation: -----\n\n  /**\n   * @param value\n   * @param bw\n   * @param path\n   * @throws if the value is invalid\n   *\n   * @internal\n   */\n  private _$write(value: { [x: string]: any; }, bw: BufferWriter, path: string): void {\n    // write header\n    if (this._$header !== undefined) this._$writer.$writeUInt16(this._$header);\n\n    // write scalar\n    if (this._$type !== undefined) {\n      const safeValue = (this._$validate || this._$transforms) ? this._$preprocess(value) : value;\n\n      return CODERS[this._$type].$write(safeValue, bw, path);\n    }\n\n    // Check for object type\n    if (!value || typeof value !== 'object') {\n      throw new TypeError(`Expected an object at ${path}`);\n    }\n\n    // Write each field\n    for (const field of this._$fields) {\n      const subpath = path ? `${path}.${field.$name}` : field.$name;\n      const subValue = value[field.$name];\n\n      if (field.$isOptional) {\n\n        // add 'presence' flag\n        if (subValue === undefined || subValue === null) {\n          coders.boolCoder.$write(false, bw);\n          continue;\n        }\n        else {\n          coders.boolCoder.$write(true, bw);\n        }\n      }\n\n      if (!field.$isArray) {\n        // scalar field\n        field.$coder._$write(subValue, bw, subpath);\n        continue;\n      }\n\n      // Array field\n      this._$writeArray(subValue, bw, subpath, field.$coder);\n    }\n  }\n\n  /**\n   * pre-process: validation and/or transforms\n   * @internal\n   */\n  private _$preprocess<T extends Record<string, any>>(data: T): T {\n    if (this._$validate && this._$validate(data) === false) {\n      throw new Error('failed validation');\n    }\n\n    if (this._$transforms instanceof Function) {\n      return this._$transforms(data);\n    }\n    else if (Array.isArray(this._$transforms) && this._$transforms[0] instanceof Function) {\n      return this._$transforms[0](data);\n    }\n\n    return data;\n  }\n\n  /**\n   * post-process: validation and/or transforms\n   * @internal\n   */\n  private _$postprocess<T extends Record<string, any>>(data: T): T {\n    if (Array.isArray(this._$transforms) && this._$transforms[1] instanceof Function) {\n      data = this._$transforms[1](data);\n    }\n\n    if (this._$validate instanceof Function) {\n      this._$validate(data);\n    }\n\n    return data;\n  }\n\n  /**\n   * This function will be executed only the first time\n   * After that, we'll compile the read routine and add it directly to the instance\n   * @param state\n   * @returns\n   * @throws if fails\n   *\n   * @internal\n   */\n  private _$read<DecodedType = InferredDecodedType<EncoderType>>(state: BufferReader): DecodedType {\n    // This function will be executed only the first time to compile the read routine.\n    // After that, we'll compile the read routine and add it directly to the instance\n\n    // Update the read method implementation.\n    this._$read = this._$compileFormatReadFn();\n\n    return this._$read(state);\n  }\n\n  /**\n   * Generate read function code for this coder.\n   *\n   * @example\n   * // new Type({a:'int', 'b?':['string']}) would emit:\n   *\n   * `return {\n   *   a: this._readField(0, state),\n   *   b: this._readField(1, state),\n   * }`\n   *\n   * @internal\n   */\n  private _$makeObjectReader(): string {\n    const fieldsStr: string = this._$fields\n      .map(({ $name: name }, i) => `${name}:this.${this._$readField.name}(${i},state)`)\n      .join(',');\n\n    return `return{${fieldsStr}}`;\n  }\n\n  /**\n   * Read an individual field.\n   * @internal\n   */\n  private _$readField(fieldId: number, state: BufferReader): any {\n    const field = this._$fields[fieldId];\n\n    if (field.$isOptional && !this._$readOptional(state)) {\n      return undefined;\n    }\n\n    if (field.$isArray) {\n      return this._$readArray(field.$coder, state);\n    }\n\n    return field.$coder._$read(state);\n  }\n\n  /**\n   * Compile the decode() method for this object.\n   *\n   * @internal\n   */\n  private _$compileFormatReadFn<DecodedType = InferredDecodedType<EncoderType>>(): (state: BufferReader) => DecodedType {\n    // scalar type\n    if (this._$type !== undefined) {\n      return this._$hasValidationOrTransforms\n        ? (s) => this._$postprocess(CODERS[this._$type].$read(s))\n        : CODERS[this._$type].$read;\n    }\n\n    // scalar type\n    return new Function('state', this._$makeObjectReader()) as any;\n  }\n\n  /**\n   * @param value\n   * @param data\n   * @param path\n   * @param type\n   * @throws if the value is invalid\n   *\n   * @internal\n   */\n  private _$writeArray(value: string | any[], data: any, path: string, type: BufferFormat<any, any>): void {\n    if (!Array.isArray(value)) {\n      throw new EncodeError(`Array<${type._$type}>`, data, path);\n    }\n\n    let i: string | number, len: number;\n    len = value.length;\n    coders.uintCoder.$write(len, data);\n    for (i = 0; i < len; i++) {\n      type._$write(value[i], data, path + '.' + i);\n    }\n  }\n\n  /**\n   * @throws if invalid data\n   *\n   * @internal\n   */\n  private _$readArray<T extends EncoderDefinition>(type: BufferFormat<T, any>, state: any): Array<T> {\n    const arr = new Array(coders.uintCoder.$read(state));\n    for (let j = 0; j < arr.length; j++) {\n      arr[j] = type._$read(state);\n    }\n    return arr;\n  }\n\n  /** @internal */\n  private _$readOptional(state: BufferReader): boolean {\n    return coders.boolCoder.$read(state);\n  }\n}\n\n/**\n * Parses and represents an object field.\n *\n * @internal\n */\nclass Field {\n  public readonly $name: string;\n  public readonly $coder: BufferFormat<any>;\n  public readonly $isOptional: boolean;\n  public readonly $isArray: boolean;\n\n  private _$formatString?: string;\n\n  public constructor(name: string, rawType: FieldDefinition) {\n    this.$isOptional = rawType instanceof OptionalType;\n    let type = rawType instanceof OptionalType ? rawType.type : rawType;\n    this.$name = name;\n\n    if (Array.isArray(type)) {\n      if (type.length !== 1) {\n        throw new TypeError('Invalid array definition, it must have exactly one element');\n      }\n\n      type = type[0];\n      this.$isArray = true;\n    }\n    else {\n      this.$isArray = false;\n    }\n\n    this.$coder = new BufferFormat<any>(type, null);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  public get f(): string {\n    if (this._$formatString === undefined) {\n      this._$formatString = `${(this.$coder as any).f}${this.$isArray ? '[]' : ''}${this.$isOptional ? '?' : ''}`;\n    }\n\n    return this._$formatString;\n  }\n}\n"],"names":["TinybufError","Error","EncodeError","constructor","a","b","c","super","DecodeError","summary","cause","message","this","stack","$hashCode","str","hash","i","length","charCodeAt","$strToHashCode","$hashCodeToStr","hashCode","String","fromCharCode","Math","floor","peekHeader","DataView","ArrayBuffer","buffer","getUint16","peekHeaderStr","bufferParser","BufferParser","_$formats","Map","processBuffer","f","data","cb","header","has","get","decode","e","on","format","callback","overwritePrevious","set","ignore","forEach","clear","$floor","$ceil","ceil","$clamp","value","min","max","$roundTowardZero","x","$roundAwayFromZero","uscalround","$fromuscal8","$touscal8","scalround","$fromscal8","$toscal8","mask","pad","slice","reduce","n","unmask","len","clz32","Array","from","_","encoder","TextEncoder","decoder","TextDecoder","MAX_VARINT32","POW_32","uintCoder","$write","$writeUInt8","$writeUInt16","$writeUInt32","$read","state","firstByte","$peek","$readUint32","$readUint16","$skipByte","intCoder","intValue","dateCoder","path","getTime","Date","stringCoder","bufferCoder","encode","y","byteLength","$writeBuffer","$readBuffer","boolCoder","$readUint8","boolsCoder","jsonCoder","JSON","stringify","parse","regexCoder","global","ignoreCase","multiline","source","g","m","RegExp","CODERS","$writeInt8","$readInt8","$writeInt16","$readInt16","$writeInt32","$readInt32","$writeFloat64","$readFloat64","$writeFloat32","$readFloat32","$writeFloat16","$readFloat16","setTinybufConfig","cfg","Object","assign","safe","useGlobalEncodingBuffer","encodingBufferMaxSize","encodingBufferInitialSize","encodingBufferIncrement","f16round","$fromf16","$tof16","Float32Array","Int32Array","s","z","Float64Array","pow","Infinity","NaN","BufferWriter","$byteOffset","_$buf","_$autoResize","_$dataView","$asView","Uint8Array","$asCopy","setInt8","_$alloc","setInt16","setInt32","setUint8","setUint16","setUint32","setFloat32","setFloat64","byteOffset","readView","bytes","currentAlloc","minRequestedSize","newLength","newBuffer","currentData","BufferReader","getUint8","r","getUint32","getInt8","getInt16","getInt32","getFloat32","getFloat64","RangeError","view","OptionalType","type","optional","t","defineFormat","BufferFormat","def","_$hasValidationOrTransforms","TypeError","undefined","_$type","_$fieldsMap","_$fields","keys","map","name","Field","_$header","h","Number","isInteger","_$format","v","join","_$initWriter","_$globalEncodingBuffer","_$writer","_$preprocess","_$write","_$read","setTransforms","transforms","Function","isArray","_$transforms","field","$coder","setValidation","validations","_$validate","bw","safeValue","subpath","$name","subValue","$isOptional","coders.boolCoder","$isArray","_$writeArray","_$postprocess","_$compileFormatReadFn","_$makeObjectReader","_$readField","fieldId","_$readOptional","_$readArray","coders.uintCoder","arr","j","rawType","_$formatString"],"mappings":"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"}