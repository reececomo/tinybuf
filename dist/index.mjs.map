{"version":3,"file":"index.mjs","sources":["../src/core/lib/errors.ts","../src/core/lib/hashCode.ts","../src/core/lib/peek.ts","../src/core/BufferParser.ts","../src/core/lib/math.ts","../src/core/lib/scalar.ts","../src/core/lib/boolArray.ts","../src/core/lib/coders.ts","../src/core/settings.ts","../src/core/lib/float16.ts","../src/core/lib/BufferWriter.ts","../src/core/lib/BufferReader.ts","../src/core/Type.ts","../src/core/BufferFormat.ts"],"sourcesContent":["export class TinybufError extends Error {}\n\nexport class EncodeError extends TinybufError {\n  public constructor(message: string)\n  public constructor(expectedType: string, value: any, path: string)\n  public constructor(a: string, b?: any, c?: string) {\n    super(`Failed to encode ${b} as '${a}'${c ? ` (path: '${c}')` : ''}`);\n  }\n}\n\nexport class DecodeError extends TinybufError {\n  public constructor(\n    summary: string,\n    public readonly cause: Error,\n  ) {\n    super(`${summary}: ${cause.message}`);\n    this.stack = cause.stack;\n  }\n}\n","/**\n * DJB2 hash algorithm (modified for 16-bit uints).\n *\n * DJB2 is a simple and widely used non-cryptographic\n * hash function created by Daniel J. Bernstein.\n *\n * @returns 16-bit unsigned integer\n */\nexport function $hashCode(str: string): number {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = (hash * 33) ^ str.charCodeAt(i);\n  }\n  return hash & 0xFFFF; // Ensure the result is a Uint16\n}\n\n/**\n * Returns an unsigned 16-bit integer hashcode for some string.\n * Prefers 2 character string.\n *\n * @returns A UInt16 between 0 and 65535 (inclusive).\n */\nexport function $strToHashCode(str: string): number {\n  if (str.length !== 2) return $hashCode(str);\n  return str.charCodeAt(0) * 256 + str.charCodeAt(1);\n}\n\n/**\n * Convert a UInt16 hashcode to a 2-byte string.\n */\nexport function $hashCodeToStr(hashCode: number): string {\n  return String.fromCharCode(Math.floor(hashCode / 256)) + String.fromCharCode(hashCode % 256);\n}\n","import { $hashCodeToStr } from \"./hashCode\";\n\n\n/**\n * Read the header bytes of a buffer as a number.\n *\n * @throws {RangeError} if buffer size < 2\n */\nexport function peekHeader(b: ArrayBuffer | ArrayBufferView): number {\n  return new DataView(b instanceof ArrayBuffer ? b : b.buffer).getUint16(0, false);\n}\n\n/**\n * Read the header bytes of a buffer as a string.\n *\n * @throws {RangeError} if buffer length < 2\n */\nexport function peekHeaderStr(b: ArrayBuffer | ArrayBufferView): string {\n  return $hashCodeToStr(peekHeader(b));\n}\n","import { BufferFormat } from \"./BufferFormat\";\nimport { EncoderDefinition, InferredDecodedType } from \"./Type\";\nimport { DecodeError, TinybufError } from \"./lib/errors\";\nimport { $hashCodeToStr, $strToHashCode } from \"./lib/hashCode\";\nimport { peekHeader } from \"./lib/peek\";\n\ntype AnyFormat = BufferFormat<any, any>;\ntype Uint16FormatHeader = number;\n\n/**\n * Small utility for registering and processing format handlers.\n *\n * @example\n * const myHandler = bufferParser()\n *   .on(FormatA, aData => {})\n *   .on(FormatB, bData => {});\n *\n * myHandler.processBuffer(bytes);\n */\nexport const bufferParser = (): BufferParserInstance => new BufferParserInstance();\n\nexport class BufferParserInstance {\n  /** @internal */\n  private _$formats = new Map<Uint16FormatHeader, [AnyFormat, (data: any) => any]>();\n\n  /**\n   * Decode an array buffer and trigger the relevant data handler.\n   *\n   * When passed an ArrayBufferView, accesses the underlying 'buffer' instance directly.\n   *\n   * @throws {TinybufError} if fails to decode, or no handler is registered\n   */\n  public processBuffer(b: ArrayBuffer | ArrayBufferView): void {\n    let f: any, data: any, cb: (data: any) => any;\n\n    try {\n      const header = peekHeader(b);\n\n      if (!this._$formats.has(header)) {\n        throw new TinybufError(`Unknown format: ${header} '${$hashCodeToStr(header)}')`);\n      }\n\n      [f, cb] = this._$formats.get(header);\n      data = f.decode(b);\n    }\n    catch (e) {\n      throw new DecodeError('Failed to decode', e);\n    }\n\n    cb(data);\n  }\n\n  /**\n   * Register a format handler.\n   */\n  public on<EncoderType extends EncoderDefinition, DecodedType = InferredDecodedType<EncoderType>>(\n    format: BufferFormat<EncoderType, string | number>,\n    callback: (data: DecodedType) => any,\n    overwritePrevious: boolean = false,\n  ): this {\n    if (format.header == null) {\n      throw new TinybufError('Format requires header');\n    }\n\n    const header = typeof format.header === 'string' ? $strToHashCode(format.header) : format.header;\n\n    if (this._$formats.has(header) && !overwritePrevious) {\n      throw new TinybufError(`Format header collision: ${format.header}`);\n    }\n\n    this._$formats.set(header, [format, callback]);\n\n    return this;\n  }\n\n  /** Register a format (or formats) that are recognized. */\n  public ignore(...format: AnyFormat[]): this {\n    format.forEach(f => this.on(f, () => {}, true));\n    return this;\n  }\n\n  /** Clears all registered formats and handlers. */\n  public clear(): void {\n    this._$formats.clear();\n  }\n}\n","/** Clamp a number to a range. */\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max);\n}\n\n/** Round toward zero */\nexport function r2z(x: number): number {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n}\n/** Round away zero */\nexport function raz(x: number): number {\n  return x < 0 ? Math.floor(x) : Math.ceil(x);\n}\n","import { clamp, r2z, raz } from \"./math\";\n\n/** @returns A UInt8 bitmask representation. */\nexport function toUScalar8(uScalar: number): number {\n  return Number.isNaN(uScalar) ? 255 : clamp(127 + r2z(uScalar * 254 - 127), 0, 254);\n}\n\n/** @returns A UInt8 bitmask representation. */\nexport function toScalar8(scalar: number): number {\n  return Number.isNaN(scalar) ? 255 : clamp(r2z(scalar * 127), -127, 127) + 127;\n}\n\n/** @returns An unsigned scalar between 0.0 and 1.0. */\nexport function fromUScalar8(uInt8: number): number {\n  // Make symmetric: (0.5 + round((uint8 - 127) / 254 * 100)) / 100\n  return uInt8 === 255 ? NaN : clamp((raz((uInt8 - 127) * 0.3937007874015748) + 50) * 0.01, 0, 1);\n}\n\n/** @returns A signed scalar between -1.0 and 1.0. */\nexport function fromScalar8(uInt8: number): number {\n  // Make symmetric: round((uint8 - 127) / 127 * 100) / 100\n  return uInt8 === 255 ? NaN : clamp(raz((uInt8 - 127) * 0.787401574803149) * 0.01, -1, 1);\n}\n\n/**\n * Quantize a number to an 8-bit scalar between 0.0 and 1.0.\n *\n * @param doubleFloat A number.\n * @returns A number (double) in its closest signed scalar representation.\n */\nexport function uScalarRound(doubleFloat: number): number {\n  return fromUScalar8(toUScalar8(doubleFloat));\n}\n\n/**\n * Quantize a number to an 8-bit signed scalar between -1.0 and 1.0.\n *\n * @param doubleFloat A number.\n * @returns A number (double) in its closest signed scalar representation.\n */\nexport function scalarRound(doubleFloat: number): number {\n  return fromScalar8(toScalar8(doubleFloat));\n}\n","/**\n * Encode a boolean array as an integer.\n * Modified version of: https://github.com/geckosio/typed-array-buffer-schema/blob/d1e2330c8910e29280ab59e92619e5019b6405d4/src/serialize.ts#L29\n */\nexport function $bools2Mask(bools: boolean[], length: number): number {\n  let str = '';\n  for (let i = 0; i < length; i++) {\n    str += +!!bools[i];\n  }\n  return parseInt(str, 2);\n}\n\n/**\n * Decode a boolean array as an integer.\n * Modified version of: https://github.com/geckosio/typed-array-buffer-schema/blob/d1e2330c8910e29280ab59e92619e5019b6405d4/src/serialize.ts#L39\n */\nexport function $mask2Bools(int: number, length: 8 | 16 | 32): boolean[] {\n  return [...(int >>> 0).toString(2).padStart(length, '0')].map(e => (e == '0' ? false : true));\n}\n\n\n/**\n * Encode a variable-sized boolean array as an integer.\n * Modified version of: https://github.com/geckosio/typed-array-buffer-schema/blob/d1e2330c8910e29280ab59e92619e5019b6405d4/src/serialize.ts#L29\n */\nexport function $vBools2Mask(bools: boolean[]): number {\n  let str = '';\n  for (let i = 0; i < bools.length; i++) {\n    str += +!!bools[i];\n  }\n  return parseInt(str, 2);\n}\n\n/**\n * Decode a variable-sized boolean array from an integer.\n * Modified version of: https://github.com/geckosio/typed-array-buffer-schema/blob/d1e2330c8910e29280ab59e92619e5019b6405d4/src/serialize.ts#L39\n */\nexport function $mask2vBools(u: number): boolean[] {\n  return [...(u >>> 0).toString(2)].map(e => (e == '0' ? false : true));\n}\n","import { BufferWriter } from './BufferWriter';\nimport { BufferReader } from './BufferReader';\nimport { r2z } from './math';\nimport {\n  fromUScalar8,\n  fromScalar8,\n  toUScalar8,\n  toScalar8\n} from './scalar';\nimport { EncodeError } from './errors';\nimport { Type } from '../Type';\nimport {\n  $bools2Mask,\n  $mask2Bools,\n  $mask2vBools,\n  $vBools2Mask\n} from './boolArray';\n\n// Pre-calculated constants\nconst MAX_AUTO_UINT8 = 128,\n  MAX_AUTO_UINT16 = 16_384,\n  MAX_AUTO_UINT32 = 536_870_912,\n  MAX_AUTO_INT8 = 64,\n  MAX_AUTO_INT16 = 8_192,\n  MAX_AUTO_INT32 = 268_435_456,\n  MAX_INT8 = 127,\n  MAX_INT16 = 32_767,\n  MAX_INT32 = 2_147_483_647,\n  MAX_UINT8 = 255,\n  MAX_UINT16 = 65_535,\n  MAX_UINT32 = 4_294_967_295,\n  POW_32 = 4_294_967_296;\n\nconst utf8Decoder = new TextDecoder('utf-8');\n\nexport interface BinaryTypeCoder<T, R = T> {\n  $write(value: T, data: BufferWriter, path?: string): void;\n  $read(state: BufferReader): R;\n}\n\n/**\n * Formats (big-endian):\n * 7b  0xxx xxxx\n * 14b  10xx xxxx  xxxx xxxx\n * 29b  110x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx\n * 61b  111x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx\n */\nexport const uintCoder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number' || value > Number.MAX_SAFE_INTEGER || value < 0) {\n      throw new EncodeError('uint', value, path);\n    }\n\n    if (value < MAX_AUTO_UINT8) {\n      data.$writeUInt8(r2z(value));\n    }\n    else if (value < MAX_AUTO_UINT16) {\n      data.$writeUInt16(r2z(value) + 0x8000);\n    }\n    else if (value < MAX_AUTO_UINT32) {\n      data.$writeUInt32(r2z(value) + 0xc0000000);\n    }\n    else {\n      // Split in two 32b uints\n      const uIntValue = r2z(value);\n      data.$writeUInt32(Math.floor(uIntValue / POW_32) + 0xe0000000);\n      data.$writeUInt32(uIntValue >>> 0);\n    }\n  },\n  $read: function (state) {\n    const firstByte = state.$peekUInt8();\n\n    if (!(firstByte & 0x80)) {\n      state.$skipByte();\n      return firstByte;\n    }\n    else if (!(firstByte & 0x40)) {\n      return state.$readUint16() - 0x8000;\n    }\n    else if (!(firstByte & 0x20)) {\n      return state.$readUint32() - 0xc0000000;\n    }\n    else {\n      return (state.$readUint32() - 0xe0000000) * POW_32 + state.$readUint32();\n    }\n  }\n};\n\nexport const uint8Coder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number' || value < 0 || value > MAX_UINT8) {\n      throw new EncodeError('uint8', value, path);\n    }\n    data.$writeUInt8(r2z(value));\n  },\n  $read: function (state) {\n    return state.$readUint8();\n  }\n};\n\nexport const uint16Coder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number' || value < 0 || value > MAX_UINT16) {\n      throw new EncodeError('uint16', value, path);\n    }\n    data.$writeUInt16(r2z(value));\n  },\n  $read: function (state) {\n    return state.$readUint16();\n  }\n};\n\nexport const uint32Coder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number' || value < 0 || value > MAX_UINT32) {\n      throw new EncodeError('uint32', value, path);\n    }\n    data.$writeUInt32(r2z(value));\n  },\n  $read: function (state) {\n    return state.$readUint32();\n  }\n};\n\n/**\n * Same formats as uintCoder.\n *\n * @see {uintCoder}\n */\nexport const intCoder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number' || value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER) {\n      throw new EncodeError('int', value, path);\n    }\n\n    if (value >= -MAX_AUTO_INT8 && value < MAX_AUTO_INT8) {\n      data.$writeUInt8(r2z(value) & 0x7f);\n    }\n    else if (value >= -MAX_AUTO_INT16 && value < MAX_AUTO_INT16) {\n      data.$writeUInt16((r2z(value) & 0x3fff) + 0x8000);\n    }\n    else if (value >= -MAX_AUTO_INT32 && value < MAX_AUTO_INT32) {\n      data.$writeUInt32((r2z(value) & 0x1fffffff) + 0xc0000000);\n    }\n    else {\n      const intValue = r2z(value);\n      // Split in two 32b uints\n      data.$writeUInt32((Math.floor(intValue / POW_32) & 0x1fffffff) + 0xe0000000);\n      data.$writeUInt32(intValue >>> 0);\n    }\n  },\n  $read: function (state) {\n    let firstByte = state.$peekUInt8(), i: number;\n\n    if (!(firstByte & 0x80)) {\n      state.$skipByte();\n      return (firstByte & 0x40) ? (firstByte | 0xffffff80) : firstByte;\n    }\n    else if (!(firstByte & 0x40)) {\n      i = state.$readUint16() - 0x8000;\n      return (i & 0x2000) ? (i | 0xffffc000) : i;\n    }\n    else if (!(firstByte & 0x20)) {\n      i = state.$readUint32() - 0xc0000000;\n      return (i & 0x10000000) ? (i | 0xe0000000) : i;\n    }\n    else {\n      i = state.$readUint32() - 0xe0000000;\n      i = (i & 0x10000000) ? (i | 0xe0000000) : i;\n      return i * POW_32 + state.$readUint32();\n    }\n  }\n};\n\nexport const int8Coder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number' || value < -MAX_INT8 || value > MAX_INT8) {\n      throw new EncodeError('int8', value, path);\n    }\n    data.$writeInt8(r2z(value));\n  },\n  $read: function (state) {\n    return state.$readInt8();\n  }\n};\n\nexport const int16Coder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number' || value < -MAX_INT16 || value > MAX_INT16) {\n      throw new EncodeError('int16', value, path);\n    }\n    data.$writeInt16(r2z(value));\n  },\n  $read: function (state) {\n    return state.$readInt16();\n  }\n};\n\nexport const int32Coder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number' || value < -MAX_INT32 || value > MAX_INT32) {\n      throw new EncodeError('int32', value, path);\n    }\n    data.$writeInt32(r2z(value));\n  },\n  $read: function (state) {\n    return state.$readInt32();\n  }\n};\n\n/**\n * 16-bit half precision float\n */\nexport const float16Coder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number') {\n      throw new EncodeError('number', value, path);\n    }\n    data.$writeFloat16(value);\n  },\n  $read: function (state) {\n    return state.$readFloat16();\n  }\n};\n\n/**\n * 32-bit single precision float\n */\nexport const float32Coder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number') {\n      throw new EncodeError('number', value, path);\n    }\n    data.$writeFloat32(value);\n  },\n  $read: function (state) {\n    return state.$readFloat32();\n  }\n};\n\n/**\n * 64-bit double precision float\n */\nexport const float64Coder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number') {\n      throw new EncodeError('number', value, path);\n    }\n    data.$writeFloat64(value);\n  },\n  $read: function (state) {\n    return state.$readFloat64();\n  }\n};\n\n/**\n * Scalar between 0.0 and 1.0.\n */\nexport const uscalarCoder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number') {\n      throw new EncodeError('number', value, path);\n    }\n    data.$writeUInt8(toUScalar8(value));\n  },\n  $read: function (state) {\n    return fromUScalar8(state.$readUint8());\n  }\n};\n\n/**\n * Signed scalar between -1.0 and 1.0.\n */\nexport const scalarCoder: BinaryTypeCoder<number> = {\n  $write: function (value, data, path) {\n    if (typeof value !== 'number') {\n      throw new EncodeError('number', value, path);\n    }\n    data.$writeUInt8(toScalar8(value));\n  },\n  $read: function (state) {\n    return fromScalar8(state.$readUint8());\n  }\n};\n\n/**\n * <uint_length> <buffer_data>\n */\nexport const stringCoder: BinaryTypeCoder<string> = {\n  $write: function (value, data, path) {\n    bufferCoder.$write(new TextEncoder().encode(value ?? ''), data, path);\n  },\n  $read: function (state) {\n    return utf8Decoder.decode(bufferCoder.$read(state));\n  }\n};\n\n/**\n * <uint_length> <buffer_data>\n */\nexport const bufferCoder: BinaryTypeCoder<ArrayBuffer | ArrayBufferView, Uint8Array> = {\n  $write: function (value, data, path) {\n    uintCoder.$write(value.byteLength, data, path);\n    data.$writeBuffer(value);\n  },\n  $read: function (state): Uint8Array {\n    return state.$readBuffer(uintCoder.$read(state));\n  }\n};\n\n/**\n * either 0x00 or 0x01\n */\nexport const boolCoder: BinaryTypeCoder<boolean> = {\n  $write: function (value, data) {\n    data.$writeUInt8(value ? 1 : 0);\n  },\n  $read: function (state) {\n    return state.$readUint8() !== 0;\n  }\n};\n\n/**\n * Encode exactly 8 booleans as a UInt8.\n */\nexport const bools8Coder: BinaryTypeCoder<boolean[]> = {\n  $write: function (value, data) {\n    data.$writeUInt8($bools2Mask(value, 8));\n  },\n  $read: function (state) {\n    return $mask2Bools(state.$readUint8(), 8);\n  }\n};\n\n/**\n * Encode exactly 16 booleans as a UInt16.\n */\nexport const bools16Coder: BinaryTypeCoder<boolean[]> = {\n  $write: function (value, data) {\n    data.$writeUInt16($bools2Mask(value, 16));\n  },\n  $read: function (state) {\n    return $mask2Bools(state.$readUint16(), 16);\n  }\n};\n\n/**\n * Encode exactly 32 booleans as a UInt32.\n */\nexport const bools32Coder: BinaryTypeCoder<boolean[]> = {\n  $write: function (value, data) {\n    data.$writeUInt32($bools2Mask(value, 32));\n  },\n  $read: function (state) {\n    return $mask2Bools(state.$readUint32(), 32);\n  }\n};\n/**\n * Encode any number of booleans as one or more UInt8s.\n *\n * <padding> <is_last> <payload ...>\n */\nexport const boolsCoder: BinaryTypeCoder<boolean[]> = {\n  $write: function (value, data) {\n    for (let i = 0; i < Math.max(1, value.length); i += 6) {\n      const last = i + 6 >= value.length;\n      const intValue = $vBools2Mask([\n        true, // positive padding\n        last,\n        ...value.slice(i, i + 6)\n      ]);\n\n      data.$writeUInt8(intValue);\n    }\n  },\n  $read: function (state) {\n    const values: boolean[] = [];\n    let last = false;\n\n    while (!last) {\n      const chunk = $mask2vBools(state.$readUint8());\n      chunk.shift(); // positive padding\n      last = chunk.shift();\n      values.push(...chunk);\n    }\n\n    return values;\n  }\n};\n\n/**\n * <uint_length> <buffer_data>\n */\nexport const jsonCoder: BinaryTypeCoder<any> = {\n  $write: function (value, data, path) {\n    let stringValue: string;\n    try {\n      stringValue = JSON.stringify(value);\n    }\n    catch (error) {\n      throw new EncodeError('JSON', error, path);\n    }\n\n    stringCoder.$write(stringValue, data, path);\n  },\n  $read: function (state) {\n    const stringValue = stringCoder.$read(state);\n    return JSON.parse(stringValue);\n  }\n};\n\n/**\n * <uint_source_length> <buffer_source_data> <flags>\n * flags is a bit-mask: g=1, i=2, m=4\n */\nexport const regexCoder: BinaryTypeCoder<RegExp> = {\n  $write: function (value, data, path) {\n    if (!(value instanceof RegExp)) {\n      throw new EncodeError('RegExp', value, path);\n    }\n\n    let g: number, i: number, m: number;\n    stringCoder.$write(value.source, data, path);\n    g = value.global ? 1 : 0;\n    i = value.ignoreCase ? 2 : 0;\n    m = value.multiline ? 4 : 0;\n    data.$writeUInt8(g + i + m);\n  },\n  $read: function (state) {\n    const source = stringCoder.$read(state),\n      flags = state.$readUint8(),\n      g = flags & 0x1 ? 'g' : '',\n      i = flags & 0x2 ? 'i' : '',\n      m = flags & 0x4 ? 'm' : '';\n    return new RegExp(source, g + i + m);\n  }\n};\n\n/**\n * <uint_time_ms>\n */\nexport const dateCoder: BinaryTypeCoder<Date> = {\n  $write: function (value, data, path) {\n    if (!(value instanceof Date)) {\n      throw new EncodeError('Date', value, path);\n    }\n    else {\n      const time = value.getTime();\n      if (isNaN(time)) {\n        throw new EncodeError('Date', 'NaN', path);\n      }\n      intCoder.$write(time, data, path);\n    }\n  },\n  $read: function (state) {\n    return new Date(intCoder.$read(state));\n  }\n};\n\n/**\n * Array of coders, indexed by type\n */\nexport const CODERS: Record<Type, BinaryTypeCoder<any>> = [\n  uintCoder, // Type.UInt\n  uint8Coder, // Type.UInt8\n  uint16Coder, // Type.UInt16\n  uint32Coder, // Type.UInt32\n  intCoder, // Type.Int\n  int8Coder, // Type.Int8\n  int16Coder, // Type.Int16\n  int32Coder, // Type.Int32\n  float64Coder, // Type.Float64\n  float32Coder, // Type.Float32\n  float16Coder, // Type.Float16\n  scalarCoder, // Type.Scalar\n  uscalarCoder, // Type.UScalar\n  boolCoder, // Type.Bool\n  boolsCoder, // Type.Bools\n  bools8Coder, // Type.Bools8\n  bools16Coder, // Type.Bools16\n  bools32Coder, // Type.Bools32\n  stringCoder, // Type.String\n  bufferCoder, // Type.Buffer\n  jsonCoder, // Type.JSON\n  regexCoder, // Type.RegExp\n  dateCoder, // Type.Date\n];\n","/** Default maximum transmission unit in networking */\nconst MTU = 1500;\n\n/** Set Tinybuf global config */\nexport const setTinybufConfig = (newSettings: Partial<typeof cfg>): void => {\n  cfg = {\n    ...cfg,\n    ...newSettings\n  };\n};\n\nexport let cfg = {\n  /**\n   * (default: 1500)\n   * The maximum bytes to allocate to an encoding buffer. If using the global\n   * encoding buffer, this is the size it is initialized to.\n   */\n  encodingBufferMaxSize: MTU,\n\n  /**\n   * (default: 256)\n   * Initial bytes to allocate to individual format encoding buffers, if used.\n   */\n  encodingBufferInitialSize: 256,\n\n  /**\n   * (default: 256)\n   * Additional bytes when resizing individual format encoding buffers, if used.\n   */\n  encodingBufferIncrement: 256,\n\n  /**\n   * (default: true)\n   * By default, format encoders share a global encoding buffer for performance\n   * and memory management reasons.\n   *\n   * When set to false, each format will be allocated its own resizable\n   * encoding buffer.\n   *\n   * Enable to maximise performance and memory re-use, just be cautious of\n   * possible race conditions.\n   */\n  useGlobalEncodingBuffer: false,\n};\n","/* eslint-disable @typescript-eslint/no-extraneous-class */\n\nconst FLOAT16_PRECALCULATE_SUBNORMAL = Math.pow(2, -24);\n\n/**\n * Convert a number to the nearest 16-bit half precision float representation (as a UInt16 bitmask).\n *\n * @param doubleFloat A number.\n * @returns A UInt16 bitmask representation of a half precision float.\n *\n * @see https://stackoverflow.com/a/32633586\n */\nexport const $f16mask = (function() {\n  const floatView = new Float32Array(1);\n  const int32View = new Int32Array(floatView.buffer);\n\n  // This method is faster than the OpenEXR implementation (very often\n  // used, eg. in Ogre), with the additional benefit of rounding, inspired\n  // by James Tursa's half-precision code.\n  return function toHalf(v: number): number {\n    floatView[0] = v;\n    const x = int32View[0];\n\n    let b = (x >> 16) & 0b1000000000000000;\n    let m = (x >> 12) & 0b0000011111111111;\n    const e = (x >> 23) & 0b0000000011111111;\n\n    // If zero, or denormal, or exponent underflows too much for a denormal\n    // half, return signed zero.\n    if (e < 103) return b;\n\n    // If NaN, return NaN. If Inf or exponent overflow, return Inf.\n    if (e > 142) {\n      if (isNaN(v)) return 0b0111110000000001; // Float 16 NaN\n\n      b |= 0x7c00;\n\n      // If exponent was 0xff and one significand bit was set, it means NaN,\n      // not Inf, so make sure we set one significand bit too.\n      b |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);\n      return b;\n    }\n\n    // If exponent underflows but not too much, return a denormal\n    if (e < 113) {\n      m |= 0x0800;\n      // Extra rounding may overflow and set significand to 0 and exponent\n      // to 1, which is OK.\n      b |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n      return b;\n    }\n\n    b |= ((e - 112) << 10) | (m >> 1);\n\n    // Extra rounding. An overflow will set significand to 0 and increment\n    // the exponent, which is OK.\n    b += m & 1;\n\n    return b;\n  };\n}());\n\n\n/**\n * Convert a UInt16 bitmask of a 16-bit half precision float representation into\n * a double precision float (number).\n *\n * @param b A UInt16 bitmask representation of a half precision float.\n * @returns A number (standard 64-bit double precision representation).\n */\nexport function $f16unmask(b: number): number {\n  // eslint-disable-next-line max-len\n  if ((b & 0x8000) === 0) return f16.t[(((/* exponent: */ b >> 10 /* FLOAT16_SIGNIFICAND_BITS */) & 0x1F) << 10 /* FLOAT16_SIGNIFICAND_BITS */) + (/* significand: */ b & 0x3FF  /* FLOAT16_SIGNIFICAND_MASK */)];\n  else return -f16.t[(((/* exponent: */ b >> 10 /* FLOAT16_SIGNIFICAND_BITS */) & 0x1F) << 10 /* FLOAT16_SIGNIFICAND_BITS */) + (/* significand: */ b & 0x3FF  /* FLOAT16_SIGNIFICAND_MASK */)];\n}\n\n/**\n * The fround16() method returns the nearest 16-bit half precision float representation of a number.\n *\n * @param doubleFloat A number.\n * @returns The nearest 16-bit half precision float representation of x.\n */\nexport function fround16(doubleFloat: number): number {\n  return $f16unmask($f16mask(doubleFloat));\n}\n\n// ----- Precomputed table: -----\n\n/** precomputed table of the conversion factors for each possible combination of exponent and significand bits (unsigned) */\nclass f16 {\n  public static readonly t = this._$initF16LookupTable(); // static: lazy initializer\n\n  private static _$initF16LookupTable(): number[] {\n    const t = [];\n    for (let exponent = 0; exponent < 1 << 5 /* FLOAT16_EXPONENT_BITS */; exponent++) {\n      for (let significand = 0; significand < 1 << 10 /* FLOAT16_SIGNIFICAND_BITS */; significand++) {\n        const value = f16._$precalculate(exponent, significand);\n        t[(exponent << 10 /* FLOAT16_SIGNIFICAND_BITS */) + significand] = value;\n      }\n    }\n    return t;\n  }\n\n\n  /** precalculate the value for a given exponent and significand */\n  private static _$precalculate(exponent: number, significand: number): number {\n    if (exponent === 0) {\n      if (significand === 0) return 0; // subnormal or zero\n      return FLOAT16_PRECALCULATE_SUBNORMAL * (significand / 1024); // Subnormal\n    }\n    if (exponent === 0x1F /* FLOAT16_EXPONENT_MASK */) return significand === 0 ? Infinity : NaN; // Infinity or NaN\n    // normalize\n    exponent -= 15 /* FLOAT16_EXPONENT_BIAS */; // adjust exponent bias\n    return Math.pow(2, exponent) * (1 + significand / 1024);\n  }\n}","import { cfg } from \"../settings\";\nimport { EncodeError } from \"./errors\";\nimport { $f16mask } from \"./float16\";\n\n/**\n * Wraps a view into an underlying buffer, and can be dynamically resized.\n *\n * @internal\n */\nexport class BufferWriter {\n  public $byteOffset: number = 0;\n\n  private _$dataView: DataView;\n  private _$buf: ArrayBuffer;\n  private readonly _$autoResize: boolean;\n\n  public constructor(value: number | ArrayBuffer) {\n    if (value instanceof ArrayBuffer) {\n      this._$buf = value;\n      this._$autoResize = false;\n    }\n    else {\n      this._$buf = new ArrayBuffer(value);\n      this._$autoResize = true;\n    }\n\n    this._$dataView = new DataView(this._$buf, 0, this._$buf.byteLength);\n  }\n\n  public $asView(): Uint8Array {\n    return new Uint8Array(this._$dataView.buffer, 0, this.$byteOffset);\n  }\n\n  public $asCopy(): Uint8Array {\n    return new Uint8Array(this._$dataView.buffer.slice(0, this.$byteOffset));\n  }\n\n  // ----- Writers: -----\n\n  public $writeInt8(value: number): void {\n    this._$dataView.setInt8(this._$alloc(1), value);\n  }\n\n  public $writeInt16(value: number): void {\n    this._$dataView.setInt16(this._$alloc(2), value, true);\n  }\n\n  public $writeInt32(value: number): void {\n    this._$dataView.setInt32(this._$alloc(4), value, true);\n  }\n\n  public $writeUInt8(value: number): void {\n    this._$dataView.setUint8(this._$alloc(1), value);\n  }\n\n  public $writeUInt16(value: number): void {\n    this._$dataView.setUint16(this._$alloc(2), value); // big-endian\n  }\n\n  public $writeUInt32(value: number): void {\n    this._$dataView.setUint32(this._$alloc(4), value); // big-endian\n  }\n\n  public $writeFloat16(value: number): void {\n    this._$dataView.setUint16(this._$alloc(2), $f16mask(value));\n  }\n\n  public $writeFloat32(value: number): void {\n    this._$dataView.setFloat32(this._$alloc(4), value, true);\n  }\n\n  public $writeFloat64(value: number): void {\n    this._$dataView.setFloat64(this._$alloc(8), value, true);\n  }\n\n  public $writeBuffer(b: ArrayBuffer | ArrayBufferView): void {\n    const byteOffset = this._$alloc(b.byteLength);\n    const readView = b instanceof Uint8Array ? b\n      : b instanceof ArrayBuffer ? new Uint8Array(b)\n        : new Uint8Array(b.buffer, b.byteOffset, b.byteLength);\n    new Uint8Array(this._$dataView.buffer, byteOffset, b.byteLength).set(readView);\n  }\n\n  // ----- Private methods: -----\n\n  /** Allocate the given number of bytes, and then return the current header position (byteOffset). */\n  private _$alloc(bytes: number): number {\n    if (this.$byteOffset + bytes <= this._$dataView.byteLength) {\n      const i = this.$byteOffset; // copy\n      this.$byteOffset += bytes;\n\n      return i;\n    }\n\n    const currentAlloc = this._$dataView.byteLength;\n    const minRequestedSize = currentAlloc + bytes;\n    if (!this._$autoResize || minRequestedSize > cfg.encodingBufferMaxSize) {\n      throw new EncodeError(`exceeded max encoding buffer size: ${cfg.encodingBufferMaxSize}`);\n    }\n\n    let newLength = this._$dataView.byteLength;\n    do {\n      newLength = Math.min(newLength + cfg.encodingBufferIncrement, cfg.encodingBufferMaxSize);\n    }\n    while (newLength < this.$byteOffset + bytes);\n\n    // copy bytes to new buffer\n    const newBuffer = new ArrayBuffer(newLength);\n    const currentData = new Uint8Array(this._$dataView.buffer, this._$dataView.byteOffset, currentAlloc);\n    new Uint8Array(newBuffer).set(currentData);\n\n    // update the view\n    this._$buf = newBuffer;\n    this._$dataView = new DataView(newBuffer);\n\n    // increment the pointer\n    const i = this.$byteOffset; // copy\n    this.$byteOffset += bytes;\n\n    return i;\n  }\n}\n","import { $f16unmask } from \"./float16\";\n\n/**\n * Wraps a buffer with a read head pointer.\n *\n * @internal\n */\nexport class BufferReader {\n  public i: number;\n  private _$dataView: DataView;\n\n  public constructor(b: Uint8Array | ArrayBufferView | ArrayBuffer, byteOffset?: number) {\n    this._$dataView = b instanceof ArrayBuffer ? new DataView(b) : new DataView(b.buffer, b.byteOffset, b.byteLength);\n    this.i = byteOffset ?? 0;\n  }\n\n  /** Read the next byte, without moving the read head pointer. */\n  public $peekUInt8(): number {\n    return this._$dataView.getUint8(this.i);\n  }\n\n  /** used to skip bytes for reading type headers. */\n  public $skipByte(): void {\n    this.i++;\n  }\n\n  // ----- Readers: -----\n\n  public $readUint8(): number {\n    return this._$dataView.getUint8(this.i++);\n  }\n\n  public $readUint16(): number {\n    const r = this._$dataView.getUint16(this.i); // big-endian\n    this.i += 2;\n    return r;\n  }\n\n  public $readUint32(): number {\n    const r = this._$dataView.getUint32(this.i); // big-endian\n    this.i += 4;\n    return r;\n  }\n\n  public $readInt8(): number {\n    return this._$dataView.getInt8(this.i++);\n  }\n\n  public $readInt16(): number {\n    const r = this._$dataView.getInt16(this.i, true);\n    this.i += 2;\n    return r;\n  }\n\n  public $readInt32(): number {\n    const r = this._$dataView.getInt32(this.i, true);\n    this.i += 4;\n    return r;\n  }\n\n  public $readFloat16(): number {\n    const r = this._$dataView.getUint16(this.i);\n    this.i += 2;\n    return $f16unmask(r);\n  }\n\n  public $readFloat32(): number {\n    const r = this._$dataView.getFloat32(this.i, true);\n    this.i += 4;\n    return r;\n  }\n\n  public $readFloat64(): number {\n    const r = this._$dataView.getFloat64(this.i, true);\n    this.i += 8;\n    return r;\n  }\n\n  /** @throws RangeError if exceeds length */\n  public $readBuffer(bytes: number): Uint8Array {\n    if (this.i + bytes > this._$dataView.byteLength) {\n      throw new RangeError();\n    }\n\n    const view = new Uint8Array(this._$dataView.buffer, this.i, bytes);\n    this.i += bytes;\n\n    return view;\n  }\n}\n","/**\n * Binary coder types.\n *\n * @see {ValueTypes} for corresponding type definitions\n */\nexport const enum Type {\n  /**\n   * Unsigned integer (1 - 8 bytes).\n   * - 0 → 127 = 1 byte\n   * - 128 → 16,384 = 2 bytes\n   * - 16,385 → 536,870,911 = 4 bytes\n   * - 536,870,912 → `Number.MAX_SAFE_INTEGER` = 8 bytes\n   */\n  UInt,\n\n  /** Unsigned 8-bit integer (between 0 and 255, 1 byte). */\n  UInt8,\n\n  /** Unsigned 16-bit integer (between 0 and 65,535, 2 bytes). */\n  UInt16,\n\n  /** Unsigned 32-bit integer (between 0 and 4,294,967,295, 4 bytes). */\n  UInt32,\n\n  /**\n   * Signed integer (1 - 8 bytes).\n   * - 0 → ±64 = 1 byte\n   * - … → ±8,192 = 2 bytes\n   * - … → ±268,435,456 = 4 bytes\n   * - … → ±`Number.MAX_SAFE_INTEGER` = 8 bytes\n   */\n  Int,\n\n  /** Signed 1 byte integer (between -127 and 127). */\n  Int8,\n\n  /** Signed 2 byte integer (between -32,767 and 32,767). */\n  Int16,\n\n  /** Signed 4 byte integer (between -2,147,483,647 and 2,147,483,647). */\n  Int32,\n\n  /** Default JavaScript `number` type. Floating-point number (64-bit, double precision, 8 bytes). */\n  Float64,\n\n  /** Floating-point number (32-bit, single precision, 4 bytes). */\n  Float32,\n\n  /** Floating-point number (16-bit, half precision, 2 bytes). */\n  Float16,\n\n  /** A signed scalar between -1.00 and 1.00 (1 byte). */\n  Scalar,\n\n  /** An unsigned scalar between 0.00 and 1.00 (1 byte). */\n  UScalar,\n\n  /**\n   * Boolean value (1 byte).\n   * @see {Bools8} for packing multiple booleans into a single byte.\n   */\n  Bool,\n\n  /** Any array of booleans (0¶ byte / 2-bit header). */\n  Bools,\n\n  /** Up to 8 booleans (1 byte). */\n  Bools8,\n\n  /** Up to 16 booleans (2 bytes). */\n  Bools16,\n\n  /** Up to 32 booleans (4 bytes). */\n  Bools32,\n\n  /** A string (1† byte header + string bytes). */\n  String,\n\n  /** Any Uint8Array, ArrayBuffer or ArrayBufferLike value (1† byte header + buffer bytes). */\n  Buffer,\n\n  /** Any JSON-serializable data. Encodes as a UTF-8 string. */\n  JSON,\n\n  /** JavaScript regular expression. */\n  RegExp,\n\n  /**\n   * JavaScript date object.\n   *\n   * Encoded as an 8 byte (64-bit) integer UTC timestamp from as the number\n   * of milliseconds since the Unix Epoch (January 1, 1970, 00:00:00 UTC).\n   *\n   * @see {Date}\n   */\n  Date,\n}\n\n/**\n * Mappings for the value types.\n */\nexport type ValueTypes = {\n  // Floats\n  [Type.Float16]: number;\n  [Type.Float32]: number;\n  [Type.Float64]: number;\n  // Integers\n  [Type.Int]: number;\n  [Type.Int8]: number;\n  [Type.Int16]: number;\n  [Type.Int32]: number;\n  [Type.UInt]: number;\n  [Type.UInt8]: number;\n  [Type.UInt16]: number;\n  [Type.UInt32]: number;\n  // Scalar\n  [Type.UScalar]: number;\n  [Type.Scalar]: number;\n  // Boolean\n  [Type.Bool]: boolean;\n  [Type.Bools]: boolean[];\n  [Type.Bools8]: boolean[];\n  [Type.Bools16]: boolean[];\n  [Type.Bools32]: boolean[];\n  // Other\n  [Type.String]: string;\n  [Type.Date]: Date;\n  [Type.RegExp]: RegExp;\n  [Type.JSON]: any;\n  [Type.Buffer]: Uint8Array | ArrayBuffer | ArrayBufferView;\n};\n\n/** @throws any error too */\nexport type ValidationFn<T> = (x: T) => undefined | boolean | Error;\nexport type TransformFn<T> = (x: T) => T;\nexport type Transforms<T> = TransformFn<T> | [preEncode: TransformFn<T>] | [preEncode: TransformFn<T> | undefined, postDecode: TransformFn<T> | undefined];\n\n/**\n * A wrapper around any Type definition that declares it as optional.\n */\nexport class OptionalType<T extends FieldDefinition> {\n  public constructor(public type: T) {}\n}\n\n/**\n * Wrap any definition as optional.\n */\nexport function optional<T extends FieldDefinition>(t: T): OptionalType<T> {\n  return new OptionalType(t);\n}\n\n/**\n * A definition for an object binary encoder.\n */\nexport type EncoderDefinition = {\n  [key: string]: FieldDefinition | OptionalType<FieldDefinition>;\n};\n\n/**\n * Definition for an object-field binary encoder.\n */\nexport type FieldDefinition = keyof ValueTypes | [keyof ValueTypes] | EncoderDefinition | [EncoderDefinition] | OptionalType<FieldDefinition>;\n\n/**\n * The resulting type of the decoded data, based on the encoder definition.\n */\nexport type InferredDecodedType<EncoderType extends EncoderDefinition> = {\n  [EKey in keyof EncoderType as EncoderType[EKey] extends OptionalType<any> ? never : EKey]: EncoderType[EKey] extends keyof ValueTypes\n      ? ValueTypes[EncoderType[EKey]]\n      : EncoderType[EKey] extends [keyof ValueTypes]\n        ? Array<ValueTypes[EncoderType[EKey][0]]>\n        : EncoderType[EKey] extends EncoderDefinition\n          ? InferredDecodedType<EncoderType[EKey]>\n          : EncoderType[EKey] extends [EncoderDefinition]\n            ? Array<InferredDecodedType<EncoderType[EKey][number]>>\n            : never;\n} & {\n  [EKey in keyof EncoderType as EncoderType[EKey] extends OptionalType<any> ? EKey : never]?: EncoderType[EKey] extends OptionalType<infer OptionalValue extends keyof ValueTypes>\n    ? ValueTypes[OptionalValue] | undefined\n    : EncoderType[EKey] extends OptionalType<infer OptionalValue extends [keyof ValueTypes]>\n      ? Array<ValueTypes[OptionalValue[0]]> | undefined\n      : EncoderType[EKey] extends OptionalType<infer OptionalValue extends EncoderDefinition>\n        ? InferredDecodedType<OptionalValue> | undefined\n        : never;\n};\n\nexport type InferredTransformConfig<EncoderType extends EncoderDefinition> = {\n [EKey in keyof EncoderType]?: EncoderType[EKey] extends keyof ValueTypes\n     ? Transforms<ValueTypes[EncoderType[EKey]]>\n     : EncoderType[EKey] extends [keyof ValueTypes]\n       ? Transforms<ValueTypes[EncoderType[EKey][0]]>\n       : EncoderType[EKey] extends EncoderDefinition\n         ? InferredTransformConfig<EncoderType[EKey]>\n         : EncoderType[EKey] extends [EncoderDefinition]\n           ? InferredTransformConfig<EncoderType[EKey][number]>\n           : EncoderType[EKey] extends OptionalType<infer OptionalValue extends keyof ValueTypes>\n            ? Transforms<ValueTypes[OptionalValue]>\n            : EncoderType[EKey] extends OptionalType<infer OptionalValue extends [keyof ValueTypes]>\n              ? Transforms<ValueTypes[OptionalValue[0]]>\n              : EncoderType[EKey] extends OptionalType<infer OptionalValue extends EncoderDefinition>\n                ? InferredTransformConfig<OptionalValue> | undefined\n                : never;\n};\n\nexport type InferredValidationConfig<EncoderType extends EncoderDefinition> = {\n [EKey in keyof EncoderType]?: EncoderType[EKey] extends keyof ValueTypes\n     ? ValidationFn<ValueTypes[EncoderType[EKey]]>\n     : EncoderType[EKey] extends [keyof ValueTypes]\n       ? ValidationFn<ValueTypes[EncoderType[EKey][0]]>\n       : EncoderType[EKey] extends EncoderDefinition\n         ? InferredValidationConfig<EncoderType[EKey]>\n         : EncoderType[EKey] extends [EncoderDefinition]\n           ? InferredValidationConfig<EncoderType[EKey][number]>\n           : EncoderType[EKey] extends OptionalType<infer OptionalValue extends keyof ValueTypes>\n            ? ValidationFn<ValueTypes[OptionalValue]>\n            : EncoderType[EKey] extends OptionalType<infer OptionalValue extends [keyof ValueTypes]>\n              ? ValidationFn<ValueTypes[OptionalValue[0]]>\n              : EncoderType[EKey] extends OptionalType<infer OptionalValue extends EncoderDefinition>\n                ? InferredValidationConfig<OptionalValue> | undefined\n                : never;\n};\n","import { CODERS } from './lib/coders';\nimport * as coders from './lib/coders';\nimport { $hashCode, $strToHashCode } from './lib/hashCode';\nimport { peekHeader, peekHeaderStr } from './lib/peek';\nimport { BufferWriter } from './lib/BufferWriter';\nimport { BufferReader } from './lib/BufferReader';\nimport {\n  InferredDecodedType,\n  EncoderDefinition,\n  Type,\n  OptionalType,\n  InferredTransformConfig,\n  InferredValidationConfig,\n  ValidationFn,\n  Transforms,\n  FieldDefinition\n} from './Type';\nimport { EncodeError } from './lib/errors';\nimport { cfg } from './settings';\n\nexport type FormatHeader = string | number;\n\n/**\n * Decoded object types for a given binary format.\n * @example let onData = (data: Decoded<typeof MyBufferFormat>) => {...};\n */\nexport type Decoded<FromBufferFormat> = FromBufferFormat extends BufferFormat<infer EncoderType, any> ? InferredDecodedType<EncoderType> : never;\n\n/**\n * Defines a format for encoding/decoding binary buffers.\n *\n * Optionally customize the identifier, either as a 2-byte string, an unsigned integer (0 -> 65,535), or as `null` to disable entirely.\n *\n * @example\n * const MyFormat = defineFormat({ ... });\n * const MyFormat = defineFormat('ab', { ... });\n * const MyFormat = defineFormat(1234, { ... });\n * const MyFormat = defineFormat(null, { ... });\n */\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(def: T): BufferFormat<T, HeaderType>;\n/**\n * Defines a format for encoding/decoding binary buffers.\n *\n * Optionally customize the identifier, either as a 2-byte string, an unsigned integer (0 -> 65,535), or as `null` to disable entirely.\n *\n * @example\n * const MyFormat = defineFormat({ ... });\n * const MyFormat = defineFormat('ab', { ... });\n * const MyFormat = defineFormat(1234, { ... });\n * const MyFormat = defineFormat(null, { ... });\n */\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(h: HeaderType | null, def: T): BufferFormat<T, HeaderType>;\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(a?: HeaderType | T, b?: T): BufferFormat<T, HeaderType> {\n  return a !== null && typeof a === 'object'\n    ? new BufferFormat<T, HeaderType>(a as T)\n    : new BufferFormat<T, HeaderType>(b as T, a as HeaderType);\n}\n\nfunction isValidHeader(h: FormatHeader): boolean {\n  if (typeof h === 'number') return Number.isInteger(h) && h >= 0 && h <= 65_535;\n  if (typeof h === 'string') return new TextEncoder().encode(h).byteLength === 2;\n  return false;\n}\n\n/**\n * BufferFormat is a utility class for encoding and decoding binary data based\n * on a provided encoding format.\n *\n * @see {header}\n * @see {encode(data)}\n * @see {decode(binary)}\n */\nexport class BufferFormat<EncoderType extends EncoderDefinition, HeaderType extends FormatHeader = number> {\n  /** @internal */\n  private static _$globalEncodingBuffer?: ArrayBuffer;\n\n  /**\n   * A unique identifier encoded as the first 2 bytes (or `undefined` if headerless).\n   *\n   * @see {peekHeader(...)}\n   * @see {peekHeaderStr(...)}\n   * @see {$hashCode}\n   */\n  public readonly header!: HeaderType;\n\n  /** @internal */\n  private readonly _$header!: number; // always uint16 vesion\n  /** @internal */\n  private readonly _$type!: Type;\n  /** @internal */\n  private readonly _$fields!: Field[];\n  /** @internal */\n  private readonly _$fieldsMap!: Map<string, Field>;\n\n  /** @internal */\n  private _$format?: string;\n  /** @internal */\n  private _$transforms?: Transforms<any> | undefined;\n  /** @internal */\n  private _$validate?: ValidationFn<any> | undefined;\n  /** @internal */\n  private _$hasValidationOrTransforms = false;\n  /** @internal */\n  private _$writer?: BufferWriter;\n\n  public constructor(\n    def: EncoderType,\n    header?: HeaderType | null,\n  ) {\n    // set definition\n    if (def instanceof OptionalType) {\n      throw new TypeError(\"Invalid encoding format: Root object cannot be optionals.\");\n    }\n    else if (def !== undefined && typeof def === 'number') {\n      this._$type = def;\n    }\n    else if (def instanceof Object) {\n      this._$type = undefined; // object\n      this._$fieldsMap = new Map();\n      this._$fields = Object.keys(def).map((name) => {\n        const f = new Field(name, def[name]);\n        this._$fieldsMap.set(name, f);\n        return f;\n      });\n\n      // set headers\n      if (header === undefined) {\n        this.header = $hashCode(this.f) as HeaderType; // automatic\n        this._$header = this.header as number;\n      }\n      else if (header === null) {\n        this.header = undefined; // headerless\n        this._$header = undefined;\n      }\n      else if (isValidHeader(header)) {\n        this.header = header; // manual\n        this._$header = typeof header === 'number' ? header : $strToHashCode(header);\n      }\n      else {\n        throw new TypeError(`Header should be an integer between 0 and 65535, a 2-byte string, or null. Received: ${header}`);\n      }\n    }\n    else {\n      throw new TypeError(\"Invalid encoding format: Must be an object, or a known coder type.\");\n    }\n  }\n\n  // ----- Static methods: -----\n\n  /**\n   * Read the header of a buffer as a number.\n   *\n   * @see {header}\n   * @throws {RangeError} if buffer size < 2\n   */\n  public static peekHeader = peekHeader;\n\n  /**\n   * Read the header of a buffer as a string.\n   *\n   * @see {header}\n   * @throws {RangeError} if buffer size < 2\n   */\n  public static peekHeaderStr = peekHeaderStr;\n\n  // ----- Accessors: -----\n\n  /**\n   * @example \"{uint8,str[]?}\"\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  private get f(): string {\n    if (this._$format === undefined) {\n      this._$format = this._$fields !== undefined\n        ? `{${this._$fields.map(v => v.f).join(',')}}`\n        : `${this._$type}`;\n    }\n\n    return this._$format;\n  }\n\n  /** @internal */\n  private static _$initWriter(): BufferWriter {\n    if (cfg.useGlobalEncodingBuffer) {\n      if (!BufferFormat._$globalEncodingBuffer) {\n        // lazy init: global encoding buffer created at max size\n        BufferFormat._$globalEncodingBuffer = new ArrayBuffer(cfg.encodingBufferMaxSize);\n      }\n\n      return new BufferWriter(BufferFormat._$globalEncodingBuffer);\n    }\n\n    return new BufferWriter(cfg.encodingBufferInitialSize);\n  }\n\n  /**\n   * Encode an object to bytes.\n   *\n   * **Warning:** Returns an unsafe view into the encoding buffer. Pass this reference to preserve\n   * performance, and to minimize memory allocation and fragmentation.\n   *\n   * @param data - data to encode\n   * @param safe - (default: false) safely copies bytes, instead of returning a pointer to the encoding buffer\n   *\n   * @returns An unsafe Uint8Array view of the encoded byte array buffer.\n   * @throws if fails to encode value to schema.\n   */\n  public encode<DecodedType extends InferredDecodedType<EncoderType>>(\n    data: DecodedType,\n    safe?: boolean,\n  ): Uint8Array {\n    // lazy init\n    if (!this._$writer) this._$writer = BufferFormat._$initWriter();\n\n    // reset byteOffset\n    this._$writer.$byteOffset = 0;\n    if (this._$hasValidationOrTransforms) data = this._$preprocess(data);\n    this._$write(data, this._$writer, '');\n\n    return safe ? this._$writer.$asCopy() : this._$writer.$asView();\n  }\n\n  /**\n   * Decode binary data to an object.\n   * @throws if fails to decode bytes to schema.\n   */\n  public decode<DecodedType = InferredDecodedType<EncoderType>>(b: Uint8Array | ArrayBufferView | ArrayBuffer): DecodedType {\n    return this._$read(new BufferReader(b, this.header === undefined ? 0 : 2));\n  }\n\n  /**\n   * Set additional transform functions to apply before encoding and after decoding.\n   */\n  public setTransforms(transforms: InferredTransformConfig<EncoderType> | Transforms<any>): this {\n    this._$hasValidationOrTransforms = true;\n\n    if (transforms instanceof Function || (Array.isArray(transforms) && transforms[0] instanceof Function)) {\n      this._$transforms = transforms;\n    }\n    else {\n      for (const name of Object.keys(transforms)) {\n        const field = this._$fieldsMap.get(name);\n        if (!field) {\n          throw new TypeError(`Failed to set transforms for field '${name}'`);\n        }\n\n        // Set validation for object.\n        field.$coder.setTransforms(transforms[name]);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Set additional validation rules which are applied on encode() and decode().\n   *\n   * - Validation functions should throw an error, return an error, or return boolean false.\n   * - Anything else is treated as successfully passing validation.\n   */\n  public setValidation(validations: InferredValidationConfig<EncoderType> | ValidationFn<any>): this {\n    this._$hasValidationOrTransforms = true;\n\n    if (validations instanceof Function) {\n      this._$validate = validations;\n    }\n    else {\n      for (const name of Object.keys(validations)) {\n        const field = this._$fieldsMap.get(name);\n        if (!field) {\n          throw new TypeError(`Failed to set validation function for field '${name}'`);\n        }\n\n        field.$coder.setValidation(validations[name]);\n      }\n    }\n\n    return this;\n  }\n\n  // ----- Implementation: -----\n\n  /**\n   * @param value\n   * @param bw\n   * @param path\n   * @throws if the value is invalid\n   *\n   * @internal\n   */\n  private _$write(value: { [x: string]: any; }, bw: BufferWriter, path: string): void {\n    // write header\n    if (this._$header !== undefined) this._$writer.$writeUInt16(this._$header);\n\n    // write scalar\n    if (this._$type !== undefined) {\n      const safeValue = (this._$validate || this._$transforms) ? this._$preprocess(value) : value;\n\n      return CODERS[this._$type].$write(safeValue, bw, path);\n    }\n\n    // Check for object type\n    if (!value || typeof value !== 'object') {\n      throw new TypeError(`Expected an object at ${path}`);\n    }\n\n    // Write each field\n    for (const field of this._$fields) {\n      const subpath = path ? `${path}.${field.$name}` : field.$name;\n      const subValue = value[field.$name];\n\n      if (field.$isOptional) {\n\n        // add 'presence' flag\n        if (subValue === undefined || subValue === null) {\n          coders.boolCoder.$write(false, bw);\n          continue;\n        }\n        else {\n          coders.boolCoder.$write(true, bw);\n        }\n      }\n\n      if (!field.$isArray) {\n        // scalar field\n        field.$coder._$write(subValue, bw, subpath);\n        continue;\n      }\n\n      // Array field\n      this._$writeArray(subValue, bw, subpath, field.$coder);\n    }\n  }\n\n  /**\n   * pre-process: validation and/or transforms\n   * @internal\n   */\n  private _$preprocess<T extends Record<string, any>>(data: T): T {\n    if (this._$validate && this._$validate(data) === false) {\n      throw new Error('failed validation');\n    }\n\n    if (this._$transforms instanceof Function) {\n      return this._$transforms(data);\n    }\n    else if (Array.isArray(this._$transforms) && this._$transforms[0] instanceof Function) {\n      return this._$transforms[0](data);\n    }\n\n    return data;\n  }\n\n  /**\n   * post-process: validation and/or transforms\n   * @internal\n   */\n  private _$postprocess<T extends Record<string, any>>(data: T): T {\n    if (Array.isArray(this._$transforms) && this._$transforms[1] instanceof Function) {\n      data = this._$transforms[1](data);\n    }\n\n    if (this._$validate instanceof Function) {\n      this._$validate(data);\n    }\n\n    return data;\n  }\n\n  /**\n   * This function will be executed only the first time\n   * After that, we'll compile the read routine and add it directly to the instance\n   * @param state\n   * @returns\n   * @throws if fails\n   *\n   * @internal\n   */\n  private _$read<DecodedType = InferredDecodedType<EncoderType>>(state: BufferReader): DecodedType {\n    // This function will be executed only the first time to compile the read routine.\n    // After that, we'll compile the read routine and add it directly to the instance\n\n    // Update the read method implementation.\n    this._$read = this._$compileFormatReadFn();\n\n    return this._$read(state);\n  }\n\n  /**\n   * Generate read function code for this coder.\n   *\n   * @example\n   * // new Type({a:'int', 'b?':['string']}) would emit:\n   *\n   * `return {\n   *   a: this._readField(0, state),\n   *   b: this._readField(1, state),\n   * }`\n   *\n   * @internal\n   */\n  private _$makeObjectReader(): string {\n    const fieldsStr: string = this._$fields\n      .map(({ $name: name }, i) => `${name}:this.${this._$readField.name}(${i},state)`)\n      .join(',');\n\n    return `return{${fieldsStr}}`;\n  }\n\n  /**\n   * Read an individual field.\n   * @internal\n   */\n  private _$readField(fieldId: number, state: BufferReader): any {\n    const field = this._$fields[fieldId];\n\n    if (field.$isOptional && !this._$readOptional(state)) {\n      return undefined;\n    }\n\n    if (field.$isArray) {\n      return this._$readArray(field.$coder, state);\n    }\n\n    return field.$coder._$read(state);\n  }\n\n  /**\n   * Compile the decode() method for this object.\n   *\n   * @internal\n   */\n  private _$compileFormatReadFn<DecodedType = InferredDecodedType<EncoderType>>(): (state: BufferReader) => DecodedType {\n    // scalar type\n    if (this._$type !== undefined) {\n      return this._$hasValidationOrTransforms\n        ? (s) => this._$postprocess(CODERS[this._$type].$read(s))\n        : CODERS[this._$type].$read;\n    }\n\n    // scalar type\n    return new Function('state', this._$makeObjectReader()) as any;\n  }\n\n  /**\n   * @param value\n   * @param data\n   * @param path\n   * @param type\n   * @throws if the value is invalid\n   *\n   * @internal\n   */\n  private _$writeArray(value: string | any[], data: any, path: string, type: BufferFormat<any, any>): void {\n    if (!Array.isArray(value)) {\n      throw new EncodeError(`Array<${type._$type}>`, data, path);\n    }\n\n    let i: string | number, len: number;\n    len = value.length;\n    coders.uintCoder.$write(len, data);\n    for (i = 0; i < len; i++) {\n      type._$write(value[i], data, path + '.' + i);\n    }\n  }\n\n  /**\n   * @throws if invalid data\n   *\n   * @internal\n   */\n  private _$readArray<T extends EncoderDefinition>(type: BufferFormat<T, any>, state: any): Array<T> {\n    const arr = new Array(coders.uintCoder.$read(state));\n    for (let j = 0; j < arr.length; j++) {\n      arr[j] = type._$read(state);\n    }\n    return arr;\n  }\n\n  /** @internal */\n  private _$readOptional(state: BufferReader): boolean {\n    return coders.boolCoder.$read(state);\n  }\n}\n\n/**\n * Parses and represents an object field.\n *\n * @internal\n */\nclass Field {\n  public readonly $name: string;\n  public readonly $coder: BufferFormat<any>;\n  public readonly $isOptional: boolean;\n  public readonly $isArray: boolean;\n\n  private _$formatString?: string;\n\n  public constructor(name: string, rawType: FieldDefinition) {\n    this.$isOptional = rawType instanceof OptionalType;\n    let type = rawType instanceof OptionalType ? rawType.type : rawType;\n    this.$name = name;\n\n    if (Array.isArray(type)) {\n      if (type.length !== 1) {\n        throw new TypeError('Invalid array definition, it must have exactly one element');\n      }\n\n      type = type[0];\n      this.$isArray = true;\n    }\n    else {\n      this.$isArray = false;\n    }\n\n    this.$coder = new BufferFormat<any>(type, null);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  public get f(): string {\n    if (this._$formatString === undefined) {\n      this._$formatString = `${(this.$coder as any).f}${this.$isArray ? '[]' : ''}${this.$isOptional ? '?' : ''}`;\n    }\n\n    return this._$formatString;\n  }\n}\n"],"names":["TinybufError","Error","EncodeError","constructor","a","b","c","super","DecodeError","summary","cause","message","this","stack","$hashCode","str","hash","i","length","charCodeAt","$strToHashCode","$hashCodeToStr","hashCode","String","fromCharCode","Math","floor","peekHeader","DataView","ArrayBuffer","buffer","getUint16","peekHeaderStr","bufferParser","BufferParserInstance","_$formats","Map","processBuffer","f","data","cb","header","has","get","decode","e","on","format","callback","overwritePrevious","set","ignore","forEach","clear","clamp","value","min","max","r2z","x","ceil","raz","toUScalar8","uScalar","Number","isNaN","toScalar8","scalar","fromUScalar8","uInt8","NaN","fromScalar8","uScalarRound","doubleFloat","scalarRound","$bools2Mask","bools","parseInt","$mask2Bools","int","toString","padStart","map","$vBools2Mask","MAX_AUTO_INT32","MAX_INT32","POW_32","utf8Decoder","TextDecoder","uintCoder","$write","path","MAX_SAFE_INTEGER","$writeUInt8","$writeUInt16","$writeUInt32","uIntValue","$read","state","firstByte","$peekUInt8","$readUint32","$readUint16","$skipByte","intCoder","intValue","stringCoder","bufferCoder","TextEncoder","encode","byteLength","$writeBuffer","$readBuffer","boolCoder","$readUint8","jsonCoder","stringValue","JSON","stringify","error","parse","regexCoder","RegExp","g","m","source","global","ignoreCase","multiline","flags","dateCoder","Date","time","getTime","CODERS","$writeInt8","$readInt8","$writeInt16","$readInt16","$writeInt32","$readInt32","$writeFloat64","$readFloat64","$writeFloat32","$readFloat32","$writeFloat16","$readFloat16","slice","values","last","chunk","shift","push","setTinybufConfig","newSettings","cfg","Object","assign","encodingBufferMaxSize","encodingBufferInitialSize","encodingBufferIncrement","useGlobalEncodingBuffer","FLOAT16_PRECALCULATE_SUBNORMAL","pow","$f16mask","floatView","Float32Array","int32View","Int32Array","toHalf","v","$f16unmask","f16","t","fround16","_$initF16LookupTable","exponent","significand","_$precalculate","Infinity","_a","BufferWriter","$byteOffset","_$buf","_$autoResize","_$dataView","$asView","Uint8Array","$asCopy","setInt8","_$alloc","setInt16","setInt32","setUint8","setUint16","setUint32","setFloat32","setFloat64","byteOffset","readView","bytes","currentAlloc","minRequestedSize","newLength","newBuffer","currentData","BufferReader","getUint8","r","getUint32","getInt8","getInt16","getInt32","getFloat32","getFloat64","RangeError","view","OptionalType","type","optional","defineFormat","BufferFormat","def","_$hasValidationOrTransforms","TypeError","undefined","_$type","_$fieldsMap","_$fields","keys","name","Field","_$header","isValidHeader","h","isInteger","_$format","join","_$initWriter","_$globalEncodingBuffer","safe","_$writer","_$preprocess","_$write","_$read","setTransforms","transforms","Function","Array","isArray","_$transforms","field","$coder","setValidation","validations","_$validate","bw","safeValue","subpath","$name","subValue","$isOptional","coders.boolCoder","$isArray","_$writeArray","_$postprocess","_$compileFormatReadFn","_$makeObjectReader","_$readField","fieldId","_$readOptional","_$readArray","s","len","coders.uintCoder","arr","j","rawType","_$formatString"],"mappings":"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"}