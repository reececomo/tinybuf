{"version":3,"file":"index.mjs","sources":["../src/core/lib/errors.ts","../src/core/lib/hashCode.ts","../src/core/lib/peek.ts","../src/core/BufferParser.ts","../src/core/lib/boolArray.ts","../src/core/lib/math.ts","../src/core/lib/scalar.ts","../src/core/lib/coders.ts","../src/core/settings.ts","../src/core/lib/float16.ts","../src/core/lib/BufferWriter.ts","../src/core/lib/BufferReader.ts","../src/core/Type.ts","../src/core/BufferFormat.ts"],"sourcesContent":["// Buffer parser errors:\n\nexport class TinyBufError extends Error {}\n\nexport class UnrecognizedFormatError extends TinyBufError {}\nexport class FormatHeaderCollisionError extends TinyBufError {}\nexport class BufferDecodingError extends TinyBufError {\n  public constructor(\n    summary: string,\n    public readonly underlying: Error,\n  ) {\n    super(`${summary}: ${underlying.message}`);\n    this.stack = underlying.stack;\n  }\n}\n\n// Encoding errors:\n\nexport class WriteTypeError extends TinyBufError {\n  public constructor(expectedType: string, value: any, path? : string) {\n    super(`Expected '${expectedType}', instead received: ${value} (type: ${typeof value}) (at path: '${path || '<root>'}')`);\n  }\n}\nexport class BufferEncodingError extends TinyBufError {}\n","/**\n * DJB2 hash algorithm (modified for 16-bit uints).\n *\n * DJB2 is a simple and widely used non-cryptographic\n * hash function created by Daniel J. Bernstein.\n *\n * @returns 16-bit unsigned integer\n */\nfunction djb2HashUInt16(str: string): number {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = (hash * 33) ^ str.charCodeAt(i);\n  }\n  return hash & 0xFFFF; // Ensure the result is a Uint16\n}\nexport const hashCode = djb2HashUInt16;\n\n/**\n * Returns an unsigned 16-bit integer hashcode for some string.\n * Prefers 2 character string.\n *\n * @returns A UInt16 between 0 and 65535 (inclusive).\n */\nexport function strToHashCode(str: string): number {\n  // Prefer 2 character string\n  if (str.length === 2) {\n    return str.charCodeAt(0) * 256 + str.charCodeAt(1);\n  }\n\n  return djb2HashUInt16(str); // Fallback to DJB2\n}\n\n/**\n * Convert a UInt16 hashcode to a 2-byte string.\n */\nexport function hashCodeToStr(hashCode: number): string {\n  return String.fromCharCode(Math.floor(hashCode / 256)) + String.fromCharCode(hashCode % 256);\n}\n","import { hashCodeToStr } from \"./hashCode\";\n\n\n/**\n * Read the header bytes of a buffer as a number.\n *\n * @throws {RangeError} if buffer size < 2\n */\nexport function peekHeader(b: ArrayBuffer | ArrayBufferView): number {\n  return new DataView(b instanceof ArrayBuffer ? b : b.buffer).getUint16(0, false);\n}\n\n/**\n * Read the header bytes of a buffer as a string.\n *\n * @throws {RangeError} if buffer length < 2\n */\nexport function peekHeaderStr(b: ArrayBuffer | ArrayBufferView): string {\n  return hashCodeToStr(peekHeader(b));\n}\n","import { BufferFormat } from \"./BufferFormat\";\nimport { EncoderDefinition, InferredDecodedType } from \"./Type\";\nimport {\n  BufferDecodingError,\n  FormatHeaderCollisionError,\n  UnrecognizedFormatError\n} from \"./lib/errors\";\nimport { hashCodeToStr, strToHashCode } from \"./lib/hashCode\";\nimport { peekHeader } from \"./lib/peek\";\n\ntype AnyFormat = BufferFormat<any, any>;\ntype Uint16FormatHeader = number;\n\n/**\n * Small utility for registering and processing format handlers.\n *\n * @example\n * const myHandler = bufferParser()\n *   .on(FormatA, aData => {})\n *   .on(FormatB, bData => {});\n *\n * myHandler.processBuffer(bytes);\n */\nexport const bufferParser = (): BufferParserInstance => new BufferParserInstance();\n\nexport class BufferParserInstance {\n  private formats = new Map<Uint16FormatHeader, [AnyFormat, (data: any) => any]>();\n\n  /** All available formats */\n  public get availableFormats(): Set<AnyFormat> {\n    return new Set([...this.formats.values()].map(v => v[0]));\n  }\n\n  /**\n   * Decode an array buffer and trigger the relevant data handler.\n   *\n   * When passed an ArrayBufferView, accesses the underlying 'buffer' instance directly.\n   *\n   * @throws {BufferDecodingError} if the buffer failed to decode to the registered format, or header was bad\n   * @throws {UnrecognizedFormatError} if no format is registered that can handle this data\n   */\n  public processBuffer(b: ArrayBuffer | ArrayBufferView): void {\n    let header: number;\n\n    try {\n      header = peekHeader(b);\n    }\n    catch (e) {\n      throw new BufferDecodingError(`Failed to process buffer`, e);\n    }\n\n    if (!this.formats.has(header)) {\n      throw new UnrecognizedFormatError(`Unrecognized format (uint16: ${header}, str: '${hashCodeToStr(header)}')`);\n    }\n\n    const [f, onData] = this.formats.get(header);\n    let data: any;\n\n    try {\n      data = f.decode(b);\n    }\n    catch (e) {\n      throw new BufferDecodingError(`Failed to decode data to format '${f.header}'`, e);\n    }\n\n    onData(data);\n  }\n\n  /**\n   * Register a format handler.\n   */\n  public on<EncoderType extends EncoderDefinition, DecodedType = InferredDecodedType<EncoderType>>(\n    format: BufferFormat<EncoderType, string | number>,\n    callback: (data: DecodedType) => any,\n    overwritePrevious: boolean = false,\n  ): this {\n    if (format.header == null) {\n      throw new TypeError('Cannot register a headerless encoding format.');\n    }\n\n    const header = typeof format.header === 'string' ? strToHashCode(format.header) : format.header;\n\n    if (this.formats.has(header) && !overwritePrevious) {\n      throw new FormatHeaderCollisionError(`Format with identical header was already registered: ${format.header}`);\n    }\n\n    this.formats.set(header, [format, callback]);\n\n    return this;\n  }\n\n  /** Register a format (or formats) that are recognized. */\n  public ignore(...format: AnyFormat[]): this {\n    format.forEach(f => this.on(f, () => {}, true));\n    return this;\n  }\n\n  /** Clears all registered formats and handlers. */\n  public clear(): void {\n    this.formats.clear();\n  }\n}\n","/**\n * Whether the given value is a boolean array.\n */\nexport function isBooleanArray(value: any): value is boolean[] {\n  return Array.isArray(value) && value.every(entry => typeof entry === 'boolean');\n}\n\n/**\n * Encode a boolean array as an integer.\n * Modified version of: https://github.com/geckosio/typed-array-buffer-schema/blob/d1e2330c8910e29280ab59e92619e5019b6405d4/src/serialize.ts#L29\n */\nexport function fixedLengthBooleanArrayToBitmask(booleanArray: boolean[], length: 8 | 16 | 32): number {\n  let str = '';\n  for (let i = 0; i < length; i++) {\n    str += +!!booleanArray[i];\n  }\n  return parseInt(str, 2);\n}\n\n/**\n * Encode a boolean array as an integer.\n * Modified version of: https://github.com/geckosio/typed-array-buffer-schema/blob/d1e2330c8910e29280ab59e92619e5019b6405d4/src/serialize.ts#L29\n */\nexport function bools2Mask(booleanArray: boolean[]): number {\n  let str = '';\n  for (let i = 0; i < booleanArray.length; i++) {\n    str += +!!booleanArray[i];\n  }\n  return parseInt(str, 2);\n}\n\n/**\n * Decode a boolean array as an integer.\n * Modified version of: https://github.com/geckosio/typed-array-buffer-schema/blob/d1e2330c8910e29280ab59e92619e5019b6405d4/src/serialize.ts#L39\n */\nexport function mask2Bools(int: number, length: 8 | 16 | 32): boolean[] {\n  return [...(int >>> 0).toString(2).padStart(length, '0')].map(e => (e == '0' ? false : true));\n}\n\n/**\n * Decode a boolean array as an integer.\n * Modified version of: https://github.com/geckosio/typed-array-buffer-schema/blob/d1e2330c8910e29280ab59e92619e5019b6405d4/src/serialize.ts#L39\n */\nexport function uInt8ToBooleanArray(int: number): boolean[] {\n  return [...(int >>> 0).toString(2)].map(e => (e == '0' ? false : true));\n}\n","/** Clamp a number to a range. */\nexport function clamp(value: number, min: number, max: number): number {\n  return Math.min(Math.max(value, min), max);\n}\n\n/** Round toward zero */\nexport function r2z(x: number): number {\n  return x < 0 ? Math.ceil(x) : Math.floor(x);\n}\n/** Round away zero */\nexport function raz(x: number): number {\n  return x < 0 ? Math.floor(x) : Math.ceil(x);\n}\n","import { clamp, r2z, raz } from \"./math\";\n\n/** @returns A UInt8 bitmask representation. */\nexport function toUScalar8(uScalar: number): number {\n  return Number.isNaN(uScalar) ? 255 : clamp(127 + r2z(uScalar * 254 - 127), 0, 254);\n}\n\n/** @returns A UInt8 bitmask representation. */\nexport function toScalar8(scalar: number): number {\n  return Number.isNaN(scalar) ? 255 : clamp(r2z(scalar * 127), -127, 127) + 127;\n}\n\n/** @returns An unsigned scalar between 0.0 and 1.0. */\nexport function fromUScalar8(uInt8: number): number {\n  // Make symmetric: (0.5 + round((uint8 - 127) / 254 * 100)) / 100\n  return uInt8 === 255 ? NaN : clamp((raz((uInt8 - 127) * 0.3937007874015748) + 50) * 0.01, 0, 1);\n}\n\n/** @returns A signed scalar between -1.0 and 1.0. */\nexport function fromScalar8(uInt8: number): number {\n  // Make symmetric: round((uint8 - 127) / 127 * 100) / 100\n  return uInt8 === 255 ? NaN : clamp(raz((uInt8 - 127) * 0.787401574803149) * 0.01, -1, 1);\n}\n\n/**\n * Quantize a number to an 8-bit scalar between 0.0 and 1.0.\n *\n * @param doubleFloat A number.\n * @returns A number (double) in its closest signed scalar representation.\n */\nexport function uScalarRound(doubleFloat: number): number {\n  return fromUScalar8(toUScalar8(doubleFloat));\n}\n\n/**\n * Quantize a number to an 8-bit signed scalar between -1.0 and 1.0.\n *\n * @param doubleFloat A number.\n * @returns A number (double) in its closest signed scalar representation.\n */\nexport function scalarRound(doubleFloat: number): number {\n  return fromScalar8(toScalar8(doubleFloat));\n}\n","import { BufferWriter } from './BufferWriter';\nimport { BufferReader } from './BufferReader';\nimport * as boolArray from './boolArray';\nimport { r2z } from './math';\nimport {\n  fromUScalar8,\n  fromScalar8,\n  toUScalar8,\n  toScalar8\n} from './scalar';\nimport { WriteTypeError } from './errors';\n\n// Pre-calculated constants\nconst MAX_AUTO_UINT8 = 128,\n  MAX_AUTO_UINT16 = 16_384,\n  MAX_AUTO_UINT32 = 536_870_912,\n  MAX_AUTO_INT8 = 64,\n  MAX_AUTO_INT16 = 8_192,\n  MAX_AUTO_INT32 = 268_435_456,\n  MAX_INT8 = 127,\n  MAX_INT16 = 32_767,\n  MAX_INT32 = 2_147_483_647,\n  MAX_UINT8 = 255,\n  MAX_UINT16 = 65_535,\n  MAX_UINT32 = 4_294_967_295,\n  POW_32 = 4_294_967_296;\n\nconst utf8Decoder = new TextDecoder('utf-8');\n\nexport interface BinaryTypeCoder<T, R = T> {\n  write(value: T, data: BufferWriter, path?: string): void;\n  read(state: BufferReader): R;\n}\n\n/**\n * Formats (big-endian):\n * 7b  0xxx xxxx\n * 14b  10xx xxxx  xxxx xxxx\n * 29b  110x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx\n * 61b  111x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx\n */\nexport const uintCoder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number' || value > Number.MAX_SAFE_INTEGER || value < 0) {\n      throw new WriteTypeError('uint', value, path);\n    }\n\n    const uIntValue = r2z(value);\n\n    if (uIntValue < MAX_AUTO_UINT8) {\n      data.writeUInt8(uIntValue);\n    }\n    else if (uIntValue < MAX_AUTO_UINT16) {\n      data.writeUInt16(uIntValue + 0x8000);\n    }\n    else if (uIntValue < MAX_AUTO_UINT32) {\n      data.writeUInt32(uIntValue + 0xc0000000);\n    }\n    else {\n      // Split in two 32b uints\n      data.writeUInt32(Math.floor(uIntValue / POW_32) + 0xe0000000);\n      data.writeUInt32(uIntValue >>> 0);\n    }\n  },\n  read: function (state) {\n    const firstByte = state.peekUInt8();\n\n    if (!(firstByte & 0x80)) {\n      state.skipByte();\n      return firstByte;\n    }\n    else if (!(firstByte & 0x40)) {\n      return state.readUint16() - 0x8000;\n    }\n    else if (!(firstByte & 0x20)) {\n      return state.readUint32() - 0xc0000000;\n    }\n    else {\n      return (state.readUint32() - 0xe0000000) * POW_32 + state.readUint32();\n    }\n  }\n};\n\nexport const uint8Coder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number' || value < 0 || value > MAX_UINT8) {\n      throw new WriteTypeError('uint8', value, path);\n    }\n    data.writeUInt8(r2z(value));\n  },\n  read: function (state) {\n    return state.readUint8();\n  }\n};\n\nexport const uint16Coder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number' || value < 0 || value > MAX_UINT16) {\n      throw new WriteTypeError('uint16', value, path);\n    }\n    data.writeUInt16(r2z(value));\n  },\n  read: function (state) {\n    return state.readUint16();\n  }\n};\n\nexport const uint32Coder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number' || value < 0 || value > MAX_UINT32) {\n      throw new WriteTypeError('uint32', value, path);\n    }\n    data.writeUInt32(r2z(value));\n  },\n  read: function (state) {\n    return state.readUint32();\n  }\n};\n\n/**\n * Same formats as uintCoder.\n *\n * @see {uintCoder}\n */\nexport const intCoder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number' || value > Number.MAX_SAFE_INTEGER || value < -Number.MAX_SAFE_INTEGER) {\n      throw new WriteTypeError('int', value, path);\n    }\n\n    const intValue = r2z(value);\n\n    if (intValue >= -MAX_AUTO_INT8 && intValue < MAX_AUTO_INT8) {\n      data.writeUInt8(intValue & 0x7f);\n    }\n    else if (intValue >= -MAX_AUTO_INT16 && intValue < MAX_AUTO_INT16) {\n      data.writeUInt16((intValue & 0x3fff) + 0x8000);\n    }\n    else if (intValue >= -MAX_AUTO_INT32 && intValue < MAX_AUTO_INT32) {\n      data.writeUInt32((intValue & 0x1fffffff) + 0xc0000000);\n    }\n    else {\n      // Split in two 32b uints\n      data.writeUInt32((Math.floor(intValue / POW_32) & 0x1fffffff) + 0xe0000000);\n      data.writeUInt32(intValue >>> 0);\n    }\n  },\n  read: function (state) {\n    let firstByte = state.peekUInt8(), i: number;\n\n    if (!(firstByte & 0x80)) {\n      state.skipByte();\n      return (firstByte & 0x40) ? (firstByte | 0xffffff80) : firstByte;\n    }\n    else if (!(firstByte & 0x40)) {\n      i = state.readUint16() - 0x8000;\n      return (i & 0x2000) ? (i | 0xffffc000) : i;\n    }\n    else if (!(firstByte & 0x20)) {\n      i = state.readUint32() - 0xc0000000;\n      return (i & 0x10000000) ? (i | 0xe0000000) : i;\n    }\n    else {\n      i = state.readUint32() - 0xe0000000;\n      i = (i & 0x10000000) ? (i | 0xe0000000) : i;\n      return i * POW_32 + state.readUint32();\n    }\n  }\n};\n\nexport const int8Coder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number' || value < -MAX_INT8 || value > MAX_INT8) {\n      throw new WriteTypeError('int8', value, path);\n    }\n    data.writeInt8(r2z(value));\n  },\n  read: function (state) {\n    return state.readInt8();\n  }\n};\n\nexport const int16Coder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number' || value < -MAX_INT16 || value > MAX_INT16) {\n      throw new WriteTypeError('int16', value, path);\n    }\n    data.writeInt16(r2z(value));\n  },\n  read: function (state) {\n    return state.readInt16();\n  }\n};\n\nexport const int32Coder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number' || value < -MAX_INT32 || value > MAX_INT32) {\n      throw new WriteTypeError('int32', value, path);\n    }\n    data.writeInt32(r2z(value));\n  },\n  read: function (state) {\n    return state.readInt32();\n  }\n};\n\n/**\n * 16-bit half precision float\n */\nexport const float16Coder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number') {\n      throw new WriteTypeError('number', value, path);\n    }\n    data.writeFloat16(value);\n  },\n  read: function (state) {\n    return state.readFloat16();\n  }\n};\n\n/**\n * 32-bit single precision float\n */\nexport const float32Coder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number') {\n      throw new WriteTypeError('number', value, path);\n    }\n    data.writeFloat32(value);\n  },\n  read: function (state) {\n    return state.readFloat32();\n  }\n};\n\n/**\n * 64-bit double precision float\n */\nexport const float64Coder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number') {\n      throw new WriteTypeError('number', value, path);\n    }\n    data.writeFloat64(value);\n  },\n  read: function (state) {\n    return state.readFloat64();\n  }\n};\n\n/**\n * Scalar between 0.0 and 1.0.\n */\nexport const uscalarCoder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number') {\n      throw new WriteTypeError('number', value, path);\n    }\n    data.writeUInt8(toUScalar8(value));\n  },\n  read: function (state) {\n    return fromUScalar8(state.readUint8());\n  }\n};\n\n/**\n * Signed scalar between -1.0 and 1.0.\n */\nexport const scalarCoder: BinaryTypeCoder<number> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'number') {\n      throw new WriteTypeError('number', value, path);\n    }\n    data.writeUInt8(toScalar8(value));\n  },\n  read: function (state) {\n    return fromScalar8(state.readUint8());\n  }\n};\n\n/**\n * <uint_length> <buffer_data>\n */\nexport const stringCoder: BinaryTypeCoder<string> = {\n  write: function (value, data, path) {\n    bufferCoder.write(new TextEncoder().encode(value ?? ''), data, path);\n  },\n  read: function (state) {\n    return utf8Decoder.decode(bufferCoder.read(state));\n  }\n};\n\n/**\n * <uint_length> <buffer_data>\n */\nexport const bufferCoder: BinaryTypeCoder<ArrayBuffer | ArrayBufferView, Uint8Array> = {\n  write: function (value, data, path) {\n    uintCoder.write(value.byteLength, data, path);\n    data.writeBuffer(value);\n  },\n  read: function (state): Uint8Array {\n    return state.readBuffer(uintCoder.read(state));\n  }\n};\n\n/**\n * either 0x00 or 0x01\n */\nexport const booleanCoder: BinaryTypeCoder<boolean> = {\n  write: function (value, data, path) {\n    if (typeof value !== 'boolean') {\n      throw new WriteTypeError('boolean', value, path);\n    }\n    data.writeUInt8(value ? 1 : 0);\n  },\n  read: function (state) {\n    const value = state.readUint8();\n    return Boolean(value !== 0);\n  }\n};\n\n/**\n * Encode any number of booleans as one or more UInt8s.\n *\n * <padding> <is_last> <payload ...>\n */\nexport const booleanArrayCoder: BinaryTypeCoder<boolean[]> = {\n  write: function (value, data, path) {\n    if (!boolArray.isBooleanArray(value)) {\n      throw new WriteTypeError('boolean[]', value, path);\n    }\n\n    const chunkSize = 6;\n    for (let i = 0; i < Math.max(1, value.length); i += chunkSize) {\n      const isFinalChunk = i + chunkSize >= value.length;\n      const intValue = boolArray.bools2Mask([\n        true, // positive header\n        isFinalChunk,\n        ...value.slice(i, i + chunkSize)\n      ]);\n\n      data.writeUInt8(intValue);\n    }\n  },\n  read: function (state) {\n    const values: boolean[] = [];\n    let isFinalChunk = false;\n\n    while (!isFinalChunk) {\n      const bitmask = state.readUint8();\n      const chunk = boolArray.uInt8ToBooleanArray(bitmask);\n      chunk.shift(); // pop header\n      isFinalChunk = chunk.shift();\n\n      values.push(...chunk);\n    }\n\n    return values;\n  }\n};\n\n/**\n * Encode exactly 8 booleans as a UInt8.\n */\nexport const bitmask8Coder: BinaryTypeCoder<boolean[]> = {\n  write: function (value, data, path) {\n    if (!boolArray.isBooleanArray(value)) {\n      throw new WriteTypeError('boolean[]', value, path);\n    }\n\n    const bitmask = boolArray.fixedLengthBooleanArrayToBitmask(value, 8);\n    data.writeUInt8(bitmask);\n  },\n  read: function (state) {\n    const bitmask = state.readUint8();\n    return boolArray.mask2Bools(bitmask, 8);\n  }\n};\n\n/**\n * Encode exactly 16 booleans as a UInt16.\n */\nexport const bitmask16Coder: BinaryTypeCoder<boolean[]> = {\n  write: function (value, data, path) {\n    if (!boolArray.isBooleanArray(value)) {\n      throw new WriteTypeError('boolean[]', value, path);\n    }\n\n    const bitmask = boolArray.fixedLengthBooleanArrayToBitmask(value, 16);\n    data.writeUInt16(bitmask);\n  },\n  read: function (state) {\n    const bitmask = state.readUint16();\n    return boolArray.mask2Bools(bitmask, 16);\n  }\n};\n\n/**\n * Encode exactly 32 booleans as a UInt32.\n */\nexport const bitmask32Coder: BinaryTypeCoder<boolean[]> = {\n  write: function (value, data, path) {\n    if (!boolArray.isBooleanArray(value)) {\n      throw new WriteTypeError('boolean[]', value, path);\n    }\n    const bitmask = boolArray.fixedLengthBooleanArrayToBitmask(value, 32);\n    data.writeUInt32(bitmask);\n  },\n  read: function (state) {\n    const bitmask = state.readUint32();\n    return boolArray.mask2Bools(bitmask, 32);\n  }\n};\n\n/**\n * <uint_length> <buffer_data>\n */\nexport const jsonCoder: BinaryTypeCoder<any> = {\n  write: function (value, data, path) {\n    let stringValue: string;\n    try {\n      stringValue = JSON.stringify(value);\n    }\n    catch (error) {\n      throw new WriteTypeError('JSON', error, path);\n    }\n\n    stringCoder.write(stringValue, data, path);\n  },\n  read: function (state) {\n    const stringValue = stringCoder.read(state);\n    return JSON.parse(stringValue);\n  }\n};\n\n/**\n * <uint_source_length> <buffer_source_data> <flags>\n * flags is a bit-mask: g=1, i=2, m=4\n */\nexport const regexCoder: BinaryTypeCoder<RegExp> = {\n  write: function (value, data, path) {\n    if (!(value instanceof RegExp)) {\n      throw new WriteTypeError('RegExp', value, path);\n    }\n\n    let g: number, i: number, m: number;\n    stringCoder.write(value.source, data, path);\n    g = value.global ? 1 : 0;\n    i = value.ignoreCase ? 2 : 0;\n    m = value.multiline ? 4 : 0;\n    data.writeUInt8(g + i + m);\n  },\n  read: function (state) {\n    const source = stringCoder.read(state),\n      flags = state.readUint8(),\n      g = flags & 0x1 ? 'g' : '',\n      i = flags & 0x2 ? 'i' : '',\n      m = flags & 0x4 ? 'm' : '';\n    return new RegExp(source, g + i + m);\n  }\n};\n\n/**\n * <uint_time_ms>\n */\nexport const dateCoder: BinaryTypeCoder<Date> = {\n  write: function (value, data, path) {\n    if (!(value instanceof Date)) {\n      throw new WriteTypeError('Date', value, path);\n    }\n    else {\n      const time = value.getTime();\n      if (isNaN(time)) {\n        throw new WriteTypeError('Date', 'NaN', path);\n      }\n      intCoder.write(time, data, path);\n    }\n  },\n  read: function (state) {\n    return new Date(intCoder.read(state));\n  }\n};\n","/** Default maximum transmission unit in networking */\nconst MTU = 1500;\n\nexport const setTinybufConfig = (newSettings: Partial<typeof SETTINGS>): void => {\n  SETTINGS = { ...SETTINGS, ...newSettings };\n};\n\nexport let SETTINGS = {\n  /**\n   * (default: false) When enabled, shares one write buffer (default: each format manages its own buffer).\n   * Use to maximise performance and memory re-use, just be cautious of possible race conditions.\n   *\n   * Note: The global buffer is initialized to `SETTINGS.encodingBufferMaxSize`\n   */\n  useGlobalEncodingBuffer: false,\n\n  /** (default: 1500) When automatically increasing buffer length, this is the most bytes to allocate */\n  encodingBufferMaxSize: MTU,\n\n  /** (default: 256) How many bytes to allocate to a new write buffer */\n  encodingBufferInitialSize: 256,\n\n  /** (default: 256) When automatically increasing buffer length, this is the amount of new bytes to allocate */\n  encodingBufferIncrement: 256,\n\n  /** (default: false) Emits debug console logs (e.g. for memory allocation) */\n  debug: false,\n};\n","/* eslint-disable @typescript-eslint/no-extraneous-class */\n\nconst FLOAT16_PRECALCULATE_SUBNORMAL = Math.pow(2, -24);\n\n/**\n * Convert a number to the nearest 16-bit half precision float representation (as a UInt16 bitmask).\n *\n * @param doubleFloat A number.\n * @returns A UInt16 bitmask representation of a half precision float.\n *\n * @see https://stackoverflow.com/a/32633586\n */\nexport const f16mask = (function() {\n  const floatView = new Float32Array(1);\n  const int32View = new Int32Array(floatView.buffer);\n\n  // This method is faster than the OpenEXR implementation (very often\n  // used, eg. in Ogre), with the additional benefit of rounding, inspired\n  // by James Tursa's half-precision code.\n  return function toHalf(v: number): number {\n    floatView[0] = v;\n    const x = int32View[0];\n\n    let b = (x >> 16) & 0b1000000000000000;\n    let m = (x >> 12) & 0b0000011111111111;\n    const e = (x >> 23) & 0b0000000011111111;\n\n    // If zero, or denormal, or exponent underflows too much for a denormal\n    // half, return signed zero.\n    if (e < 103) return b;\n\n    // If NaN, return NaN. If Inf or exponent overflow, return Inf.\n    if (e > 142) {\n      if (isNaN(v)) return 0b0111110000000001; // Float 16 NaN\n\n      b |= 0x7c00;\n\n      // If exponent was 0xff and one significand bit was set, it means NaN,\n      // not Inf, so make sure we set one significand bit too.\n      b |= ((e == 255) ? 0 : 1) && (x & 0x007fffff);\n      return b;\n    }\n\n    // If exponent underflows but not too much, return a denormal\n    if (e < 113) {\n      m |= 0x0800;\n      // Extra rounding may overflow and set significand to 0 and exponent\n      // to 1, which is OK.\n      b |= (m >> (114 - e)) + ((m >> (113 - e)) & 1);\n      return b;\n    }\n\n    b |= ((e - 112) << 10) | (m >> 1);\n\n    // Extra rounding. An overflow will set significand to 0 and increment\n    // the exponent, which is OK.\n    b += m & 1;\n\n    return b;\n  };\n}());\n\n\n/**\n * Convert a UInt16 bitmask of a 16-bit half precision float representation into\n * a double precision float (number).\n *\n * @param b A UInt16 bitmask representation of a half precision float.\n * @returns A number (standard 64-bit double precision representation).\n */\nexport function f16unmask(b: number): number {\n  // eslint-disable-next-line max-len\n  if ((b & 0x8000) === 0) return f16.t[(((/* exponent: */ b >> 10 /* FLOAT16_SIGNIFICAND_BITS */) & 0x1F) << 10 /* FLOAT16_SIGNIFICAND_BITS */) + (/* significand: */ b & 0x3FF  /* FLOAT16_SIGNIFICAND_MASK */)];\n  else return -f16.t[(((/* exponent: */ b >> 10 /* FLOAT16_SIGNIFICAND_BITS */) & 0x1F) << 10 /* FLOAT16_SIGNIFICAND_BITS */) + (/* significand: */ b & 0x3FF  /* FLOAT16_SIGNIFICAND_MASK */)];\n}\n\n/**\n * The fround16() method returns the nearest 16-bit half precision float representation of a number.\n *\n * @param doubleFloat A number.\n * @returns The nearest 16-bit half precision float representation of x.\n */\nexport function fround16(doubleFloat: number): number {\n  return f16unmask(f16mask(doubleFloat));\n}\n\n// ----- Precomputed table: -----\n\n/** precomputed table of the conversion factors for each possible combination of exponent and significand bits (unsigned) */\nclass f16 {\n  public static readonly t = this._initFloat16LookupTable(); // static: lazy initializer\n\n  private static _initFloat16LookupTable(): number[] {\n    const t = [];\n    for (let exponent = 0; exponent < 1 << 5 /* FLOAT16_EXPONENT_BITS */; exponent++) {\n      for (let significand = 0; significand < 1 << 10 /* FLOAT16_SIGNIFICAND_BITS */; significand++) {\n        const value = f16.precalc(exponent, significand);\n        t[(exponent << 10 /* FLOAT16_SIGNIFICAND_BITS */) + significand] = value;\n      }\n    }\n    return t;\n  }\n\n\n  /** precalculate the value for a given exponent and significand */\n  private static precalc(exponent: number, significand: number): number {\n    if (exponent === 0) {\n      if (significand === 0) return 0; // subnormal or zero\n      return FLOAT16_PRECALCULATE_SUBNORMAL * (significand / 1024); // Subnormal\n    }\n    if (exponent === 0x1F /* FLOAT16_EXPONENT_MASK */) return significand === 0 ? Infinity : NaN; // Infinity or NaN\n    // normalize\n    exponent -= 15 /* FLOAT16_EXPONENT_BIAS */; // adjust exponent bias\n    return Math.pow(2, exponent) * (1 + significand / 1024);\n  }\n}","import { SETTINGS } from \"../settings\";\nimport { BufferEncodingError } from \"./errors\";\nimport { f16mask } from \"./float16\";\n\n/**\n * Wraps a view into an underlying buffer, and can be dynamically resized.\n */\nexport class BufferWriter {\n  /** byteOffset */\n  public o: number = 0;\n\n  private view: DataView;\n  private buf: ArrayBuffer;\n  private resize: boolean = true;\n\n  public constructor(value: number | ArrayBuffer) {\n    if (value instanceof ArrayBuffer) {\n      this.buf = value;\n      this.resize = false;\n      if (SETTINGS.debug) {\n        console.debug(`[tinybuf] assigning buffer writer to global encoding buffer`);\n      }\n    }\n    else {\n      if (SETTINGS.debug) {\n        console.debug(`[tinybuf] allocating new buffer (${value} bytes)`);\n      }\n      this.buf = new ArrayBuffer(value);\n    }\n    this.view = new DataView(this.buf, 0, this.buf.byteLength);\n  }\n\n  public asView(): Uint8Array {\n    return new Uint8Array(this.view.buffer, 0, this.o);\n  }\n\n  public asCopy(): Uint8Array {\n    return new Uint8Array(this.view.buffer.slice(0, this.o));\n  }\n\n  // ----- Writers: -----\n\n  public writeInt8(value: number): void {\n    this.view.setInt8(this.alloc(1), value);\n  }\n\n  public writeInt16(value: number): void {\n    this.view.setInt16(this.alloc(2), value, true);\n  }\n\n  public writeInt32(value: number): void {\n    this.view.setInt32(this.alloc(4), value, true);\n  }\n\n  public writeUInt8(value: number): void {\n    this.view.setUint8(this.alloc(1), value);\n  }\n\n  public writeUInt16(value: number): void {\n    this.view.setUint16(this.alloc(2), value);\n  }\n\n  public writeUInt32(value: number): void {\n    this.view.setUint32(this.alloc(4), value);\n  }\n\n  public writeFloat16(value: number): void {\n    this.view.setUint16(this.alloc(2), f16mask(value));\n  }\n\n  public writeFloat32(value: number): void {\n    this.view.setFloat32(this.alloc(4), value);\n  }\n\n  public writeFloat64(value: number): void {\n    this.view.setFloat64(this.alloc(8), value);\n  }\n\n  public writeBuffer(b: ArrayBuffer | ArrayBufferView): void {\n    const byteOffset = this.alloc(b.byteLength);\n    const readView = b instanceof Uint8Array ? b\n      : b instanceof ArrayBuffer ? new Uint8Array(b)\n        : new Uint8Array(b.buffer, b.byteOffset, b.byteLength);\n    new Uint8Array(this.view.buffer, byteOffset, b.byteLength).set(readView);\n  }\n\n  // ----- Private methods: -----\n\n  /** Allocate the given number of bytes, and then return the current header position (byteOffset). */\n  private alloc(bytes: number): number {\n    const byteOffset = this.o;\n\n    if (this.o + bytes <= this.view.byteLength) {\n      this.o += bytes;\n\n      return byteOffset;\n    }\n\n    if (!this.resize) {\n      throw new BufferEncodingError(`Write buffer exceeded maximum size of global buffer.`);\n    }\n\n    const currentAlloc = this.view.byteLength;\n    const minRequestedSize = currentAlloc + bytes;\n    if (minRequestedSize > SETTINGS.encodingBufferMaxSize) {\n      throw new BufferEncodingError(`Write buffer exceeded maximum size. Bytes requested: ${minRequestedSize}. Max size: ${SETTINGS.encodingBufferMaxSize}.`);\n    }\n\n    let newLength = this.view.byteLength;\n    do {\n      newLength = Math.min(newLength + SETTINGS.encodingBufferIncrement, SETTINGS.encodingBufferMaxSize);\n    }\n    while (newLength < this.o + bytes);\n\n    if (SETTINGS.debug) {\n      console.debug(`[tinybuf] resizing buffer ${currentAlloc} -> ${newLength}`);\n    }\n\n    // copy bytes to new buffer\n    const newBuffer = new ArrayBuffer(newLength);\n    const currentData = new Uint8Array(this.view.buffer, this.view.byteOffset, currentAlloc);\n    new Uint8Array(newBuffer).set(currentData);\n\n    // update the view\n    this.buf = newBuffer;\n    this.view = new DataView(newBuffer);\n\n    // increment the pointer\n    this.o += bytes;\n\n    return byteOffset;\n  }\n}\n","import { f16unmask } from \"./float16\";\n\n/**\n * Wraps a buffer with a read head pointer.\n */\nexport class BufferReader {\n  private i: number;\n  private data: DataView;\n\n  public constructor(b: Uint8Array | ArrayBufferView | ArrayBuffer, byteOffset?: number) {\n    this.data = b instanceof ArrayBuffer ? new DataView(b) : new DataView(b.buffer, b.byteOffset, b.byteLength);\n    this.i = byteOffset ?? 0;\n  }\n\n  public get hasEnded(): boolean {\n    return this.i === this.data.byteLength;\n  }\n\n  /** Read the next byte, without moving the read head pointer. */\n  public peekUInt8(): number {\n    return this.data.getUint8(this.i);\n  }\n\n  /** used to skip bytes for reading type headers. */\n  public skipByte(): void {\n    this.i++;\n  }\n\n  // ----- Readers: -----\n\n  public readUint8(): number {\n    return this.data.getUint8(this.i++);\n  }\n\n  public readUint16(): number {\n    const r = this.data.getUint16(this.i);\n    this.i += 2;\n    return r;\n  }\n\n  public readUint32(): number {\n    const r = this.data.getUint32(this.i);\n    this.i += 4;\n    return r;\n  }\n\n  public readInt8(): number {\n    return this.data.getInt8(this.i++);\n  }\n\n  public readInt16(): number {\n    const r = this.data.getInt16(this.i, true);\n    this.i += 2;\n    return r;\n  }\n\n  public readInt32(): number {\n    const r = this.data.getInt32(this.i, true);\n    this.i += 4;\n    return r;\n  }\n\n  public readFloat16(): number {\n    const r = this.data.getUint16(this.i);\n    this.i += 2;\n    return f16unmask(r);\n  }\n\n  public readFloat32(): number {\n    const r = this.data.getFloat32(this.i);\n    this.i += 4;\n    return r;\n  }\n\n  public readFloat64(): number {\n    const r = this.data.getFloat64(this.i);\n    this.i += 8;\n    return r;\n  }\n\n  /** @throws RangeError if exceeds length */\n  public readBuffer(bytes: number): Uint8Array {\n    if (this.i + bytes > this.data.byteLength) {\n      throw new RangeError('Trying to access beyond byte length');\n    }\n\n    const view = new Uint8Array(this.data.buffer, this.i, bytes);\n    this.i += bytes;\n\n    return view;\n  }\n}\n","\n/**\n * Binary coder types.\n */\nexport const enum Type {\n  /**\n   * Boolean value (1 byte).\n   * @see {Bools8} for packing multiple booleans into a single byte.\n   */\n  Bool = 'bool',\n\n  /** A string (1† byte header + string bytes). */\n  String = 'str',\n\n  /** Floating-point number (16-bit, half precision, 2 bytes). */\n  Float16 = 'float16',\n\n  /** Floating-point number (32-bit, single precision, 4 bytes). */\n  Float32 = 'float32',\n\n  /** Floating-point number (64-bit, double precision, 8 bytes). Default JavaScript `number` type. */\n  Float64 = 'float64',\n\n  /**\n   * Signed integer (1 - 8 bytes).\n   * - 0 → ±64 = 1 byte\n   * - … → ±8,192 = 2 bytes\n   * - … → ±268,435,456 = 4 bytes\n   * - … → ±`Number.MAX_SAFE_INTEGER` = 8 bytes\n   */\n  Int = 'int',\n\n  /** Signed 1 byte integer (between -127 and 127). */\n  Int8 = 'int8',\n\n  /** Signed 2 byte integer (between -32,767 and 32,767). */\n  Int16 = 'int16',\n\n  /** Signed 4 byte integer (between -2,147,483,647 and 2,147,483,647). */\n  Int32 = 'int32',\n\n  /**\n   * Unsigned integer (1 - 8 bytes).\n   * - 0 → 127 = 1 byte\n   * - 128 → 16,384 = 2 bytes\n   * - 16,385 → 536,870,911 = 4 bytes\n   * - 536,870,912 → `Number.MAX_SAFE_INTEGER` = 8 bytes\n   */\n  UInt = 'uint',\n\n  /** Unsigned 8-bit integer (between 0 and 255, 1 byte). */\n  UInt8 = 'uint8',\n\n  /** Unsigned 16-bit integer (between 0 and 65,535, 2 bytes). */\n  UInt16 = 'uint16',\n\n  /** Unsigned 32-bit integer (between 0 and 4,294,967,295, 4 bytes). */\n  UInt32 = 'uint32',\n\n  /** A signed scalar between -1.00 and 1.00 (1 byte). */\n  Scalar = 'scalar',\n\n  /** An unsigned scalar between 0.00 and 1.00 (1 byte). */\n  UScalar = 'uscalar',\n\n  // ---- Advanced types: -----\n\n  /** Any Uint8Array, ArrayBuffer or ArrayBufferLike value (1† byte header + buffer bytes). */\n  Buffer = 'buf',\n\n  /**\n   * A JavaScript date object.\n   *\n   * Encoded as an 8 byte (64-bit) integer UTC timestamp from as the number\n   * of milliseconds since the Unix Epoch (January 1, 1970, 00:00:00 UTC).\n   *\n   * @see {Date}\n   */\n  Date = 'date',\n\n  /** A JavaScript regular expression. */\n  RegExp = 'regex',\n\n  /** Any JSON-serializable data. Encodes as a UTF-8 string. */\n  JSON = 'json',\n\n  /** Up to 8 booleans (1 byte). */\n  Bools8 = 'bitmask8',\n\n  /** Up to 16 booleans (2 bytes). */\n  Bools16 = 'bitmask16',\n\n  /** Up to 32 booleans (4 bytes). */\n  Bools32 = 'bitmask32',\n\n  /** Any array of booleans (0¶ byte / 2-bit header). */\n  Bools = 'booltuple',\n\n  // ----- Data structures: -----\n\n  /** [INTERNAL ONLY] Use \"[T]\" array syntax instead. */\n  Array = '[array]',\n\n  /** [INTERNAL ONLY] Use \"{}\" object syntax instead. */\n  Object = '{object}',\n\n  // ----- Aliases: -----\n\n  /** Alias for `Type.Float16` @see {Float16} */\n  Half = 'float16',\n\n  /** Alias for `Type.Float32` @see {Float32} */\n  Single = 'float32',\n\n  /** Alias for `Type.Float64` @see {Float64} */\n  Double = 'float64',\n\n  /** Alias for `Type.Float64 @see {Float64} */\n  Number = 'float64',\n\n  /** Alias for `Type.Bool` @see {Bool} */\n  Boolean = 'bool',\n\n  /** Alias for 'Type.UInt' @see {UInt} */\n  Enum = 'uint',\n}\n\n/** All value types - excluding array, object and optional */\nexport const VALID_VALUE_TYPES: readonly string[] = [\n  // Floats\n  Type.Float16,\n  Type.Float32,\n  Type.Float64,\n  // Integers\n  Type.Int,\n  Type.Int8,\n  Type.Int16,\n  Type.Int32,\n  Type.UInt,\n  Type.UInt8,\n  Type.UInt16,\n  Type.UInt32,\n  // Scalars\n  Type.UScalar,\n  Type.Scalar,\n  // Boolean\n  Type.Bool,\n  Type.Bools,\n  Type.Bools8,\n  Type.Bools16,\n  Type.Bools32,\n  // Other\n  Type.String,\n  Type.Date,\n  Type.RegExp,\n  Type.JSON,\n  Type.Buffer,\n] as const;\n\n/**\n * Mappings for the value types.\n */\nexport type ValueTypes = {\n  // Floats\n  [Type.Float16]: number;\n  [Type.Float32]: number;\n  [Type.Float64]: number;\n  // Integers\n  [Type.Int]: number;\n  [Type.Int8]: number;\n  [Type.Int16]: number;\n  [Type.Int32]: number;\n  [Type.UInt]: number;\n  [Type.UInt8]: number;\n  [Type.UInt16]: number;\n  [Type.UInt32]: number;\n  // Scalar\n  [Type.UScalar]: number;\n  [Type.Scalar]: number;\n  // Boolean\n  [Type.Bool]: boolean;\n  [Type.Bools]: boolean[];\n  [Type.Bools8]: boolean[];\n  [Type.Bools16]: boolean[];\n  [Type.Bools32]: boolean[];\n  // Other\n  [Type.String]: string;\n  [Type.Date]: Date;\n  [Type.RegExp]: RegExp;\n  [Type.JSON]: any;\n  [Type.Buffer]: Uint8Array | ArrayBuffer | ArrayBufferView;\n};\n\n/** @throws any error too */\nexport type ValidationFn<T> = (x: T) => undefined | boolean | Error;\nexport type TransformFn<T> = (x: T) => T;\nexport type Transforms<T> = TransformFn<T> | [preEncode: TransformFn<T>] | [preEncode: TransformFn<T> | undefined, postDecode: TransformFn<T> | undefined];\n\n/**\n * A wrapper around any Type definition that declares it as optional.\n */\nexport class OptionalType<T extends FieldDefinition> {\n  public constructor(public type: T) {}\n}\n\n/**\n * Wrap any definition as optional.\n */\nexport function optional<T extends FieldDefinition>(t: T): OptionalType<T> {\n  return new OptionalType(t);\n}\n\n/**\n * A definition for an object binary encoder.\n */\nexport type EncoderDefinition = {\n  [key: string]: FieldDefinition | OptionalType<FieldDefinition>;\n};\n\n/**\n * Definition for an object-field binary encoder.\n */\nexport type FieldDefinition = keyof ValueTypes | [keyof ValueTypes] | EncoderDefinition | [EncoderDefinition] | OptionalType<FieldDefinition>;\n\n/**\n * The resulting type of the decoded data, based on the encoder definition.\n */\nexport type InferredDecodedType<EncoderType extends EncoderDefinition> = {\n  [EKey in keyof EncoderType as EncoderType[EKey] extends OptionalType<any> ? never : EKey]: EncoderType[EKey] extends keyof ValueTypes\n      ? ValueTypes[EncoderType[EKey]]\n      : EncoderType[EKey] extends [keyof ValueTypes]\n        ? Array<ValueTypes[EncoderType[EKey][0]]>\n        : EncoderType[EKey] extends EncoderDefinition\n          ? InferredDecodedType<EncoderType[EKey]>\n          : EncoderType[EKey] extends [EncoderDefinition]\n            ? Array<InferredDecodedType<EncoderType[EKey][number]>>\n            : never;\n} & {\n  [EKey in keyof EncoderType as EncoderType[EKey] extends OptionalType<any> ? EKey : never]?: EncoderType[EKey] extends OptionalType<infer OptionalValue extends keyof ValueTypes>\n    ? ValueTypes[OptionalValue] | undefined\n    : EncoderType[EKey] extends OptionalType<infer OptionalValue extends [keyof ValueTypes]>\n      ? Array<ValueTypes[OptionalValue[0]]> | undefined\n      : EncoderType[EKey] extends OptionalType<infer OptionalValue extends EncoderDefinition>\n        ? InferredDecodedType<OptionalValue> | undefined\n        : never;\n};\n\nexport type InferredTransformConfig<EncoderType extends EncoderDefinition> = {\n [EKey in keyof EncoderType]?: EncoderType[EKey] extends keyof ValueTypes\n     ? Transforms<ValueTypes[EncoderType[EKey]]>\n     : EncoderType[EKey] extends [keyof ValueTypes]\n       ? Transforms<ValueTypes[EncoderType[EKey][0]]>\n       : EncoderType[EKey] extends EncoderDefinition\n         ? InferredTransformConfig<EncoderType[EKey]>\n         : EncoderType[EKey] extends [EncoderDefinition]\n           ? InferredTransformConfig<EncoderType[EKey][number]>\n           : EncoderType[EKey] extends OptionalType<infer OptionalValue extends keyof ValueTypes>\n            ? Transforms<ValueTypes[OptionalValue]>\n            : EncoderType[EKey] extends OptionalType<infer OptionalValue extends [keyof ValueTypes]>\n              ? Transforms<ValueTypes[OptionalValue[0]]>\n              : EncoderType[EKey] extends OptionalType<infer OptionalValue extends EncoderDefinition>\n                ? InferredTransformConfig<OptionalValue> | undefined\n                : never;\n};\n\nexport type InferredValidationConfig<EncoderType extends EncoderDefinition> = {\n [EKey in keyof EncoderType]?: EncoderType[EKey] extends keyof ValueTypes\n     ? ValidationFn<ValueTypes[EncoderType[EKey]]>\n     : EncoderType[EKey] extends [keyof ValueTypes]\n       ? ValidationFn<ValueTypes[EncoderType[EKey][0]]>\n       : EncoderType[EKey] extends EncoderDefinition\n         ? InferredValidationConfig<EncoderType[EKey]>\n         : EncoderType[EKey] extends [EncoderDefinition]\n           ? InferredValidationConfig<EncoderType[EKey][number]>\n           : EncoderType[EKey] extends OptionalType<infer OptionalValue extends keyof ValueTypes>\n            ? ValidationFn<ValueTypes[OptionalValue]>\n            : EncoderType[EKey] extends OptionalType<infer OptionalValue extends [keyof ValueTypes]>\n              ? ValidationFn<ValueTypes[OptionalValue[0]]>\n              : EncoderType[EKey] extends OptionalType<infer OptionalValue extends EncoderDefinition>\n                ? InferredValidationConfig<OptionalValue> | undefined\n                : never;\n};\n","import * as coders from './lib/coders';\nimport { hashCode, strToHashCode } from './lib/hashCode';\nimport { peekHeader, peekHeaderStr } from './lib/peek';\nimport { BufferWriter } from './lib/BufferWriter';\nimport { BufferReader } from './lib/BufferReader';\nimport {\n  InferredDecodedType,\n  EncoderDefinition,\n  Type,\n  OptionalType,\n  VALID_VALUE_TYPES,\n  InferredTransformConfig,\n  InferredValidationConfig,\n  ValidationFn,\n  Transforms,\n  FieldDefinition\n} from './Type';\nimport { WriteTypeError } from './lib/errors';\nimport { SETTINGS } from './settings';\n\nexport type FormatHeader = string | number;\n\n/**\n * Decoded object types for a given binary format.\n * @example let onData = (data: Decoded<typeof MyBufferFormat>) => {...};\n */\nexport type Decoded<FromBufferFormat> = FromBufferFormat extends BufferFormat<infer EncoderType, any> ? InferredDecodedType<EncoderType> : never;\n\n/**\n * Defines a format for encoding/decoding binary buffers.\n *\n * Optionally customize the identifier, either as a 2-byte string, an unsigned integer (0 -> 65,535), or as `null` to disable entirely.\n *\n * @example\n * const MyFormat = defineFormat({ ... });\n * const MyFormat = defineFormat('ab', { ... });\n * const MyFormat = defineFormat(1234, { ... });\n * const MyFormat = defineFormat(null, { ... });\n */\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(def: T): BufferFormat<T, HeaderType>;\n/**\n * Defines a format for encoding/decoding binary buffers.\n *\n * Optionally customize the identifier, either as a 2-byte string, an unsigned integer (0 -> 65,535), or as `null` to disable entirely.\n *\n * @example\n * const MyFormat = defineFormat({ ... });\n * const MyFormat = defineFormat('ab', { ... });\n * const MyFormat = defineFormat(1234, { ... });\n * const MyFormat = defineFormat(null, { ... });\n */\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(h: HeaderType | null, def: T): BufferFormat<T, HeaderType>;\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(a?: HeaderType | T, b?: T): BufferFormat<T, HeaderType> {\n  return a !== null && typeof a === 'object'\n    ? new BufferFormat<T, HeaderType>(a as T)\n    : new BufferFormat<T, HeaderType>(b as T, a as HeaderType);\n}\n\nfunction isValidHeader(h: FormatHeader): boolean {\n  if (typeof h === 'number') return Number.isInteger(h) && h >= 0 && h <= 65_535;\n  if (typeof h === 'string') return new TextEncoder().encode(h).byteLength === 2;\n  return false;\n}\n\n/**\n * BufferFormat is a utility class for encoding and decoding binary data based\n * on a provided encoding format.\n *\n * @see {header}\n * @see {encode(data)}\n * @see {decode(binary)}\n */\nexport class BufferFormat<EncoderType extends EncoderDefinition, HeaderType extends FormatHeader = number> {\n  /** A global encoding buffer that can be used by all formats */\n  public static globalBuffer?: ArrayBuffer;\n\n  /**\n   * A unique identifier encoded as the first 2 bytes (or `undefined` if headerless).\n   *\n   * @see {peekHeader(...)}\n   * @see {peekHeaderStr(...)}\n   * @see {hashCode}\n   */\n  public readonly header!: HeaderType;\n\n  protected readonly _header!: number;\n  protected readonly type: Type;\n  protected readonly fields!: Field[];\n  protected readonly fieldsMap!: Map<string, Field>;\n\n  protected _hash?: number;\n  protected _format?: string;\n  protected _transforms?: Transforms<any> | undefined;\n  protected _validate?: ValidationFn<any> | undefined;\n  protected _vt = false;\n  protected _w?: BufferWriter;\n\n  public constructor(\n    def: EncoderType,\n    header?: HeaderType | null,\n  ) {\n    // set definition\n    if (def instanceof OptionalType) {\n      throw new TypeError(\"Invalid encoding format: Root object cannot be optionals.\");\n    }\n    else if (def !== undefined && typeof def === 'string' && VALID_VALUE_TYPES.includes(def)) {\n      this.type = def;\n    }\n    else if (def instanceof Object) {\n      this.type = Type.Object;\n      this.fieldsMap = new Map();\n      this.fields = Object.keys(def).map((name) => {\n        const f = new Field(name, def[name]);\n        this.fieldsMap.set(name, f);\n        return f;\n      });\n    }\n    else {\n      throw new TypeError(\"Invalid encoding format: Must be an object, or a known coder type.\");\n    }\n\n    // set headers\n    if (header === undefined && this.type === Type.Object) {\n      this.header = this.hashCode as HeaderType; // automatic\n      this._header = this.header as number;\n    }\n    else if (header === null) {\n      this.header = undefined; // headerless\n      this._header = undefined;\n    }\n    else if (isValidHeader(header)) {\n      this.header = header; // manual\n      this._header = typeof header === 'number' ? header : strToHashCode(header);\n    }\n    else {\n      throw new TypeError(`Header should be an integer between 0 and 65535, a 2-byte string, or null. Received: ${header}`);\n    }\n  }\n\n  // ----- Static methods: -----\n\n  /**\n   * Read the header of a buffer as a number.\n   *\n   * @see {header}\n   * @throws {RangeError} if buffer size < 2\n   */\n  public static peekHeader = peekHeader;\n\n  /**\n   * Read the header of a buffer as a string.\n   *\n   * @see {header}\n   * @throws {RangeError} if buffer size < 2\n   */\n  public static peekHeaderStr = peekHeaderStr;\n\n  // ----- Accessors: -----\n\n  /** A uint16 number representing the shape of the encoded format */\n  public get hashCode(): number {\n    if (this._hash === undefined) {\n      this._hash = hashCode(this.format);\n    }\n\n    return this._hash;\n  }\n\n  /** @example \"{uint8,str[]?}\" */\n  protected get format(): string {\n    if (this._format === undefined) {\n      this._format = this.type === Type.Object\n        ? `{${this.fields.map(v => v.format).join(',')}}`\n        : `${this.type}`;\n    }\n\n    return this._format;\n  }\n\n  // ----- Public methods: -----\n\n  /**\n   * Encode an object to bytes.\n   *\n   * **Warning:** Returns an unsafe view into the encoding buffer. Pass this reference to preserve\n   * performance, and to minimize memory allocation and fragmentation.\n   *\n   * Set `{ safe: true }` to return a safe copy instead.\n   *\n   * @returns An unsafe Uint8Array view of the encoded byte array buffer.\n   * @throws if fails to encode value to schema.\n   */\n  public encode<DecodedType extends InferredDecodedType<EncoderType>>(\n    data: DecodedType,\n    opts?: {\n      /** (default: false) copy bytes to a new buffer, instead of returning an unsafe view */\n      safe?: boolean\n    },\n  ): Uint8Array {\n    if (this._w === undefined) {\n      // init global buffer if needed\n      if (SETTINGS.useGlobalEncodingBuffer && BufferFormat.globalBuffer === undefined) {\n        // lazy init\n        BufferFormat.globalBuffer = new ArrayBuffer(SETTINGS.encodingBufferMaxSize);\n        if (SETTINGS.debug) {\n          console.debug(`[tinybuf] init global encoding buffer (${SETTINGS.encodingBufferMaxSize} bytes)`);\n        }\n      }\n\n      // create writer\n      this._w = new BufferWriter(\n        SETTINGS.useGlobalEncodingBuffer ? BufferFormat.globalBuffer! : SETTINGS.encodingBufferInitialSize\n      );\n    }\n    else {\n      // reset\n      this._w.o = 0;\n    }\n\n    if (this._vt) data = this._preEncode(data);\n    this.write(data, this._w, '');\n\n    return opts?.safe ? this._w.asCopy() : this._w.asView();\n  }\n\n  /**\n   * Decode binary data to an object.\n   * @throws if fails to decode bytes to schema.\n   */\n  public decode<DecodedType = InferredDecodedType<EncoderType>>(b: Uint8Array | ArrayBufferView | ArrayBuffer): DecodedType {\n    return this.read(new BufferReader(b, this.header === undefined ? 0 : 2));\n  }\n\n  /**\n   * Set additional transform functions to apply before encoding and after decoding.\n   */\n  public setTransforms(transforms: InferredTransformConfig<EncoderType> | Transforms<any>): this {\n    this._vt = true;\n\n    if (transforms instanceof Function || (Array.isArray(transforms) && transforms[0] instanceof Function)) {\n      this._transforms = transforms;\n    }\n    else {\n      for (const name of Object.keys(transforms)) {\n        const field = this.fieldsMap.get(name);\n        if (!field) {\n          throw new TypeError(`Failed to set transforms for field '${name}'`);\n        }\n\n        // Set validation for object.\n        field.coder.setTransforms(transforms[name]);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Set additional validation rules which are applied on encode() and decode().\n   *\n   * - Validation functions should throw an error, return an error, or return boolean false.\n   * - Anything else is treated as successfully passing validation.\n   */\n  public setValidation(validations: InferredValidationConfig<EncoderType> | ValidationFn<any>): this {\n    this._vt = true;\n\n    if (validations instanceof Function) {\n      this._validate = validations;\n    }\n    else {\n      for (const name of Object.keys(validations)) {\n        const field = this.fieldsMap.get(name);\n        if (!field) {\n          throw new TypeError(`Failed to set validation function for field '${name}'`);\n        }\n\n        field.coder.setValidation(validations[name]);\n      }\n    }\n\n    return this;\n  }\n\n  // ----- Implementation: -----\n\n  /**\n   * @param value\n   * @param bw\n   * @param path\n   * @throws if the value is invalid\n   */\n  protected write(value: { [x: string]: any; }, bw: BufferWriter, path: string): void {\n    if (this._header !== undefined) this._w.writeUInt16(this._header);\n    if (this.type !== Type.Object) {\n      const safeValue = (this._validate || this._transforms) ? this._preEncode(value) : value;\n\n      return this.getCoder(this.type).write(safeValue, bw, path);\n    }\n\n    // Check for object type\n    if (!value || typeof value !== 'object') {\n      throw new TypeError(`Expected an object at ${path}`);\n    }\n\n    // Write each field\n    for (const field of this.fields) {\n      const subpath = path ? `${path}.${field.name}` : field.name;\n      const subValue = value[field.name];\n\n      if (field.isOptional) {\n\n        // Add 'presence' flag\n        if (subValue === undefined || subValue === null) {\n          coders.booleanCoder.write(false, bw);\n          continue;\n        }\n        else {\n          coders.booleanCoder.write(true, bw);\n        }\n      }\n\n      if (!field.isArray) {\n        // Scalar field\n        field.coder.write(subValue, bw, subpath);\n        continue;\n      }\n\n      // Array field\n      this._writeArray(subValue, bw, subpath, field.coder);\n    }\n  }\n\n  /**\n   * Helper to get the right coder.\n   */\n  protected getCoder(type: Type): coders.BinaryTypeCoder<any> {\n    switch (type) {\n      case Type.Bool: return coders.booleanCoder;\n      case Type.Bools: return coders.booleanArrayCoder;\n      case Type.Bools16: return coders.bitmask16Coder;\n      case Type.Bools32: return coders.bitmask32Coder;\n      case Type.Bools8: return coders.bitmask8Coder;\n      case Type.Buffer: return coders.bufferCoder;\n      case Type.Date: return coders.dateCoder;\n      case Type.Float16: return coders.float16Coder;\n      case Type.Float32: return coders.float32Coder;\n      case Type.Float64: return coders.float64Coder;\n      case Type.Int: return coders.intCoder;\n      case Type.Int16: return coders.int16Coder;\n      case Type.Int32: return coders.int32Coder;\n      case Type.Int8: return coders.int8Coder;\n      case Type.JSON: return coders.jsonCoder;\n      case Type.RegExp: return coders.regexCoder;\n      case Type.Scalar: return coders.scalarCoder;\n      case Type.String: return coders.stringCoder;\n      case Type.UInt: return coders.uintCoder;\n      case Type.UInt16: return coders.uint16Coder;\n      case Type.UInt32: return coders.uint32Coder;\n      case Type.UInt8: return coders.uint8Coder;\n      case Type.UScalar: return coders.uscalarCoder;\n    }\n  }\n\n  // ----- Private methods: -----\n\n  private _preEncode<T extends Record<string, any>>(data: T): T {\n    if (this._validate && this._validate(data) === false) {\n      throw new Error('custom validation failed');\n    }\n\n    if (this._transforms instanceof Function) {\n      return this._transforms(data);\n    }\n    else if (Array.isArray(this._transforms) && this._transforms[0] instanceof Function) {\n      return this._transforms[0](data);\n    }\n\n    return data;\n  }\n\n  private _postDecode<T extends Record<string, any>>(data: T): T {\n    if (Array.isArray(this._transforms) && this._transforms[1] instanceof Function) {\n      data = this._transforms[1](data);\n    }\n\n    if (this._validate instanceof Function) {\n      this._validate(data);\n    }\n\n    return data;\n  }\n\n  /**\n   * This function will be executed only the first time\n   * After that, we'll compile the read routine and add it directly to the instance\n   * @param state\n   * @returns\n   * @throws if fails\n   */\n  private read<DecodedType = InferredDecodedType<EncoderType>>(state: BufferReader): DecodedType {\n    // This function will be executed only the first time to compile the read routine.\n    // After that, we'll compile the read routine and add it directly to the instance\n\n    // Update the read method implementation.\n    this.read = this.compileRead();\n\n    return this.read(state);\n  }\n\n  /**\n   * Generate read function code for this coder.\n   *\n   * @example\n   * // new Type({a:'int', 'b?':['string']}) would emit:\n   *\n   * `return {\n   *   a: this._readField(0, state),\n   *   b: this._readField(1, state),\n   * }`\n   */\n  private generateObjectReadCode(): string {\n    const fieldsStr: string = this.fields\n      .map(({ name }, i) => `${name}:this.${this._readField.name}(${i},state)`)\n      .join(',');\n\n    return `return{${fieldsStr}}`;\n  }\n\n  /** Read an individual field. */\n  private _readField(fieldIndex: number, state: BufferReader): any {\n    const field = this.fields[fieldIndex];\n\n    if (field.isOptional && !this._readOptional(state)) {\n      return undefined;\n    }\n\n    if (field.isArray) {\n      return this._readArray(field.coder, state);\n    }\n\n    return field.coder.read(state);\n  }\n\n  private readValueType<DecodedType = InferredDecodedType<EncoderType>>(state: BufferReader): DecodedType {\n    return this._postDecode(this.getCoder(this.type).read(state));\n  }\n\n  /** Compile the decode() method for this object. */\n  private compileRead<DecodedType = InferredDecodedType<EncoderType>>(): (state: BufferReader) => DecodedType {\n    if (this.type !== Type.Object && this.type !== Type.Array) {\n      // Scalar type - in this case, there is no need to write custom code.\n      return (this._validate !== undefined || this._transforms !== undefined) ? this.readValueType : this.getCoder(this.type).read;\n    }\n\n    const code = this.generateObjectReadCode();\n\n    return new Function('state', code) as any;\n  }\n\n  /**\n   * @param value\n   * @param data\n   * @param path\n   * @param type\n   * @throws if the value is invalid\n   */\n  private _writeArray(value: string | any[], data: any, path: string, type: BufferFormat<any, any>): void {\n    let i: string | number, len: number;\n    if (!Array.isArray(value)) {\n      throw new WriteTypeError(`Array<${type.type}>`, data, path);\n    }\n\n    len = value.length;\n    coders.uintCoder.write(len, data);\n    for (i = 0; i < len; i++) {\n      type.write(value[i], data, path + '.' + i);\n    }\n  }\n\n  /**\n   * @throws if invalid data\n   */\n  private _readArray<T extends EncoderDefinition>(type: BufferFormat<T, any>, state: any): Array<T> {\n    const arr = new Array(coders.uintCoder.read(state));\n    for (let j = 0; j < arr.length; j++) {\n      arr[j] = type.read(state);\n    }\n    return arr;\n  }\n\n  private _readOptional(state: BufferReader): boolean {\n    return coders.booleanCoder.read(state);\n  }\n}\n\n/**\n * Parses and represents an object field.\n */\nexport class Field {\n  public readonly name: string;\n  public readonly coder: BufferFormat<any>;\n  public readonly isOptional: boolean;\n  public readonly isArray: boolean;\n\n  protected _format?: string;\n\n  public constructor(name: string, rawType: FieldDefinition) {\n    this.isOptional = rawType instanceof OptionalType;\n\n    let type = rawType instanceof OptionalType ? rawType.type : rawType;\n\n    this.name = name;\n\n    if (Array.isArray(type)) {\n      if (type.length !== 1) {\n        throw new TypeError('Invalid array definition, it must have exactly one element');\n      }\n\n      type = type[0];\n      this.isArray = true;\n    }\n    else {\n      this.isArray = false;\n    }\n\n    this.coder = new BufferFormat<any>(type, null);\n  }\n\n  public get format(): string {\n    if (this._format === undefined) {\n      this._format = `${(this.coder as any).format}${this.isArray ? '[]' : ''}${this.isOptional ? '?' : ''}`;\n    }\n\n    return this._format;\n  }\n}\n"],"names":["TinyBufError","Error","UnrecognizedFormatError","FormatHeaderCollisionError","BufferDecodingError","constructor","summary","underlying","super","message","this","stack","WriteTypeError","expectedType","value","path","BufferEncodingError","djb2HashUInt16","str","hash","i","length","charCodeAt","hashCode","strToHashCode","hashCodeToStr","String","fromCharCode","Math","floor","peekHeader","b","DataView","ArrayBuffer","buffer","getUint16","peekHeaderStr","bufferParser","BufferParserInstance","formats","Map","availableFormats","Set","values","map","v","processBuffer","header","e","has","f","onData","get","data","decode","on","format","callback","overwritePrevious","TypeError","set","ignore","forEach","clear","isBooleanArray","Array","isArray","every","entry","fixedLengthBooleanArrayToBitmask","booleanArray","parseInt","bools2Mask","mask2Bools","int","toString","padStart","clamp","min","max","r2z","x","ceil","raz","toUScalar8","uScalar","Number","isNaN","toScalar8","scalar","fromUScalar8","uInt8","NaN","fromScalar8","uScalarRound","doubleFloat","scalarRound","MAX_AUTO_INT32","MAX_INT32","POW_32","utf8Decoder","TextDecoder","uintCoder","write","MAX_SAFE_INTEGER","uIntValue","writeUInt8","writeUInt16","writeUInt32","read","state","firstByte","peekUInt8","readUint32","readUint16","skipByte","uint8Coder","readUint8","uint16Coder","uint32Coder","intCoder","intValue","int8Coder","writeInt8","readInt8","int16Coder","writeInt16","readInt16","int32Coder","writeInt32","readInt32","float16Coder","writeFloat16","readFloat16","float32Coder","writeFloat32","readFloat32","float64Coder","writeFloat64","readFloat64","uscalarCoder","scalarCoder","stringCoder","bufferCoder","TextEncoder","encode","byteLength","writeBuffer","readBuffer","booleanCoder","Boolean","booleanArrayCoder","boolArray.isBooleanArray","boolArray.bools2Mask","slice","isFinalChunk","bitmask","chunk","shift","push","bitmask8Coder","boolArray.fixedLengthBooleanArrayToBitmask","boolArray.mask2Bools","bitmask16Coder","bitmask32Coder","jsonCoder","stringValue","JSON","stringify","error","parse","regexCoder","RegExp","g","m","source","global","ignoreCase","multiline","flags","dateCoder","Date","time","getTime","setTinybufConfig","newSettings","SETTINGS","Object","assign","useGlobalEncodingBuffer","encodingBufferMaxSize","encodingBufferInitialSize","encodingBufferIncrement","debug","FLOAT16_PRECALCULATE_SUBNORMAL","pow","f16mask","floatView","Float32Array","int32View","Int32Array","toHalf","f16unmask","f16","t","fround16","_initFloat16LookupTable","exponent","significand","precalc","Infinity","_a","BufferWriter","o","resize","buf","console","view","asView","Uint8Array","asCopy","setInt8","alloc","setInt16","setInt32","setUint8","setUint16","setUint32","setFloat32","setFloat64","byteOffset","readView","bytes","currentAlloc","minRequestedSize","newLength","newBuffer","currentData","BufferReader","hasEnded","getUint8","r","getUint32","getInt8","getInt16","getInt32","getFloat32","getFloat64","RangeError","VALID_VALUE_TYPES","OptionalType","type","optional","defineFormat","a","BufferFormat","def","_vt","undefined","includes","fieldsMap","fields","keys","name","Field","_header","isValidHeader","h","isInteger","_hash","_format","join","opts","_w","globalBuffer","_preEncode","safe","setTransforms","transforms","Function","_transforms","field","coder","setValidation","validations","_validate","bw","safeValue","getCoder","subpath","subValue","isOptional","coders.booleanCoder","_writeArray","coders.booleanArrayCoder","coders.bitmask16Coder","coders.bitmask32Coder","coders.bitmask8Coder","coders.bufferCoder","coders.dateCoder","coders.float16Coder","coders.float32Coder","coders.float64Coder","coders.intCoder","coders.int16Coder","coders.int32Coder","coders.int8Coder","coders.jsonCoder","coders.regexCoder","coders.scalarCoder","coders.stringCoder","coders.uintCoder","coders.uint16Coder","coders.uint32Coder","coders.uint8Coder","coders.uscalarCoder","_postDecode","compileRead","generateObjectReadCode","_readField","fieldIndex","_readOptional","_readArray","readValueType","code","len","arr","j","rawType"],"mappings":"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"}