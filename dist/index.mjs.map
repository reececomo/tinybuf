{"version":3,"file":"index.mjs","sources":["../src/core/lib/errors.ts","../src/core/lib/hashCode.ts","../src/core/lib/peek.ts","../src/core/BufferParser.ts","../src/core/lib/math.ts","../src/core/lib/scalar.ts","../src/core/lib/bitmask.ts","../src/core/lib/utf8.ts","../src/core/lib/float16.ts","../src/core/lib/coders.ts","../src/core/config.ts","../src/core/lib/BufferWriter.ts","../src/core/lib/BufferReader.ts","../src/core/Type.ts","../src/core/BufferFormat.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/unified-signatures */\n\nexport class TinybufError extends Error {}\n","/**\n * DJB2 hash algorithm (modified for 16-bit uints).\n *\n * DJB2 is a simple and widely used non-cryptographic\n * hash function created by Daniel J. Bernstein.\n *\n * @returns 16-bit unsigned integer\n */\nexport function $hashCode(str: string): number {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = (hash * 33) ^ str.charCodeAt(i);\n  }\n  return hash & 0xFFFF; // Ensure the result is a Uint16\n}\n\n/**\n * Returns an unsigned 16-bit integer hashcode for some string.\n * Prefers 2 character string.\n *\n * @returns A UInt16 between 0 and 65535 (inclusive).\n */\nexport function $strToHashCode(str: string): number {\n  if (str.length !== 2) return $hashCode(str);\n  return str.charCodeAt(0) * 256 + str.charCodeAt(1);\n}\n\n/**\n * Convert a UInt16 hashcode to a 2-byte string.\n */\nexport function $hashCodeToStr(hashCode: number): string {\n  return String.fromCharCode(Math.floor(hashCode / 256)) + String.fromCharCode(hashCode % 256);\n}\n","import { $hashCodeToStr } from \"./hashCode\";\n\n\n/**\n * Read the header bytes of a buffer as a number.\n *\n * @throws {RangeError} if buffer size < 2\n */\nexport function peekHeader(b: ArrayBuffer | ArrayBufferView): number {\n  return (ArrayBuffer.isView(b) ? new DataView(b.buffer, b.byteOffset, 2) : new DataView(b, 0, 2)).getUint16(0, false);\n}\n\n/**\n * Read the header bytes of a buffer as a string.\n *\n * @throws {RangeError} if buffer length < 2\n */\nexport function peekHeaderStr(b: ArrayBuffer | ArrayBufferView): string {\n  return $hashCodeToStr(peekHeader(b));\n}\n","import { BufferFormat } from \"./BufferFormat\";\nimport { EncoderDefinition, InferredDecodedType } from \"./Type\";\nimport { TinybufError } from \"./lib/errors\";\nimport { $hashCodeToStr, $strToHashCode } from \"./lib/hashCode\";\nimport { peekHeader } from \"./lib/peek\";\n\ntype AnyFormat = BufferFormat<any, any>;\ntype Uint16FormatHeader = number;\n\n/**\n * Small utility for registering and processing format handlers.\n *\n * @example\n * const myHandler = bufferParser()\n *   .on(FormatA, aData => {})\n *   .on(FormatB, bData => {});\n *\n * myHandler.processBuffer(bytes);\n */\nexport const bufferParser = (): BufferParser => new BufferParser();\n\nexport class BufferParser {\n  /** @internal */\n  private _$formats = new Map<Uint16FormatHeader, [AnyFormat, (data: any) => any]>();\n\n  /**\n   * Decode an array buffer and trigger the relevant data handler.\n   *\n   * When passed an ArrayBufferView, accesses the underlying 'buffer' instance directly.\n   *\n   * @throws {TinybufError} if fails to decode, or no handler is registered\n   */\n  public processBuffer(b: ArrayBuffer | ArrayBufferView): void {\n    let f: any, data: any, cb: (data: any) => any;\n\n    try {\n      const header = peekHeader(b);\n\n      if (!this._$formats.has(header)) {\n        throw new TinybufError(`Unknown format: ${header} '${$hashCodeToStr(header)}')`);\n      }\n\n      [f, cb] = this._$formats.get(header);\n      data = f.decode(b);\n    }\n    catch (e) {\n      const err = new TinybufError(`Failed to decode: ${e}`);\n      err.stack = e.stack;\n\n      throw err;\n    }\n\n    cb(data);\n  }\n\n  /**\n   * Register a format handler.\n   */\n  public on<EncoderType extends EncoderDefinition, DecodedType = InferredDecodedType<EncoderType>>(\n    format: BufferFormat<EncoderType, string | number>,\n    callback: (data: DecodedType) => any,\n    overwritePrevious: boolean = false,\n  ): this {\n    if (format.header == null) {\n      throw new TinybufError('Format requires header');\n    }\n\n    const header = typeof format.header === 'string' ? $strToHashCode(format.header) : format.header;\n\n    if (this._$formats.has(header) && !overwritePrevious) {\n      throw new TinybufError(`Format header collision: ${format.header}`);\n    }\n\n    this._$formats.set(header, [format, callback]);\n\n    return this;\n  }\n\n  /** Register a format (or formats) that are recognized. */\n  public ignore(...format: AnyFormat[]): this {\n    format.forEach(f => this.on(f, () => {}, true));\n    return this;\n  }\n\n  /** Clears all registered formats and handlers. */\n  public clear(): void {\n    this._$formats.clear();\n  }\n}\n","export const $floor = Math.floor,\n  $ceil = Math.ceil;\n\n/** Clamp a number to a range. */\nexport const $clamp = (value: number, min: number, max: number): number =>\n  value > max ? max : value < min ? min : value;\n\n/** Round toward zero */\nexport const $roundTowardZero = (x: number): number => x < 0 ? $ceil(x) : $floor(x);\n\n/** Round away zero */\nexport const $roundAwayFromZero = (x: number): number =>\n  x < 0 ? $floor(x) : $ceil(x);\n","import { $clamp, $roundTowardZero, $roundAwayFromZero } from \"./math\";\n\n/**\n * Quantize a number to an 8-bit scalar between 0.0 and 1.0.\n *\n * @returns A number (double) in its closest signed scalar representation.\n */\nexport function uscalround(x: number): number {\n  return $fromuscal8($touscal8(x));\n}\n\n/**\n * Quantize a number to an 8-bit signed scalar between -1.0 and 1.0.\n *\n * @returns A number (double) in its closest signed scalar representation.\n */\nexport function scalround(x: number): number {\n  return $fromscal8($toscal8(x));\n}\n\n/** @returns A UInt8 bitmask representation. */\nexport function $touscal8(x: number): number {\n  return $clamp(127 + $roundTowardZero(x * 254 - 127), 0, 254);\n}\n\n/** @returns A UInt8 bitmask representation. */\nexport function $toscal8(x: number): number {\n  return $clamp($roundTowardZero(x * 127), -127, 127) + 127;\n}\n\n/** @returns An unsigned scalar between 0.0 and 1.0. */\nexport function $fromuscal8(x: number): number {\n  // Make symmetric: (0.5 + round((uint8 - 127) / 254 * 100)) / 100\n  return $clamp(($roundAwayFromZero((x - 127) * 0.3937007874015748) + 50) * 0.01, 0, 1);\n}\n\n/** @returns A signed scalar between -1.0 and 1.0. */\nexport function $fromscal8(x: number): number {\n  // Make symmetric: round((uint8 - 127) / 127 * 100) / 100\n  return $clamp($roundAwayFromZero((x - 127) * 0.787401574803149) * 0.01, -1, 1);\n}\n","/**\n * Mask booleans to a uint32.\n *\n * @param x - A boolean array.\n * @param padBit - A bit to pad the mask (for variable length data).\n */\nexport const mask = (x: boolean[], padBit: 0 | 1 = 0b1): number => {\n  return x.reduce((n, b: any) => (n << 1) | b, padBit);\n};\n\n/**\n * Unmask booleans from a uint32.\n *\n * @param x - A uint32 number.\n * @param len - number of booleans to expect (default: infer lenth from x where x is encoded with a pad bit)\n */\nexport const unmask = (x: number, len = 31 - Math.clz32(x)): boolean[] => {\n  const result = new Array<boolean>(len);\n  for (let i = 0; i < len; i++) result[i] = !!(x & (1 << (len - 1 - i)));\n  return result;\n};\n","export const $utf8encode = (function () {\n  const encoder = new TextEncoder();\n  return (x?: string): Uint8Array => encoder.encode(x);\n})();\n\nexport const $utf8decode = (function () {\n  const decoder = new TextDecoder('utf-8');\n\n  return (y: Uint8Array): string => decoder.decode(y);\n})();\n","/**\n * Returns the nearest half precision float representation of a number.\n * @param x A numeric expression.\n */\nexport function f16round(x: number): number {\n  return $fromf16($tof16(x));\n}\n\n/**\n * Returns the nearest half precision float representation of a number as a 16-bit bitmask.\n */\nexport const $tof16 = (function() {\n  const x = new Float32Array(1);\n  const y = new Int32Array(x.buffer);\n\n  return function (f: number) {\n    x[0] = f;\n    let i = y[0]; // 32-bit int\n    let s = (i >> 16) & 0X8000; // sign\n    let z = (i & 0X7FFFFFFF) + 0X1000 | 0;\n\n    if (z >= 0X47800000) {\n      if ((i & 0X7FFFFFFF) < 0X47800000) return s | 0X7BFF;\n      if (z < 0X7F800000) return s | 0X7C00;\n      return s | 0X7C00 | (i & 0X007FFFFF) >> 13;\n    }\n    if (z >= 0X38800000) return s | z - 0X38000000 >> 13;\n    else if (z < 0X33000000) return s;\n    z = (i & 0X7FFFFFFF) >> 23;\n    return s | ((i & 0X7FFFFF | 0X800000)\n      + (0X800000 >>> z - 102)\n      >> 126 - z);\n  };\n}());\n\n/**\n * Returns the nearest half precision float value for a 16-bit bitmask.\n */\nexport const $fromf16 = (function() {\n  const z = Math.pow(2, -24); // subnormal constant\n  const d = new Float32Array(32 + 1024);\n  for (let e = 0; e < 32; e++) d[e] = Math.pow(2, e - 15); // biased exponents\n  for (let m = 0; m < 1024; m++) d[m + 0x20] = 1 + m / 1024; // normalized offset mantissas\n\n  return function (b: number): number {\n    const s = (b & 32768) === 32768 ? -1 : 1; // sign: 1 bit\n    const e = b & 31744; // exponent: 5 bits\n    const m = b & 1023; // mantissa: 10 bits\n\n    if (e === 0) return m === 0 ? s * 0 : s * z;\n    if (e === 31744) return m === 0 ? s * Infinity : NaN;\n    return d[e >> 10] * d[m + 0x20] * s;\n  };\n}());\n","import { BufferWriter } from './BufferWriter';\nimport { BufferReader } from './BufferReader';\nimport {\n  $fromuscal8,\n  $fromscal8,\n  $touscal8,\n  $toscal8\n} from './scalar';\nimport { Type } from '../Type';\nimport { mask, unmask } from './bitmask';\nimport { $utf8decode, $utf8encode } from './utf8';\nimport { $floor } from './math';\nimport { $fromf16, $tof16 } from './float16';\n\n// Pre-calculated constants\nconst MAX_VARUINT8 = 128,\n  MAX_VARUINT16 = 16_384,\n  MAX_VARUINT32 = 536_870_912,\n  MAX_VARINT8 = 64,\n  MAX_VARINT16 = 8_192,\n  MAX_VARINT32 = 268_435_456,\n  POW_32 = 0x100000000;\n\ntype WriterFn<T> = (value: T, writer: BufferWriter) => void;\ntype ReaderFn<T> = (reader: BufferReader) => T;\n\nexport interface BinaryTypeCoder<T, R = T> {\n  $write: WriterFn<T>;\n  $read: ReaderFn<R>;\n}\n\n/**\n * Format (big-endian):\n * 7b   0xxx xxxx\n * 14b  10xx xxxx  xxxx xxxx\n * 29b  110x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx\n * 61b  111x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx\n */\nexport const uintCoder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => {\n    if (value < MAX_VARUINT8) {\n      writer.$writeUint8(value);\n    }\n    else if (value < MAX_VARUINT16) {\n      writer.$writeUint16(value + 0x8000);\n    }\n    else if (value < MAX_VARUINT32) {\n      writer.$writeUint32(value + 0xc0000000);\n    }\n    else {\n      writer.$writeUint32($floor(value / POW_32) + 0xe0000000);\n      writer.$writeUint32(value >>> 0);\n    }\n  },\n  $read: (reader) => {\n    const firstByte = reader.$peek();\n\n    if (!(firstByte & 0x80)) {\n      reader.$skip();\n      return firstByte;\n    }\n    else if (!(firstByte & 0x40)) {\n      return reader.$readUint16() - 0x8000;\n    }\n    else if (!(firstByte & 0x20)) {\n      return reader.$readUint32() - 0xc0000000;\n    }\n\n    return (reader.$readUint32() - 0xe0000000) * POW_32\n      + reader.$readUint32();\n  }\n};\n\nexport const uint8Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint8(value),\n  $read: (reader) => reader.$readUint8(),\n};\n\nexport const uint16Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint16(value),\n  $read: (reader) => reader.$readUint16(),\n};\n\nexport const uint32Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint32(value),\n  $read: (reader) => reader.$readUint32(),\n};\n\n/**\n * Format (big-endian):\n * 7b   0xxx xxxx\n * 14b  10xx xxxx  xxxx xxxx\n * 29b  110x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx\n * 61b  111x xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx  xxxx xxxx\n */\nexport const intCoder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => {\n    if (value >= -MAX_VARINT8 && value < MAX_VARINT8) {\n      writer.$writeUint8(value & 0x7f);\n    }\n    else if (value >= -MAX_VARINT16 && value < MAX_VARINT16) {\n      writer.$writeUint16((value & 0x3fff) + 0x8000);\n    }\n    else if (value >= -MAX_VARINT32 && value < MAX_VARINT32) {\n      writer.$writeUint32((value & 0x1fffffff) + 0xc0000000);\n    }\n    else {\n      const intValue = value;\n      // Split in two 32b uints\n      writer.$writeUint32(($floor(intValue / POW_32) & 0x1fffffff) + 0xe0000000);\n      writer.$writeUint32(intValue >>> 0);\n    }\n  },\n  $read: (reader) => {\n    let firstByte = reader.$peek(), i: number;\n\n    if (!(firstByte & 0x80)) {\n      reader.$skip();\n      return (firstByte & 0x40) ? (firstByte | 0xffffff80) : firstByte;\n    }\n    else if (!(firstByte & 0x40)) {\n      i = reader.$readUint16() - 0x8000;\n      return (i & 0x2000) ? (i | 0xffffc000) : i;\n    }\n    else if (!(firstByte & 0x20)) {\n      i = reader.$readUint32() - 0xc0000000;\n      return (i & 0x10000000) ? (i | 0xe0000000) : i;\n    }\n    else {\n      i = reader.$readUint32() - 0xe0000000;\n      i = (i & 0x10000000) ? (i | 0xe0000000) : i;\n      return i * POW_32 + reader.$readUint32();\n    }\n  }\n};\n\nexport const int8Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeInt8(value),\n  $read: (reader) => reader.$readInt8(),\n};\n\nexport const int16Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeInt16(value),\n  $read: (reader) => reader.$readInt16(),\n};\n\nexport const int32Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeInt32(value),\n  $read: (reader) => reader.$readInt32(),\n};\n\nexport const float16Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint16($tof16(value)),\n  $read: (reader) => $fromf16(reader.$readUint16()),\n};\n\nexport const float32Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeFloat32(value),\n  $read: (reader) => reader.$readFloat32(),\n};\n\nexport const float64Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeFloat64(value),\n  $read: (reader) => reader.$readFloat64(),\n};\n\nexport const uscalar8Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint8($touscal8(value)),\n  $read: (reader) => $fromuscal8(reader.$readUint8()),\n};\n\nexport const scalar8Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint8($toscal8(value)),\n  $read: (reader) => $fromscal8(reader.$readUint8()),\n};\n\nexport const dateCoder: BinaryTypeCoder<Date> = {\n  $write: (value, writer) => intCoder.$write(value.getTime(), writer),\n  $read: (reader) => new Date(intCoder.$read(reader)),\n};\n\nexport const stringCoder: BinaryTypeCoder<string> = {\n  $write: (value, writer) => {\n    const bytes = $utf8encode(value ?? '');\n    bufferCoder.$write(bytes, writer);\n  },\n  $read: (reader) => {\n    const bytes = bufferCoder.$read(reader);\n    return $utf8decode(bytes);\n  },\n};\n\nexport const bufferCoder: BinaryTypeCoder<ArrayBuffer | ArrayBufferView, Uint8Array> = {\n  $write: (value, writer) => {\n    uintCoder.$write(value.byteLength, writer); // header byte (length)\n    writer.$writeBytes(value);\n  },\n  $read: (reader) => {\n    const bytes = uintCoder.$read(reader);\n    return reader.$readBytes(bytes);\n  },\n};\n\nexport const boolCoder: BinaryTypeCoder<boolean> = {\n  $write: (value, writer) => writer.$writeUint8(value ? 1 : 0),\n  $read: (reader) => reader.$readUint8() !== 0,\n};\n\nexport const boolsCoder: BinaryTypeCoder<boolean[]> = {\n  $write: (value, writer) => {\n    if (value.length > 28) value = value.slice(0, 28); // stored as UInt\n    uintCoder.$write(mask(value), writer);\n  },\n  $read: (reader) => unmask(uintCoder.$read(reader)),\n};\n\nexport const jsonCoder: BinaryTypeCoder<any> = {\n  $write: (value, writer) => stringCoder.$write(JSON.stringify(value), writer),\n  $read: (reader) => JSON.parse(stringCoder.$read(reader)),\n};\n\nexport const regexCoder: BinaryTypeCoder<RegExp> = {\n  $write: (value, writer) => {\n    writer.$writeUint8(mask([value.global, value.ignoreCase, value.multiline]));\n    stringCoder.$write(value.source, writer);\n  },\n  $read: (reader) => {\n    const [g, i, m] = unmask(reader.$readUint8());\n    return new RegExp(stringCoder.$read(reader), (g ? 'g' : '') + (i ? 'i' : '') + (m ? 'm' : ''));\n  }\n};\n\n/** @see {Type} indices must match */\nexport const writers: Record<Type, WriterFn<any>> = [\n  uintCoder.$write, // Type.UInt\n  uint8Coder.$write, // Type.UInt8\n  uint16Coder.$write, // Type.UInt16\n  uint32Coder.$write, // Type.UInt32\n  intCoder.$write, // Type.Int\n  int8Coder.$write, // Type.Int8\n  int16Coder.$write, // Type.Int16\n  int32Coder.$write, // Type.Int32\n  float64Coder.$write, // Type.Float64\n  float32Coder.$write, // Type.Float32\n  float16Coder.$write, // Type.Float16\n  scalar8Coder.$write, // Type.Scalar\n  uscalar8Coder.$write, // Type.UScalar\n  boolCoder.$write, // Type.Bool\n  boolsCoder.$write, // Type.Bools\n  bufferCoder.$write, // Type.Buffer\n  stringCoder.$write, // Type.String\n  jsonCoder.$write, // Type.JSON\n  regexCoder.$write, // Type.RegExp\n  dateCoder.$write, // Type.Date\n];\n\n/** @see {Type} indices must match */\nexport const readers: Record<Type, ReaderFn<any>> = [\n  uintCoder.$read, // Type.UInt\n  uint8Coder.$read, // Type.UInt8\n  uint16Coder.$read, // Type.UInt16\n  uint32Coder.$read, // Type.UInt32\n  intCoder.$read, // Type.Int\n  int8Coder.$read, // Type.Int8\n  int16Coder.$read, // Type.Int16\n  int32Coder.$read, // Type.Int32\n  float64Coder.$read, // Type.Float64\n  float32Coder.$read, // Type.Float32\n  float16Coder.$read, // Type.Float16\n  scalar8Coder.$read, // Type.Scalar\n  uscalar8Coder.$read, // Type.UScalar\n  boolCoder.$read, // Type.Bool\n  boolsCoder.$read, // Type.Bools\n  bufferCoder.$read, // Type.Buffer\n  stringCoder.$read, // Type.String\n  jsonCoder.$read, // Type.JSON\n  regexCoder.$read, // Type.RegExp\n  dateCoder.$read, // Type.Date\n];\n","/** Default maximum transmission unit in networking */\nconst MTU = 1500;\n\n/** Set Tinybuf global config */\nexport const setTinybufConfig = (c: Partial<TinybufConfig>): void => {\n  cfg = { ...cfg, ...c };\n};\n\nexport type TinybufConfig = {\n  /**\n   * (default: false)\n   *\n   * This sets the default value for `preserveBytes` on\n   * `encode(data, preserveBytes?)`.\n   *\n   * By default, `encode()` returns its encoded bytes as a `Uint8Array`\n   * view of the bytes in the shared encoding buffer.\n   *\n   * This is suitable for synchronous use (e.g. high-performance applications)\n   * as it avoids slow and expensive memory allocation and fragmentation on\n   * each call to `encode()`.\n   *\n   * However, susbsequent calls are destructive to the underlying bytes, so\n   * for asynchronous uses (e.g. Promises, Workers, long-lived storage), set\n   * `preserveBytes` to `true`.\n   */\n  safe: boolean,\n\n  /**\n   * (default: true)\n   * By default, format encoders share a global encoding buffer for performance\n   * and memory management reasons.\n   *\n   * When set to false, each format is allocated an individual encoding buffer.\n   *\n   * Enable to maximise performance and memory re-use, just be cautious of\n   * possible race conditions.\n   */\n  useGlobalEncodingBuffer: boolean,\n\n  /**\n   * (default: 1500)\n   * The maximum bytes that can be allocated to an encoding buffer.\n   *\n   * Default is 1500 bytes, the standard \"Maximum Transmission Unit\".\n   */\n  encodingBufferMaxSize: number,\n\n  /**\n   * (default: 256)\n   * Initial bytes to allocate for an encoding buffer.\n   */\n  encodingBufferInitialSize: number,\n\n  /**\n   * (default: 256)\n   * Additional bytes to allocated when dynamically increasing the size of an encoding buffer.\n   */\n  encodingBufferIncrement: number,\n};\n\n/** @internal */\nexport let cfg: TinybufConfig = {\n  safe: false,\n  useGlobalEncodingBuffer: true,\n  encodingBufferMaxSize: MTU,\n  encodingBufferInitialSize: 256,\n  encodingBufferIncrement: 256,\n};\n","import { cfg } from \"../config\";\nimport { TinybufError } from \"./errors\";\n\n/**\n * Wraps a buffer with a write head pointer.\n *\n * @internal\n */\nexport class BufferWriter {\n  public i: number = 0;\n  public _$dataView: DataView;\n\n  public constructor(initialSize: number) {\n    this._$dataView = new DataView(new ArrayBuffer(initialSize));\n  }\n\n  public $viewBytes(): Uint8Array {\n    return new Uint8Array(this._$dataView.buffer, this._$dataView.byteOffset, this.i);\n  }\n\n  public $copyBytes(): Uint8Array {\n    return new Uint8Array(this._$dataView.buffer.slice(0, this.i));\n  }\n\n  // ----- Writers: -----\n\n  public $writeInt8(value: number): void {\n    this._$dataView.setInt8(this._$alloc(1), value);\n  }\n\n  public $writeInt16(value: number): void {\n    this._$dataView.setInt16(this._$alloc(2), value, true);\n  }\n\n  public $writeInt32(value: number): void {\n    this._$dataView.setInt32(this._$alloc(4), value, true);\n  }\n\n  public $writeUint8(value: number): void {\n    this._$dataView.setUint8(this._$alloc(1), value);\n  }\n\n  public $writeUint16(value: number): void {\n    this._$dataView.setUint16(this._$alloc(2), value, false); // big-endian for varint\n  }\n\n  public $writeUint32(value: number): void {\n    this._$dataView.setUint32(this._$alloc(4), value, false); // big-endian for varint\n  }\n\n  public $writeFloat32(value: number): void {\n    this._$dataView.setFloat32(this._$alloc(4), value, true);\n  }\n\n  public $writeFloat64(value: number): void {\n    this._$dataView.setFloat64(this._$alloc(8), value, true);\n  }\n\n  public $writeBytes(b: Uint8Array | ArrayBuffer | ArrayBufferView): void {\n    // allocate bytes first\n    const j = this._$alloc(b.byteLength);\n\n    console.log(`buffer: allocating ${j} for a total of ${this._$dataView.byteLength}`);\n\n    let bBytes: Uint8Array\n      try {\n       bBytes = ArrayBuffer.isView(b)\n       ? b instanceof Uint8Array ? b : new Uint8Array(b.buffer, b.byteOffset, b.byteLength)\n       : new Uint8Array(b);\n      }\n      catch (error) {\n        throw new Error('failed to copy bytes reason 11'); // FIXME: remove\n      }\n\n    // copy bytes\n    let newView: Uint8Array;\n    try {\n      newView = new Uint8Array(this._$dataView.buffer, this._$dataView.byteOffset + j, b.byteLength);\n    }\n    catch (error) {\n      throw new Error(`failed to copy bytes reason 61 - for ${b.byteLength} we're allocating ${j} for a total of ${this._$dataView.byteLength}`); // FIXME: remove\n    }\n    try {\n      newView.set(bBytes);\n    }\n    catch (error) {\n      throw new Error('failed to copy bytes reason 33'); // FIXME: remove\n    }\n    \n  }\n\n  // ----- Private methods: -----\n\n  /** @returns writer head (byteOffset) */\n  private _$alloc(bytes: number): number {\n    if (this.i + bytes > this._$dataView.byteLength) {\n      const minBytesNeeded = this.i + bytes - this._$dataView.byteLength;\n      const requestedNewBytes = Math.ceil(minBytesNeeded / cfg.encodingBufferIncrement) * cfg.encodingBufferIncrement;\n      this._$resizeBuffer(this._$dataView.byteLength + requestedNewBytes);\n    }\n\n    const j = this.i;\n    this.i += bytes;\n\n    return j;\n  }\n\n  private _$resizeBuffer(newSize: number): void {\n    if (newSize > cfg.encodingBufferMaxSize) {\n      // safety check\n      throw new TinybufError(`exceeded encodingBufferMaxSize: ${cfg.encodingBufferMaxSize}`);\n    }\n\n    const newBuf = new ArrayBuffer(newSize);\n\n    // copy bytes\n    const oldView = new Uint8Array(this._$dataView.buffer, this._$dataView.byteOffset, this._$dataView.byteLength);\n    new Uint8Array(newBuf).set(oldView);\n\n    // update view\n    this._$dataView = new DataView(newBuf);\n  }\n}\n","/**\n * Wraps a buffer with a read head pointer.\n *\n * @internal\n */\nexport class BufferReader {\n  public i: number;\n  private _$dataView: DataView;\n\n  public constructor(b: Uint8Array | ArrayBufferView | ArrayBuffer, headerBytes?: number) {\n    this._$dataView = ArrayBuffer.isView(b)\n      ? new DataView(b.buffer, b.byteOffset, b.byteLength)\n      : new DataView(b);\n\n    this.i = headerBytes ?? 0; // internal offset (header)\n  }\n\n  /** Read the next byte, without moving the read head pointer. */\n  public $peek(): number {\n    return this._$dataView.getUint8(this.i);\n  }\n\n  /** Skip the next byte without reading it. */\n  public $skip(): void {\n    this.i++;\n  }\n\n  // ----- Readers: -----\n\n  public $readUint8(): number {\n    return this._$dataView.getUint8(this.i++);\n  }\n\n  public $readUint16(): number {\n    const r = this._$dataView.getUint16(this.i); // big-endian\n    this.i += 2;\n    return r;\n  }\n\n  public $readUint32(): number {\n    const r = this._$dataView.getUint32(this.i); // big-endian\n    this.i += 4;\n    return r;\n  }\n\n  public $readInt8(): number {\n    return this._$dataView.getInt8(this.i++);\n  }\n\n  public $readInt16(): number {\n    const r = this._$dataView.getInt16(this.i, true); // little-endian\n    this.i += 2;\n    return r;\n  }\n\n  public $readInt32(): number {\n    const r = this._$dataView.getInt32(this.i, true); // little-endian\n    this.i += 4;\n    return r;\n  }\n\n  public $readFloat32(): number {\n    const r = this._$dataView.getFloat32(this.i, true); // little-endian\n    this.i += 4;\n    return r;\n  }\n\n  public $readFloat64(): number {\n    const r = this._$dataView.getFloat64(this.i, true); // little-endian\n    this.i += 8;\n    return r;\n  }\n\n  /** @throws RangeError if exceeds length */\n  public $readBytes(bytes: number): Uint8Array {\n    if (this._$dataView.byteOffset + this.i + bytes > this._$dataView.byteLength) {\n      throw new RangeError('exceeded bytes');\n    }\n\n    const view = new Uint8Array(this._$dataView.buffer, this._$dataView.byteOffset + this.i, bytes);\n    this.i += bytes;\n\n    return view;\n  }\n}\n","/**\n * Field types for defining encoding formats.\n *\n * @see [Get started: Types](https://github.com/reececomo/tinybuf/blob/main/docs/get_started.md#types)\n */\nexport enum Type {\n  /**\n   * Unsigned integer (1 - 8 bytes).\n   * - 0 → 127 = 1 byte\n   * - 128 → 16,384 = 2 bytes\n   * - 16,385 → 536,870,911 = 4 bytes\n   * - 536,870,912 → `Number.MAX_SAFE_INTEGER` = 8 bytes\n   */\n  UInt = 0,\n\n  /** Unsigned 8-bit integer (between 0 and 255, 1 byte). */\n  UInt8,\n\n  /** Unsigned 16-bit integer (between 0 and 65,535, 2 bytes). */\n  UInt16,\n\n  /** Unsigned 32-bit integer (between 0 and 4,294,967,295, 4 bytes). */\n  UInt32,\n\n  /**\n   * Signed integer (1 - 8 bytes).\n   * - 0 → ±64 = 1 byte\n   * - ±65 → ±8,192 = 2 bytes\n   * - ±8,193 → ±268,435,456 = 4 bytes\n   * - ±268,435,457 → ±`Number.MAX_SAFE_INTEGER` = 8 bytes\n   */\n  Int,\n\n  /** Signed 1 byte integer (between -127 and 127). */\n  Int8,\n\n  /** Signed 2 byte integer (between -32,767 and 32,767). */\n  Int16,\n\n  /** Signed 4 byte integer (between -2,147,483,647 and 2,147,483,647). */\n  Int32,\n\n  /** Default JavaScript `number` type. Floating-point number (64-bit, double precision, 8 bytes). */\n  Float64,\n\n  /** Floating-point number (32-bit, single precision, 4 bytes). */\n  Float32,\n\n  /**\n   * Floating-point number (16-bit, half precision, 2 bytes).\n   *\n   * **Warning:** Low precision; maximum range: ±65,504.\n   */\n  Float16,\n\n  /** A cheap, low-resolution signed scalar between -1.00 and 1.00 (1 byte). */\n  Scalar8,\n\n  /** A cheap, low-resolution unsigned scalar between 0.00 and 1.00 (1 byte). */\n  UScalar8,\n\n  /**\n   * Boolean value (1 byte).\n   * @see {Bools} for packing multiple booleans into a single byte.\n   */\n  Bool,\n\n  /** Any array of booleans (1 bit overhead, encoded as UInt). */\n  Bools,\n\n  /** Any ArrayBuffer or ArrayBufferView (e.g. Uint8Array) value (encoded as 1 x UInt for byte length + buffer bytes). */\n  Buffer,\n\n  /** A UTF-8 string (encoded as 1 x UInt for UTF-8 byte length + UTF-8 bytes). */\n  String,\n\n  /** Any JSON-serializable data. Encodes as a UTF-8 string. */\n  JSON,\n\n  /** JavaScript regular expression. */\n  RegExp,\n\n  /**\n   * JavaScript date object.\n   *\n   * Encoded as an 8 byte (64-bit) integer UTC timestamp from as the number\n   * of milliseconds since the Unix Epoch (January 1, 1970, 00:00:00 UTC).\n   *\n   * @see {Date}\n   */\n  Date,\n}\n\n/**\n * Mappings for the value types.\n */\nexport type ValueTypes = {\n  [Type.Int]: number;\n  [Type.Int8]: number;\n  [Type.Int16]: number;\n  [Type.Int32]: number;\n  [Type.UInt]: number;\n  [Type.UInt8]: number;\n  [Type.UInt16]: number;\n  [Type.UInt32]: number;\n  [Type.Float64]: number;\n  [Type.Float32]: number;\n  [Type.Float16]: number;\n  [Type.Scalar8]: number;\n  [Type.UScalar8]: number;\n  [Type.Bool]: boolean;\n  [Type.Bools]: boolean[];\n  [Type.Buffer]: Uint8Array | ArrayBuffer | ArrayBufferView;\n  [Type.String]: string;\n  [Type.JSON]: any;\n  [Type.RegExp]: RegExp;\n  [Type.Date]: Date;\n};\n\n/** @throws any error too */\nexport type ValidationFn<T> = (x: T) => undefined | boolean | Error;\nexport type TransformFn<T> = (x: T) => T;\nexport type Transforms<T> = TransformFn<T> | [preEncode: TransformFn<T>] | [preEncode: TransformFn<T> | undefined, postDecode: TransformFn<T> | undefined];\n\n/**\n * A wrapper around any Type definition that declares it as optional.\n */\nexport class MaybeType<T extends FieldDefinition> {\n  public constructor(public type: T) {}\n}\n\n/**\n * Wrap any definition as optional.\n */\nexport function optional<T extends FieldDefinition>(t: T): MaybeType<T> {\n  return new MaybeType(t);\n}\n\n/**\n * A definition for an object binary encoder.\n */\nexport type EncoderDefinition = {\n  [key: string]: FieldDefinition | MaybeType<FieldDefinition>;\n};\n\n/**\n * Definition for an object-field binary encoder.\n */\nexport type FieldDefinition = keyof ValueTypes | [keyof ValueTypes] | EncoderDefinition | [EncoderDefinition] | MaybeType<FieldDefinition>;\n\n/**\n * The resulting type of the decoded data, based on the encoder definition.\n */\nexport type InferredDecodedType<EncoderType extends EncoderDefinition> = {\n  [EKey in keyof EncoderType as EncoderType[EKey] extends MaybeType<any> ? never : EKey]: EncoderType[EKey] extends keyof ValueTypes\n      ? ValueTypes[EncoderType[EKey]]\n      : EncoderType[EKey] extends [keyof ValueTypes]\n        ? Array<ValueTypes[EncoderType[EKey][0]]>\n        : EncoderType[EKey] extends EncoderDefinition\n          ? InferredDecodedType<EncoderType[EKey]>\n          : EncoderType[EKey] extends [EncoderDefinition]\n            ? Array<InferredDecodedType<EncoderType[EKey][number]>>\n            : never;\n} & {\n  [EKey in keyof EncoderType as EncoderType[EKey] extends MaybeType<any> ? EKey : never]?: EncoderType[EKey] extends MaybeType<infer OptionalValue extends keyof ValueTypes>\n    ? ValueTypes[OptionalValue] | undefined\n    : EncoderType[EKey] extends MaybeType<infer OptionalValue extends [keyof ValueTypes]>\n      ? Array<ValueTypes[OptionalValue[0]]> | undefined\n      : EncoderType[EKey] extends MaybeType<infer OptionalValue extends EncoderDefinition>\n        ? InferredDecodedType<OptionalValue> | undefined\n        : never;\n};\n\nexport type InferredTransformConfig<EncoderType extends EncoderDefinition> = {\n [EKey in keyof EncoderType]?: EncoderType[EKey] extends keyof ValueTypes\n     ? Transforms<ValueTypes[EncoderType[EKey]]>\n     : EncoderType[EKey] extends [keyof ValueTypes]\n       ? Transforms<ValueTypes[EncoderType[EKey][0]]>\n       : EncoderType[EKey] extends EncoderDefinition\n         ? InferredTransformConfig<EncoderType[EKey]>\n         : EncoderType[EKey] extends [EncoderDefinition]\n           ? InferredTransformConfig<EncoderType[EKey][number]>\n           : EncoderType[EKey] extends MaybeType<infer OptionalValue extends keyof ValueTypes>\n            ? Transforms<ValueTypes[OptionalValue]>\n            : EncoderType[EKey] extends MaybeType<infer OptionalValue extends [keyof ValueTypes]>\n              ? Transforms<ValueTypes[OptionalValue[0]]>\n              : EncoderType[EKey] extends MaybeType<infer OptionalValue extends EncoderDefinition>\n                ? InferredTransformConfig<OptionalValue> | undefined\n                : never;\n};\n\nexport type InferredValidationConfig<EncoderType extends EncoderDefinition> = {\n [EKey in keyof EncoderType]?: EncoderType[EKey] extends keyof ValueTypes\n     ? ValidationFn<ValueTypes[EncoderType[EKey]]>\n     : EncoderType[EKey] extends [keyof ValueTypes]\n       ? ValidationFn<ValueTypes[EncoderType[EKey][0]]>\n       : EncoderType[EKey] extends EncoderDefinition\n         ? InferredValidationConfig<EncoderType[EKey]>\n         : EncoderType[EKey] extends [EncoderDefinition]\n           ? InferredValidationConfig<EncoderType[EKey][number]>\n           : EncoderType[EKey] extends MaybeType<infer OptionalValue extends keyof ValueTypes>\n            ? ValidationFn<ValueTypes[OptionalValue]>\n            : EncoderType[EKey] extends MaybeType<infer OptionalValue extends [keyof ValueTypes]>\n              ? ValidationFn<ValueTypes[OptionalValue[0]]>\n              : EncoderType[EKey] extends MaybeType<infer OptionalValue extends EncoderDefinition>\n                ? InferredValidationConfig<OptionalValue> | undefined\n                : never;\n};\n","import { writers, readers } from './lib/coders';\nimport * as coders from './lib/coders';\nimport { $hashCode, $strToHashCode } from './lib/hashCode';\nimport { peekHeader, peekHeaderStr } from './lib/peek';\nimport { BufferWriter } from './lib/BufferWriter';\nimport { BufferReader } from './lib/BufferReader';\nimport {\n  InferredDecodedType,\n  EncoderDefinition,\n  Type,\n  MaybeType,\n  InferredTransformConfig,\n  InferredValidationConfig,\n  ValidationFn,\n  Transforms,\n  FieldDefinition\n} from './Type';\nimport { cfg } from './config';\n\nexport type FormatHeader = string | number;\n\n/**\n * Decoded object types for a given binary format.\n * @example let onData = (data: Decoded<typeof MyBufferFormat>) => {...};\n */\nexport type Decoded<FromBufferFormat> = FromBufferFormat extends BufferFormat<infer EncoderType, any> ? InferredDecodedType<EncoderType> : never;\n\n/**\n * Defines a format for encoding/decoding binary buffers.\n *\n * Optionally customize the identifier, either as a 2-byte string, an unsigned integer (0 -> 65,535), or as `null` to disable entirely.\n *\n * @example\n * const MyFormat = defineFormat({ ... });\n * const MyFormat = defineFormat('ab', { ... });\n * const MyFormat = defineFormat(1234, { ... });\n * const MyFormat = defineFormat(null, { ... });\n */\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(def: T): BufferFormat<T, HeaderType>;\n/**\n * Defines a format for encoding/decoding binary buffers.\n *\n * Optionally customize the identifier, either as a 2-byte string, an unsigned integer (0 -> 65,535), or as `null` to disable entirely.\n *\n * @example\n * const MyFormat = defineFormat({ ... });\n * const MyFormat = defineFormat('ab', { ... });\n * const MyFormat = defineFormat(1234, { ... });\n * const MyFormat = defineFormat(null, { ... });\n */\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(h: HeaderType | null, def: T): BufferFormat<T, HeaderType>;\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends string | number = number>(a?: HeaderType | T, b?: T): BufferFormat<T, HeaderType> {\n  return a !== null && typeof a === 'object'\n    ? new BufferFormat<T, HeaderType>(a as T)\n    : new BufferFormat<T, HeaderType>(b as T, a as HeaderType);\n}\n\nfunction isValidHeader(h: FormatHeader): boolean {\n  if (typeof h === 'number') return Number.isInteger(h) && h >= 0 && h <= 65_535;\n  if (typeof h === 'string') return new TextEncoder().encode(h).byteLength === 2;\n  return false;\n}\n\n/**\n * BufferFormat is a utility class for encoding and decoding binary data based\n * on a provided encoding format.\n *\n * @see {header}\n * @see {encode(data)}\n * @see {decode(binary)}\n */\nexport class BufferFormat<EncoderType extends EncoderDefinition, HeaderType extends FormatHeader = number> {\n  /** @internal */\n  private static _$globalWriter?: BufferWriter;\n\n  /**\n   * A unique identifier encoded as the first 2 bytes (or `undefined` if headerless).\n   *\n   * @see {peekHeader(...)}\n   * @see {peekHeaderStr(...)}\n   */\n  public header!: HeaderType;\n\n  /** @internal */\n  private _$header!: number; // always uint16 vesion\n  /** @internal */\n  private _$type!: Type;\n  /** @internal */\n  private _$fields!: Field[];\n  /** @internal */\n  private _$fieldsMap!: Map<string, Field>;\n\n  /** @internal */\n  private _$format?: string;\n  /** @internal */\n  private _$transforms?: Transforms<any> | undefined;\n  /** @internal */\n  private _$validate?: ValidationFn<any> | undefined;\n  /** @internal */\n  private _$hasValidationOrTransforms = false;\n  /** @internal */\n  private _$writer?: BufferWriter;\n\n  public get encodingBuffer(): DataView | undefined {\n    return this._$writer?._$dataView;\n  }\n\n  public constructor(\n    def: EncoderType,\n    header?: HeaderType | null,\n  ) {\n    // set definition\n    if (typeof def === 'number') {\n      this._$type = def;\n    }\n    else if (def instanceof MaybeType) {\n      throw new TypeError('Format cannot be optional');\n    }\n    else if (def instanceof Object) {\n      this._$type = undefined; // object\n      this._$fieldsMap = new Map();\n      this._$fields = Object.keys(def).map((name) => {\n        const f = new Field(name, def[name]);\n        this._$fieldsMap.set(name, f); // also set map entry\n        return f;\n      });\n\n      // set headers\n      if (header === undefined) {\n        this.header = $hashCode(this.f) as HeaderType; // automatic\n        this._$header = this.header as number;\n      }\n      else if (header === null) {\n        this.header = undefined; // headerless\n        this._$header = undefined;\n      }\n      else if (isValidHeader(header)) {\n        this.header = header; // manual\n        this._$header = typeof header === 'number' ? header : $strToHashCode(header);\n      }\n      else {\n        throw new TypeError(`Header must be uint16, 2 byte string, or null. Received: ${header}`);\n      }\n    }\n    else {\n      throw new TypeError('Format must be object or Type');\n    }\n  }\n\n  // ----- Static methods: -----\n\n  /**\n   * Read the header of a buffer as a number.\n   *\n   * @see {header}\n   * @throws {RangeError} if buffer size < 2\n   */\n  public static peekHeader = peekHeader;\n\n  /**\n   * Read the header of a buffer as a string.\n   *\n   * @see {header}\n   * @throws {RangeError} if buffer size < 2\n   */\n  public static peekHeaderStr = peekHeaderStr;\n\n  // ----- Accessors: -----\n\n  /**\n   * @example \"{uint8,str[]?}\"\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  private get f(): string {\n    if (this._$format === undefined) {\n      this._$format = this._$fields !== undefined\n        ? `{${this._$fields.map(v => v.f).join(',')}}`\n        : `${this._$type}`;\n    }\n\n    return this._$format;\n  }\n\n  /** @internal */\n  private static _$initWriter(): BufferWriter {\n    if (cfg.useGlobalEncodingBuffer) {\n      if (!BufferFormat._$globalWriter) {\n        // lazy init: global encoding buffer created at max size\n        this._$globalWriter = new BufferWriter(cfg.encodingBufferInitialSize);\n      }\n\n      return this._$globalWriter;\n    }\n\n    return new BufferWriter(cfg.encodingBufferInitialSize);\n  }\n\n  /**\n   * Encode an object to bytes.\n   *\n   * **Warning:** Returns an unsafe view into the encoding buffer. Pass this reference to preserve\n   * performance, and to minimize memory allocation and fragmentation.\n   *\n   * @param data - data to encode\n   * @param preserveBytes - (default: `setTinybufConfig().safe`) When set to true, copies encoded\n   * bytes to a new buffer. When set to false, returns an unsafe view of bytes but prevents\n   * unnnecessary memory allocation and fragmentation.\n   *\n   * @returns a copy of encoded bytes\n   * @throws if fails to encode value to schema\n   */\n  public encode<DecodedType extends InferredDecodedType<EncoderType>>(\n    data: DecodedType,\n    preserveBytes?: boolean,\n  ): Uint8Array {\n    if (!this._$writer) {\n      // lazy init\n      this._$writer = BufferFormat._$initWriter();\n    }\n\n    // reset\n    this._$writer.i = 0;\n\n    if (this._$hasValidationOrTransforms) {\n      data = this._$preprocess(data);\n    }\n\n    this._$write(data, this._$writer);\n\n    return (preserveBytes ?? cfg.safe)\n      ? this._$writer.$copyBytes()\n      : this._$writer.$viewBytes();\n  }\n\n  /**\n   * Decode binary data to an object.\n   * @throws if fails to decode bytes to schema.\n   */\n  public decode<DecodedType = InferredDecodedType<EncoderType>>(b: Uint8Array | ArrayBufferView | ArrayBuffer): DecodedType {\n    return this._$read(new BufferReader(b, this.header === undefined ? 0 : 2));\n  }\n\n  /**\n   * Set additional transform functions to apply before encoding and after decoding.\n   */\n  public setTransforms(transforms: InferredTransformConfig<EncoderType> | Transforms<any>): this {\n    this._$hasValidationOrTransforms = true;\n\n    if (typeof transforms === 'function' || (Array.isArray(transforms) && typeof transforms[0]  === 'function')) {\n      this._$transforms = transforms;\n    }\n    else {\n      for (const name of Object.keys(transforms)) {\n        const field = this._$fieldsMap.get(name);\n        if (!field) {\n          throw new TypeError(`Failed to set transforms for field '${name}'`);\n        }\n\n        // Set validation for object.\n        field.$coder.setTransforms(transforms[name]);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Set additional validation rules which are applied on encode() and decode().\n   *\n   * - Validation functions should throw an error, return an error, or return boolean false.\n   * - Anything else is treated as successfully passing validation.\n   */\n  public setValidation(validations: InferredValidationConfig<EncoderType> | ValidationFn<any>): this {\n    this._$hasValidationOrTransforms = true;\n\n    if (typeof validations === 'function') {\n      this._$validate = validations;\n    }\n    else {\n      for (const name of Object.keys(validations)) {\n        const field = this._$fieldsMap.get(name);\n        if (!field) {\n          throw new TypeError(`Failed to set validation function for field '${name}'`);\n        }\n\n        field.$coder.setValidation(validations[name]);\n      }\n    }\n\n    return this;\n  }\n\n  // ----- Implementation: -----\n\n  /**\n   * @param value\n   * @param bw\n   * @throws if the value is invalid\n   *\n   * @internal\n   */\n  private _$write(value: any, bw: BufferWriter): void {\n    // write header\n    if (this._$header !== undefined) bw.$writeUint16(this._$header);\n\n    // write scalar\n    if (this._$type !== undefined) {\n      const safeValue = (this._$validate || this._$transforms) ? this._$preprocess(value) : value;\n\n      return writers[this._$type](safeValue, bw);\n    }\n\n    // check for object type\n    if (typeof value !== 'object' || !value) {\n      throw new TypeError('expected object type');\n    }\n\n    // write each field\n    for (const field of this._$fields) {\n      const subValue = value[field.$name];\n\n      if (field.$isOptional) {\n        if (subValue === undefined || subValue === null) {\n          coders.boolCoder.$write(false, bw);\n          continue; // skip\n        }\n        else {\n          coders.boolCoder.$write(true, bw);\n        }\n      }\n      else if (subValue == null) {\n        throw new Error(`missing required value: ${field.$name}`);\n      }\n\n      if (field.$isArray) {\n        // array\n        this._$writeArray(subValue, bw, field.$coder);\n        continue;\n      }\n\n      // scalar/object field\n      field.$coder._$write(subValue, bw);\n    }\n  }\n\n  /**\n   * pre-process: validation and/or transforms\n   * @internal\n   */\n  private _$preprocess<T extends Record<string, any>>(data: T): T {\n    if (this._$validate) this._$processValidation(data);\n\n    if (typeof this._$transforms === 'function') {\n      return this._$transforms(data);\n    }\n    else if (Array.isArray(this._$transforms) && typeof this._$transforms[0] === 'function') {\n      return this._$transforms[0](data);\n    }\n\n    return data;\n  }\n\n  /**\n   * post-process: validation and/or transforms\n   * @internal\n   */\n  private _$postprocess<T extends Record<string, any>>(data: T): T {\n    if (Array.isArray(this._$transforms) && typeof this._$transforms[1] === 'function') {\n      data = this._$transforms[1](data);\n    }\n\n    if (this._$validate) this._$processValidation(data);\n\n    return data;\n  }\n\n  private _$processValidation(data: any): void {\n    if (!this._$validate) return;\n    const res = this._$validate(data);\n    if (res instanceof Error) throw res;\n    if (res === false) throw new Error('failed validation');\n  }\n\n  /**\n   * This function will be executed only the first time\n   * After that, we'll compile the read routine and add it directly to the instance\n   * @param state\n   * @returns\n   * @throws if fails\n   *\n   * @internal\n   */\n  private _$read<DecodedType = InferredDecodedType<EncoderType>>(state: BufferReader): DecodedType {\n    // This function will be executed only the first time to compile the read routine.\n    // After that, we'll compile the read routine and add it directly to the instance\n\n    // Update the read method implementation.\n    this._$read = this._$compileFormatReadFn();\n\n    return this._$read(state);\n  }\n\n  /**\n   * Generate read function code for this coder.\n   *\n   * @example\n   * // new Type({a:'int', 'b?':['string']}) would emit:\n   *\n   * `return {\n   *   a: this._readField(0, state),\n   *   b: this._readField(1, state),\n   * }`\n   *\n   * @internal\n   */\n  private _$makeObjectReader(): string {\n    const fieldsStr: string = this._$fields\n      .map(({ $name: name }, i) => `${name}:this.${this._$readField.name}(${i},state)`)\n      .join(',');\n\n    return `return{${fieldsStr}}`;\n  }\n\n  /**\n   * Read an individual field.\n   * @internal\n   */\n  private _$readField(fieldId: number, state: BufferReader): any {\n    const field = this._$fields[fieldId];\n\n    if (field.$isOptional && !coders.boolCoder.$read(state)) {\n      return undefined;\n    }\n\n    if (field.$isArray) {\n      return this._$readArray(field.$coder, state);\n    }\n\n    return field.$coder._$read(state);\n  }\n\n  /**\n   * Compile the decode() method for this object.\n   *\n   * @internal\n   */\n  private _$compileFormatReadFn<DecodedType = InferredDecodedType<EncoderType>>(): (state: BufferReader) => DecodedType {\n    if (this._$type !== undefined) {\n      // object type\n      return this._$hasValidationOrTransforms\n        ? (s) => this._$postprocess(readers[this._$type](s))\n        : readers[this._$type];\n    }\n\n    // scalar type\n    return new Function('state', this._$makeObjectReader()) as any;\n  }\n\n  /**\n   * @internal\n   */\n  private _$writeArray(value: any[], bw: BufferWriter, type: BufferFormat<any, any>): void {\n    if (!Array.isArray(value)) {\n      throw new TypeError(`expected array, instead got: ${value}`);\n    }\n\n    coders.uintCoder.$write(value.length, bw);\n    for (let i = 0; i < value.length; i++) {\n      type._$write(value[i], bw);\n    }\n  }\n\n  /**\n   * @throws if invalid data\n   * @internal\n   */\n  private _$readArray<T extends EncoderDefinition>(type: BufferFormat<T, any>, state: any): Array<T> {\n    const arr = new Array(/* length: */ coders.uintCoder.$read(state));\n    for (let j = 0; j < arr.length; j++) {\n      arr[j] = type._$read(state);\n    }\n    return arr;\n  }\n}\n\n/**\n * Parses and represents an object field.\n *\n * @internal\n */\nclass Field {\n  public $name: string;\n  public $coder: BufferFormat<any>;\n  public $isOptional: boolean;\n  public $isArray: boolean;\n\n  private _$formatString?: string;\n\n  public constructor(name: string, rawType: FieldDefinition) {\n    this.$isOptional = rawType instanceof MaybeType;\n    let type = rawType instanceof MaybeType ? rawType.type : rawType;\n\n    this.$name = name;\n\n    if (Array.isArray(type)) {\n      if (type.length !== 1) {\n        throw new TypeError('Array type must contain exactly one format');\n      }\n\n      type = type[0];\n      this.$isArray = true;\n    }\n    else {\n      this.$isArray = false;\n    }\n\n    this.$coder = new BufferFormat<any>(type, null);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  public get f(): string {\n    if (this._$formatString === undefined) {\n      this._$formatString = `${(this.$coder as any).f}${this.$isArray ? '[]' : ''}${this.$isOptional ? '?' : ''}`;\n    }\n\n    return this._$formatString;\n  }\n}\n"],"names":["TinybufError","Error","$hashCode","str","hash","i","length","charCodeAt","$strToHashCode","$hashCodeToStr","hashCode","String","fromCharCode","Math","floor","peekHeader","b","ArrayBuffer","isView","DataView","buffer","byteOffset","getUint16","peekHeaderStr","bufferParser","BufferParser","constructor","this","_$formats","Map","processBuffer","f","data","cb","header","has","get","decode","e","err","stack","on","format","callback","overwritePrevious","set","ignore","forEach","clear","$floor","$ceil","ceil","$clamp","value","min","max","$roundTowardZero","x","$roundAwayFromZero","uscalround","$fromuscal8","$touscal8","scalround","$fromscal8","$toscal8","mask","padBit","reduce","n","unmask","len","clz32","result","Array","$utf8encode","encoder","TextEncoder","encode","$utf8decode","decoder","TextDecoder","y","f16round","$fromf16","$tof16","Float32Array","Int32Array","s","z","pow","d","m","Infinity","NaN","MAX_VARINT32","POW_32","uintCoder","$write","writer","$writeUint8","$writeUint16","$writeUint32","$read","reader","firstByte","$peek","$readUint32","$readUint16","$skip","uint8Coder","$readUint8","uint16Coder","uint32Coder","intCoder","intValue","int8Coder","$writeInt8","$readInt8","int16Coder","$writeInt16","$readInt16","int32Coder","$writeInt32","$readInt32","float16Coder","float32Coder","$writeFloat32","$readFloat32","float64Coder","$writeFloat64","$readFloat64","uscalar8Coder","scalar8Coder","dateCoder","getTime","Date","stringCoder","bytes","bufferCoder","byteLength","$writeBytes","$readBytes","boolCoder","boolsCoder","slice","jsonCoder","JSON","stringify","parse","regexCoder","global","ignoreCase","multiline","source","g","RegExp","writers","readers","setTinybufConfig","c","cfg","Object","assign","safe","useGlobalEncodingBuffer","encodingBufferMaxSize","encodingBufferInitialSize","encodingBufferIncrement","BufferWriter","initialSize","_$dataView","$viewBytes","Uint8Array","$copyBytes","setInt8","_$alloc","setInt16","setInt32","setUint8","setUint16","setUint32","setFloat32","setFloat64","j","bBytes","newView","console","log","error","minBytesNeeded","requestedNewBytes","_$resizeBuffer","newSize","newBuf","oldView","BufferReader","headerBytes","getUint8","r","getUint32","getInt8","getInt16","getInt32","getFloat32","getFloat64","RangeError","view","Type","MaybeType","type","optional","t","defineFormat","a","BufferFormat","encodingBuffer","_$writer","_a","def","_$hasValidationOrTransforms","_$type","TypeError","undefined","_$fieldsMap","_$fields","keys","map","name","Field","_$header","isValidHeader","h","Number","isInteger","_$format","v","join","_$initWriter","_$globalWriter","preserveBytes","_$preprocess","_$write","_$read","setTransforms","transforms","isArray","_$transforms","field","$coder","setValidation","validations","_$validate","bw","safeValue","subValue","$name","$isOptional","coders.boolCoder","$isArray","_$writeArray","_$processValidation","_$postprocess","res","state","_$compileFormatReadFn","_$makeObjectReader","_$readField","fieldId","_$readArray","Function","coders.uintCoder","arr","rawType","_$formatString"],"mappings":"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"}