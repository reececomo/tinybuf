{"version":3,"file":"index.cjs","sources":["../src/core/lib/errors.ts","../src/core/lib/hashCode.ts","../src/core/lib/peek.ts","../src/core/BufferParser.ts","../src/core/lib/math.ts","../src/core/lib/scalar.ts","../src/core/Type.ts","../src/core/lib/bitmask.ts","../src/core/lib/utf8.ts","../src/core/lib/float16.ts","../src/core/lib/bfloat16.ts","../src/core/lib/coders.ts","../src/core/config.ts","../src/core/lib/BufferWriter.ts","../src/core/lib/BufferReader.ts","../src/core/BufferFormat.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/unified-signatures */\n\nexport class TinybufError extends Error {}\n","/**\n * DJB2 hash algorithm (modified for 16-bit uints).\n *\n * DJB2 is a simple and widely used non-cryptographic\n * hash function created by Daniel J. Bernstein.\n *\n * @returns 16-bit unsigned integer\n */\nexport function $hashCode(str: string): number {\n  let hash = 5381;\n  for (let i = 0; i < str.length; i++) {\n    hash = (hash * 33) ^ str.charCodeAt(i);\n  }\n  return hash & 0xFFFF; // Ensure the result is a Uint16\n}\n\n/**\n * Returns an unsigned 16-bit integer hashcode for some string.\n * Prefers 2 character string.\n *\n * @returns A UInt16 between 0 and 65535 (inclusive).\n */\nexport function $strToHashCode(str: string): number {\n  if (str.length !== 2) return $hashCode(str);\n  return str.charCodeAt(0) * 256 + str.charCodeAt(1);\n}\n\n/**\n * Convert a UInt16 hashcode to a 2-byte string.\n */\nexport function $hashCodeToStr(hashCode: number): string {\n  return String.fromCharCode(Math.floor(hashCode / 256)) + String.fromCharCode(hashCode % 256);\n}\n","import { $hashCodeToStr } from \"./hashCode\";\n\n\n/**\n * Read the header bytes of a buffer as a number.\n *\n * @throws {RangeError} if buffer size < 2\n */\nexport function peekHeader(b: ArrayBuffer | ArrayBufferView): number {\n  return (ArrayBuffer.isView(b) ? new DataView(b.buffer, b.byteOffset, 2) : new DataView(b, 0, 2)).getUint16(0, false);\n}\n\n/**\n * Read the header bytes of a buffer as a string.\n *\n * @throws {RangeError} if buffer length < 2\n */\nexport function peekHeaderStr(b: ArrayBuffer | ArrayBufferView): string {\n  return $hashCodeToStr(peekHeader(b));\n}\n","import { BufferFormat } from \"./BufferFormat\";\nimport { EncoderDefinition, DecodedType } from \"./Type\";\nimport { TinybufError } from \"./lib/errors\";\nimport { $hashCodeToStr, $strToHashCode } from \"./lib/hashCode\";\nimport { peekHeader } from \"./lib/peek\";\n\ntype AnyFormat = BufferFormat<any, any>;\ntype Uint16FormatHeader = number;\n\n/**\n * Small utility for registering and processing format handlers.\n *\n * @example\n * const myHandler = bufferParser()\n *   .on(FormatA, aData => {})\n *   .on(FormatB, bData => {});\n *\n * myHandler.processBuffer(bytes);\n */\nexport const bufferParser = (): BufferParser => new BufferParser();\n\nexport class BufferParser {\n  /** @internal */\n  private _$formats = new Map<Uint16FormatHeader, [format: AnyFormat, handler: (data: any) => any, decodeInPlace: boolean]>();\n  private _$data = new Map<Uint16FormatHeader, any>(); // used when decoding in-place\n\n  /**\n   * Decode an array buffer and trigger the relevant data handler.\n   *\n   * When passed an ArrayBufferView, accesses the underlying 'buffer' instance directly.\n   *\n   * @throws {TinybufError} if fails to decode, or no handler is registered\n   */\n  public processBuffer(b: ArrayBuffer | ArrayBufferView): void {\n    let f: any, data: any, cb: (data: any) => any, r: boolean;\n\n    try {\n      const header = peekHeader(b);\n\n      if (!this._$formats.has(header)) {\n        throw new TinybufError(`Unknown format: ${header} '${$hashCodeToStr(header)}')`);\n      }\n\n      [f, cb, r] = this._$formats.get(header);\n      if (r) data = this._$data.get(header) ?? {};\n      data = f.decode(b, data);\n      if (r) this._$data.set(header, data);\n    }\n    catch (e) {\n      const err = new TinybufError(`Failed to decode: ${e}`);\n      err.stack = e.stack;\n\n      throw err;\n    }\n\n    cb(data);\n  }\n\n  /**\n   * Register a format handler.\n   */\n  public on<EncoderType extends EncoderDefinition, TDecodedType = DecodedType<EncoderType>>(\n    format: BufferFormat<EncoderType, string | number>,\n    callback: (data: TDecodedType) => any,\n    {\n      decodeInPlace = false,\n    } = {},\n  ): this {\n    if (format.header == null) {\n      throw new TinybufError(\"Format requires header\");\n    }\n\n    const header = typeof format.header === \"string\" ? $strToHashCode(format.header) : format.header;\n\n    if (this._$formats.has(header) && this._$formats.get(header)?.[0] !== format) {\n      throw new TinybufError(`Format header collision: ${format.header}`);\n    }\n\n    this._$formats.set(header, [format, callback, decodeInPlace]);\n\n    return this;\n  }\n\n  /** Register a format (or formats) that are recognized. */\n  public ignore(...format: AnyFormat[]): this {\n    format.forEach(f => this.on(f, () => {}));\n    return this;\n  }\n\n  /** Clears all registered formats and handlers. */\n  public clear(): void {\n    this._$formats.clear();\n    this._$data.clear();\n  }\n}\n","export const $floor = Math.floor,\n  $ceil = Math.ceil;\n\n/** Clamp a number to a range. */\nexport const $clamp = (value: number, min: number, max: number): number =>\n  value > max ? max : value < min ? min : value;\n\n/** Round toward zero */\nexport const $roundTowardZero = (x: number): number => x < 0 ? $ceil(x) : $floor(x);\n\n/** Round away zero */\nexport const $roundAwayFromZero = (x: number): number =>\n  x < 0 ? $floor(x) : $ceil(x);\n","import { $clamp, $roundTowardZero, $roundAwayFromZero } from \"./math\";\n\n/**\n * Quantize a number to an 8-bit scalar between 0.0 and 1.0.\n *\n * @returns A number (double) in its closest signed scalar representation.\n */\nexport function uscalround(x: number): number {\n  return $fromuscal8($touscal8(x));\n}\n\n/**\n * Quantize a number to an 8-bit signed scalar between -1.0 and 1.0.\n *\n * @returns A number (double) in its closest signed scalar representation.\n */\nexport function scalround(x: number): number {\n  return $fromscal8($toscal8(x));\n}\n\n/** @returns A UInt8 bitmask representation. */\nexport function $touscal8(x: number): number {\n  return $clamp(127 + $roundTowardZero(x * 254 - 127), 0, 254);\n}\n\n/** @returns A UInt8 bitmask representation. */\nexport function $toscal8(x: number): number {\n  return $clamp($roundTowardZero(x * 127), -127, 127) + 127;\n}\n\n/** @returns An unsigned scalar between 0.0 and 1.0. */\nexport function $fromuscal8(x: number): number {\n  // Make symmetric: (0.5 + round((uint8 - 127) / 254 * 100)) / 100\n  return $clamp(($roundAwayFromZero((x - 127) * 0.3937007874015748) + 50) * 0.01, 0, 1);\n}\n\n/** @returns A signed scalar between -1.0 and 1.0. */\nexport function $fromscal8(x: number): number {\n  // Make symmetric: round((uint8 - 127) / 127 * 100) / 100\n  return $clamp($roundAwayFromZero((x - 127) * 0.787401574803149) * 0.01, -1, 1);\n}\n","/**\n * Field types for defining encoding formats.\n *\n * @see [Types](https://github.com/reececomo/tinybuf/blob/main/docs/types.md)\n */\nexport const Type = {\n  /**\n   * Unsigned integer (1 - 8 bytes).\n   * - 0 → 127 = 1 byte\n   * - 128 → 16,384 = 2 bytes\n   * - 16,385 → 536,870,911 = 4 bytes\n   * - 536,870,912 → `Number.MAX_SAFE_INTEGER` = 8 bytes\n   */\n  UInt: \"uint\",\n\n  /** Unsigned 8-bit integer (between 0 and 255, 1 byte). */\n  UInt8: \"u8\",\n\n  /** Unsigned 16-bit integer (between 0 and 65,535, 2 bytes). */\n  UInt16: \"u16\",\n\n  /** Unsigned 32-bit integer (between 0 and 4,294,967,295, 4 bytes). */\n  UInt32: \"u32\",\n\n  /**\n   * Signed integer (1 - 8 bytes).\n   * - 0 → ±64 = 1 byte\n   * - ±65 → ±8,192 = 2 bytes\n   * - ±8,193 → ±268,435,456 = 4 bytes\n   * - ±268,435,457 → ±`Number.MAX_SAFE_INTEGER` = 8 bytes\n   */\n  Int: \"int\",\n\n  /** Signed 1 byte integer (between -127 and 127). */\n  Int8: \"i8\",\n\n  /** Signed 2 byte integer (between -32,767 and 32,767). */\n  Int16: \"i16\",\n\n  /** Signed 4 byte integer (between -2,147,483,647 and 2,147,483,647). */\n  Int32: \"i32\",\n\n  /** Default JavaScript `number` type. Floating-point number (64-bit, double precision, 8 bytes). */\n  Float64: \"f64\",\n\n  /** Floating-point number (32-bit, single precision, 4 bytes). */\n  Float32: \"f32\",\n\n  /**\n   * Floating-point number (16-bit in FP16 format, half precision, 2 bytes).\n   *\n   * **Warning:** Low precision; maximum range: ±65,504.\n   */\n  Float16: \"f16\",\n\n  /**\n   * Floating-point number (16-bit in BF16 format, half precision, 2 bytes).\n   *\n   * **Warning:** Low precision.\n   */\n  BFloat16: \"b16\",\n\n  /** A signed 2-decimal scalar between -1.00 and 1.00 (1 byte). */\n  Scalar8: \"sc\",\n\n  /** An unsigned 2-decimal scalar between 0.00 and 1.00 (1 byte). */\n  UScalar8: \"usc\",\n\n  /**\n   * Boolean value (1 byte).\n   * @see {Bools} for packing multiple booleans into a single byte.\n   */\n  Bool: \"bl\",\n\n  /** Any array of booleans (1 bit overhead, encoded as UInt). */\n  Bools: \"bls\",\n\n  /** Any ArrayBuffer or ArrayBufferView (e.g. Uint8Array) value (encoded as 1 x UInt for byte length + buffer bytes). */\n  Buffer: \"buf\",\n\n  /** A UTF-8 string (encoded as 1 x UInt for UTF-8 byte length + UTF-8 bytes). */\n  String: \"str\",\n\n  /** Any JSON data (encodes as UTF-8). */\n  JSON: \"jsn\",\n\n  /** JavaScript RegExp object. */\n  RegExp: \"re\",\n\n  /**\n   * JavaScript Date object.\n   *\n   * Encoded as an 8 byte (64-bit) integer UTC timestamp from as the number\n   * of milliseconds since the Unix Epoch (January 1, 1970, 00:00:00 UTC).\n   *\n   * @see {Date}\n   */\n  Date: \"dt\",\n} as const;\n\nexport type TypeLiteral = typeof Type[keyof typeof Type];\nexport const ValidTypes = Object.values(Type);\n\n/**\n * Mappings for the value types.\n */\nexport type ValueTypes = {\n  [Type.Int]: number;\n  [Type.Int8]: number;\n  [Type.Int16]: number;\n  [Type.Int32]: number;\n  [Type.UInt]: number;\n  [Type.UInt8]: number;\n  [Type.UInt16]: number;\n  [Type.UInt32]: number;\n  [Type.Float64]: number;\n  [Type.Float32]: number;\n  [Type.Float16]: number;\n  [Type.BFloat16]: number;\n  [Type.Scalar8]: number;\n  [Type.UScalar8]: number;\n  [Type.Bool]: boolean;\n  [Type.Bools]: boolean[];\n  [Type.Buffer]: Uint8Array | ArrayBuffer | ArrayBufferView;\n  [Type.String]: string;\n  [Type.JSON]: any;\n  [Type.RegExp]: RegExp;\n  [Type.Date]: Date;\n};\n\n/** https://www.totaltypescript.com/concepts/the-prettify-helper */\ntype Pretty<T> = T extends ArrayBuffer | ArrayBufferView | Date | RegExp | Uint8Array ? T\n  : T extends Array<infer U> ? Array<Pretty<U>>\n  : T extends object ? {[K in keyof T]: Pretty<T[K]>} & unknown : T;\n\n/** @throws any error too */\nexport type ValidationFn<T> = (x: T) => undefined | boolean | Error;\nexport type TransformFn<T> = (x: T) => T;\nexport type Transforms<T> = TransformFn<T> | [preEncode: TransformFn<T>] | [preEncode: TransformFn<T> | undefined, postDecode: TransformFn<T> | undefined];\n\n/**\n * A wrapper around any Type definition that declares it as optional.\n */\nexport class MaybeType<T extends FieldDefinition> {\n  public constructor(public type: T) {}\n}\n\n/**\n * Wrap any definition as optional.\n */\nexport function optional<T extends FieldDefinition>(t: T): MaybeType<T> {\n  return new MaybeType(t);\n}\n\n/**\n * A definition for an object binary encoder.\n */\nexport type EncoderDefinition = {\n  [key: string]: FieldDefinition | MaybeType<FieldDefinition>;\n};\n\n/**\n * Definition for an object-field binary encoder.\n */\nexport type FieldDefinition = keyof ValueTypes | [keyof ValueTypes] | EncoderDefinition | [EncoderDefinition] | MaybeType<FieldDefinition>;\n\n/**\n * The resulting type of the decoded data, based on the encoder definition.\n */\ntype RawDecodedType<EncoderType extends EncoderDefinition> = {\n  [EKey in keyof EncoderType as EncoderType[EKey] extends MaybeType<any> ? never : EKey]: EncoderType[EKey] extends keyof ValueTypes\n      ? ValueTypes[EncoderType[EKey]]\n      : EncoderType[EKey] extends [keyof ValueTypes]\n        ? Array<ValueTypes[EncoderType[EKey][0]]>\n        : EncoderType[EKey] extends EncoderDefinition\n          ? RawDecodedType<EncoderType[EKey]>\n          : EncoderType[EKey] extends [EncoderDefinition]\n            ? Array<RawDecodedType<EncoderType[EKey][number]>>\n            : never;\n} & {\n  [EKey in keyof EncoderType as EncoderType[EKey] extends MaybeType<any> ? EKey : never]?: EncoderType[EKey] extends MaybeType<infer OptionalValue extends keyof ValueTypes>\n    ? ValueTypes[OptionalValue] | undefined\n    : EncoderType[EKey] extends MaybeType<infer OptionalValue extends [keyof ValueTypes]>\n      ? Array<ValueTypes[OptionalValue[0]]> | undefined\n      : EncoderType[EKey] extends MaybeType<infer OptionalValue extends EncoderDefinition>\n        ? RawDecodedType<OptionalValue> | undefined\n        : never;\n};\n\nexport type DecodedType<EncoderType extends EncoderDefinition> = Pretty<RawDecodedType<EncoderType>>;\n\nexport type TransformConfig<EncoderType extends EncoderDefinition> = {\n [EKey in keyof EncoderType]?: EncoderType[EKey] extends keyof ValueTypes\n     ? Transforms<ValueTypes[EncoderType[EKey]]>\n     : EncoderType[EKey] extends [keyof ValueTypes]\n       ? Transforms<ValueTypes[EncoderType[EKey][0]]>\n       : EncoderType[EKey] extends EncoderDefinition\n         ? TransformConfig<EncoderType[EKey]>\n         : EncoderType[EKey] extends [EncoderDefinition]\n           ? TransformConfig<EncoderType[EKey][number]>\n           : EncoderType[EKey] extends MaybeType<infer OptionalValue extends keyof ValueTypes>\n            ? Transforms<ValueTypes[OptionalValue]>\n            : EncoderType[EKey] extends MaybeType<infer OptionalValue extends [keyof ValueTypes]>\n              ? Transforms<ValueTypes[OptionalValue[0]]>\n              : EncoderType[EKey] extends MaybeType<infer OptionalValue extends EncoderDefinition>\n                ? TransformConfig<OptionalValue> | undefined\n                : never;\n};\n\nexport type ValidationConfig<EncoderType extends EncoderDefinition> = {\n [EKey in keyof EncoderType]?: EncoderType[EKey] extends keyof ValueTypes\n     ? ValidationFn<ValueTypes[EncoderType[EKey]]>\n     : EncoderType[EKey] extends [keyof ValueTypes]\n       ? ValidationFn<ValueTypes[EncoderType[EKey][0]]>\n       : EncoderType[EKey] extends EncoderDefinition\n         ? ValidationConfig<EncoderType[EKey]>\n         : EncoderType[EKey] extends [EncoderDefinition]\n           ? ValidationConfig<EncoderType[EKey][number]>\n           : EncoderType[EKey] extends MaybeType<infer OptionalValue extends keyof ValueTypes>\n            ? ValidationFn<ValueTypes[OptionalValue]>\n            : EncoderType[EKey] extends MaybeType<infer OptionalValue extends [keyof ValueTypes]>\n              ? ValidationFn<ValueTypes[OptionalValue[0]]>\n              : EncoderType[EKey] extends MaybeType<infer OptionalValue extends EncoderDefinition>\n                ? ValidationConfig<OptionalValue> | undefined\n                : never;\n};\n","/**\n * Mask booleans to a uint32.\n *\n * @param x - A boolean array.\n * @param padBit - A bit to pad the mask (for variable length data).\n */\nexport const mask = (x: boolean[], padBit: 0 | 1 = 0b1): number => {\n  return x.reduce((n, b: any) => (n << 1) | b, padBit);\n};\n\n/**\n * Unmask booleans from a uint32.\n *\n * @param x - A uint32 number.\n * @param l - number of booleans to expect (default: infer lenth from x where x is encoded with a pad bit)\n * or pass an existing boolean array to decode in-place.\n */\nexport const unmask = (x: number, l?: number | boolean[]): boolean[] => {\n  const len = l === undefined ? 31 - Math.clz32(x) : Array.isArray(l) ? l.length : l;\n  const val = Array.isArray(l) && l.length === len ? l : new Array<boolean>(len);\n  for (let i = 0; i < len; i++) val[i] = !!(x & (1 << (len - 1 - i)));\n  return val;\n};\n","export const $utf8encode = (function () {\n  const encoder = new TextEncoder();\n  return (x?: string): Uint8Array => encoder.encode(x);\n})();\n\nexport const $utf8decode = (function () {\n  const decoder = new TextDecoder(\"utf-8\");\n  return (y: Uint8Array): string => decoder.decode(y);\n})();\n","/**\n * Returns the nearest half precision float representation of a number.\n * @param x A numeric expression.\n */\nexport function f16round(x: number): number {\n  return $fromf16($tof16(x));\n}\n\n/**\n * Returns the nearest half precision float representation of a number as a 16-bit bitmask.\n */\nexport const $tof16 = (function() {\n  const x = new Float32Array(1);\n  const y = new Int32Array(x.buffer);\n\n  return function (f: number) {\n    x[0] = f;\n    let i = y[0]; // 32-bit int\n    let s = (i >> 16) & 0X8000; // sign\n    let z = (i & 0X7FFFFFFF) + 0X1000 | 0;\n\n    if (z >= 0X47800000) {\n      if ((i & 0X7FFFFFFF) < 0X47800000) return s | 0X7BFF;\n      if (z < 0X7F800000) return s | 0X7C00;\n      return s | 0X7C00 | (i & 0X007FFFFF) >> 13;\n    }\n    if (z >= 0X38800000) return s | z - 0X38000000 >> 13;\n    else if (z < 0X33000000) return s;\n    z = (i & 0X7FFFFFFF) >> 23;\n    return s | ((i & 0X7FFFFF | 0X800000)\n      + (0X800000 >>> z - 102)\n      >> 126 - z);\n  };\n}());\n\n/**\n * Returns the nearest half precision float value for a 16-bit bitmask.\n */\nexport const $fromf16 = (function() {\n  const z = Math.pow(2, -24); // subnormal constant\n  const d = new Float32Array(32 + 1024);\n  for (let e = 0; e < 32; e++) d[e] = Math.pow(2, e - 15); // biased exponents\n  for (let m = 0; m < 1024; m++) d[m + 0x20] = 1 + m / 1024; // normalized offset mantissas\n\n  return function (b: number): number {\n    const s = (b & 32768) === 32768 ? -1 : 1; // sign: 1 bit\n    const e = b & 31744; // exponent: 5 bits\n    const m = b & 1023; // mantissa: 10 bits\n\n    if (e === 0) return m === 0 ? s * 0 : s * z;\n    if (e === 31744) return m === 0 ? s * Infinity : NaN;\n    return d[e >> 10] * d[m + 0x20] * s;\n  };\n}());\n","const i = new Uint32Array(1);\nconst f = new Float32Array(i.buffer);\n\n/**\n * Returns the nearest bfloat16 representation of a number.\n * @param x A numeric expression.\n */\nexport function bf16round(x: number): number {\n  f[0] = x;\n  i[0] = i[0] & 0xFFFF0000;\n  return f[0];\n}\n\n/** Returns a 16-bit bfloat16 bitmask for a given float. */\nexport function $tobf16(x: number): number {\n  f[0] = x;\n  return i[0] >>> 16;\n}\n\n/** Returns the nearest value from a 16-bit bfloat16 bitmask. */\nexport function $frombf16(x: number): number {\n  i[0] = x << 16;\n  return f[0];\n}\n","import { BufferWriter } from \"./BufferWriter\";\nimport { BufferReader } from \"./BufferReader\";\nimport {\n  $fromuscal8,\n  $fromscal8,\n  $touscal8,\n  $toscal8\n} from \"./scalar\";\nimport { TypeLiteral, Type } from \"../Type\";\nimport { mask, unmask } from \"./bitmask\";\nimport { $utf8decode, $utf8encode } from \"./utf8\";\nimport { $floor } from \"./math\";\nimport { $fromf16, $tof16 } from \"./float16\";\nimport { $frombf16, $tobf16 } from \"./bfloat16\";\n\n// Pre-calculated constants\nconst MAX_VARUINT8 = 128,\n  MAX_VARUINT16 = 16_384,\n  MAX_VARUINT32 = 536_870_912,\n  MAX_VARINT8 = 64,\n  MAX_VARINT16 = 8_192,\n  MAX_VARINT32 = 268_435_456,\n  POW_32 = 0x100000000;\n\ntype WriterFn<W> = (value: W, writer: BufferWriter) => void;\ntype ReaderFn<R> = (reader: BufferReader, overwrite?: Partial<R>) => R;\n\nexport interface BinaryTypeCoder<W, R = W> {\n  $write: WriterFn<W>;\n  $read: ReaderFn<R>;\n}\n\n/**\n * Format (big-endian):\n * 7b   0xxxxxxx\n * 14b  10xxxxxx xxxxxxxx\n * 29b  110xxxxx xxxxxxxx xxxxxxxx xxxxxxxx\n * 61b  111xxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx\n */\nexport const uintCoder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => {\n    if (typeof value !== \"number\") value = Number(value);\n    if (value < 0) value = 0;\n    if (value < MAX_VARUINT8) writer.$writeUint8(value);\n    else if (value < MAX_VARUINT16) writer.$writeUint16(value + 0x8000);\n    else if (value < MAX_VARUINT32) writer.$writeUint32(value + 0xc0000000);\n    else if (value >= MAX_VARUINT32) {\n      writer.$writeUint32($floor(value / POW_32) + 0xe0000000);\n      writer.$writeUint32(value >>> 0);\n    }\n    else {\n      // coercion case\n      writer.$writeUint8(value as any === true ? 1 : 0);\n    }\n  },\n  $read: (reader) => {\n    const firstByte = reader.$peek();\n\n    if (!(firstByte & 0x80)) {\n      reader.$skip();\n      return firstByte;\n    }\n    else if (!(firstByte & 0x40)) {\n      return reader.$readUint16() - 0x8000;\n    }\n    else if (!(firstByte & 0x20)) {\n      return reader.$readUint32() - 0xc0000000;\n    }\n\n    return (reader.$readUint32() - 0xe0000000) * POW_32\n      + reader.$readUint32();\n  }\n};\n\nexport const uint8Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint8(value),\n  $read: (reader) => reader.$readUint8(),\n};\n\nexport const uint16Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint16(value),\n  $read: (reader) => reader.$readUint16(),\n};\n\nexport const uint32Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint32(value),\n  $read: (reader) => reader.$readUint32(),\n};\n\n/**\n * Format (big-endian):\n * 7b   0xxxxxxx\n * 14b  10xxxxxx xxxxxxxx\n * 29b  110xxxxx xxxxxxxx xxxxxxxx xxxxxxxx\n * 61b  111xxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx\n */\nexport const intCoder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => {\n    if (typeof value !== \"number\") value = Number(value);\n    if (value >= -MAX_VARINT8 && value < MAX_VARINT8) writer.$writeUint8(value & 0x7f);\n    else if (value >= -MAX_VARINT16 && value < MAX_VARINT16) writer.$writeUint16((value & 0x3fff) + 0x8000);\n    else if (value >= -MAX_VARINT32 && value < MAX_VARINT32) writer.$writeUint32((value & 0x1fffffff) + 0xc0000000);\n    else if (value < -MAX_VARINT32 || value >= MAX_VARINT32) {\n      // Split in two 32b uints\n      writer.$writeUint32(($floor(value / POW_32) & 0x1fffffff) + 0xe0000000);\n      writer.$writeUint32(value >>> 0);\n    }\n    else {\n      // coercion case\n      writer.$writeUint8(value as any === true ? 0x7f : 0);\n    }\n  },\n  $read: (reader) => {\n    let firstByte = reader.$peek(), i: number;\n\n    if (!(firstByte & 0x80)) {\n      reader.$skip();\n      return (firstByte & 0x40) ? (firstByte | 0xffffff80) : firstByte;\n    }\n    else if (!(firstByte & 0x40)) {\n      i = reader.$readUint16() - 0x8000;\n      return (i & 0x2000) ? (i | 0xffffc000) : i;\n    }\n    else if (!(firstByte & 0x20)) {\n      i = reader.$readUint32() - 0xc0000000;\n      return (i & 0x10000000) ? (i | 0xe0000000) : i;\n    }\n    else {\n      i = reader.$readUint32() - 0xe0000000;\n      i = (i & 0x10000000) ? (i | 0xe0000000) : i;\n      return i * POW_32 + reader.$readUint32();\n    }\n  }\n};\n\nexport const int8Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeInt8(value),\n  $read: (reader) => reader.$readInt8(),\n};\n\nexport const int16Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeInt16(value),\n  $read: (reader) => reader.$readInt16(),\n};\n\nexport const int32Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeInt32(value),\n  $read: (reader) => reader.$readInt32(),\n};\n\nexport const bfloat16Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint16($tobf16(value)),\n  $read: (reader) => $frombf16(reader.$readUint16()),\n};\n\nexport const float16Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint16($tof16(value)),\n  $read: (reader) => $fromf16(reader.$readUint16()),\n};\n\nexport const float32Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeFloat32(value),\n  $read: (reader) => reader.$readFloat32(),\n};\n\nexport const float64Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeFloat64(value),\n  $read: (reader) => reader.$readFloat64(),\n};\n\nexport const uscalar8Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint8($touscal8(value)),\n  $read: (reader) => $fromuscal8(reader.$readUint8()),\n};\n\nexport const scalar8Coder: BinaryTypeCoder<number> = {\n  $write: (value, writer) => writer.$writeUint8($toscal8(value)),\n  $read: (reader) => $fromscal8(reader.$readUint8()),\n};\n\nexport const dateCoder: BinaryTypeCoder<Date> = {\n  $write: (value, writer) => intCoder.$write(value.getTime(), writer),\n  $read: (reader) => new Date(intCoder.$read(reader)),\n};\n\nexport const bufferCoder: BinaryTypeCoder<ArrayBuffer | ArrayBufferView, Uint8Array> = {\n  $write: (value, writer) => {\n    uintCoder.$write(value.byteLength, writer); // prefix length\n    writer.$writeBytes(value);\n  },\n  $read: (reader) => reader.$readBytes(uintCoder.$read(reader)),\n};\n\nexport const stringCoder: BinaryTypeCoder<string> = {\n  $write: (value, writer) => bufferCoder.$write($utf8encode(value), writer),\n  $read: (reader) => $utf8decode(bufferCoder.$read(reader)),\n};\n\nexport const boolCoder: BinaryTypeCoder<boolean> = {\n  $write: (value, writer) => writer.$writeUint8(value ? 1 : 0),\n  $read: (reader) => reader.$readUint8() !== 0,\n};\n\nexport const boolsCoder: BinaryTypeCoder<boolean[]> = {\n  $write: (value, writer) => {\n    if (value.length > 28) value = value.slice(0, 28); // drop additional\n    uintCoder.$write(mask(value), writer);\n  },\n  $read: (reader, p) => unmask(uintCoder.$read(reader), p),\n};\n\nexport const jsonCoder: BinaryTypeCoder<any> = {\n  $write: (value, writer) => stringCoder.$write(JSON.stringify(value), writer),\n  $read: (reader) => JSON.parse(stringCoder.$read(reader)),\n};\n\nexport const regexCoder: BinaryTypeCoder<RegExp> = {\n  $write: (value, writer) => {\n    writer.$writeUint8(mask([value.global, value.ignoreCase, value.multiline]));\n    stringCoder.$write(value.source, writer);\n  },\n  $read: (reader) => {\n    const [g, i, m] = unmask(reader.$readUint8());\n    return new RegExp(stringCoder.$read(reader), (g ? \"g\" : \"\") + (i ? \"i\" : \"\") + (m ? \"m\" : \"\"));\n  }\n};\n\nexport const writers: Record<TypeLiteral, WriterFn<any>> = {\n  [Type.UInt]: uintCoder.$write,\n  [Type.UInt8]: uint8Coder.$write,\n  [Type.UInt16]: uint16Coder.$write,\n  [Type.UInt32]: uint32Coder.$write,\n  [Type.Int]: intCoder.$write,\n  [Type.Int8]: int8Coder.$write,\n  [Type.Int16]: int16Coder.$write,\n  [Type.Int32]: int32Coder.$write,\n  [Type.Float64]: float64Coder.$write,\n  [Type.Float32]: float32Coder.$write,\n  [Type.Float16]: float16Coder.$write,\n  [Type.BFloat16]: bfloat16Coder.$write,\n  [Type.Scalar8]: scalar8Coder.$write,\n  [Type.UScalar8]: uscalar8Coder.$write,\n  [Type.Bool]: boolCoder.$write,\n  [Type.Bools]: boolsCoder.$write,\n  [Type.Buffer]: bufferCoder.$write,\n  [Type.String]: stringCoder.$write,\n  [Type.JSON]: jsonCoder.$write,\n  [Type.RegExp]: regexCoder.$write,\n  [Type.Date]: dateCoder.$write,\n};\n\nexport const readers: Record<TypeLiteral, ReaderFn<any>> = {\n  [Type.UInt]: uintCoder.$read,\n  [Type.UInt8]: uint8Coder.$read,\n  [Type.UInt16]: uint16Coder.$read,\n  [Type.UInt32]: uint32Coder.$read,\n  [Type.Int]: intCoder.$read,\n  [Type.Int8]: int8Coder.$read,\n  [Type.Int16]: int16Coder.$read,\n  [Type.Int32]: int32Coder.$read,\n  [Type.Float64]: float64Coder.$read,\n  [Type.Float32]: float32Coder.$read,\n  [Type.Float16]: float16Coder.$read,\n  [Type.BFloat16]: bfloat16Coder.$read,\n  [Type.Scalar8]: scalar8Coder.$read,\n  [Type.UScalar8]: uscalar8Coder.$read,\n  [Type.Bool]: boolCoder.$read,\n  [Type.Bools]: boolsCoder.$read,\n  [Type.Buffer]: bufferCoder.$read,\n  [Type.String]: stringCoder.$read,\n  [Type.JSON]: jsonCoder.$read,\n  [Type.RegExp]: regexCoder.$read,\n  [Type.Date]: dateCoder.$read,\n};\n","/** Default maximum transmission unit in networking */\nconst MTU = 1500;\n\n/** Set Tinybuf global config */\nexport const setTinybufConfig = (c: Partial<TinybufConfig>): void => {\n  cfg = { ...cfg, ...c };\n};\n\nexport type TinybufConfig = {\n  /**\n   * (default: false)\n   *\n   * This sets the default value for `preserveBytes` on\n   * `encode(data, preserveBytes?)`.\n   *\n   * By default, `encode()` returns its encoded bytes as a `Uint8Array`\n   * view of the bytes in the shared encoding buffer.\n   *\n   * This is suitable for synchronous use (e.g. high-performance applications)\n   * as it avoids slow and expensive memory allocation and fragmentation on\n   * each call to `encode()`.\n   *\n   * However, susbsequent calls are destructive to the underlying bytes, so\n   * for asynchronous uses (e.g. Promises, Workers, long-lived storage), set\n   * `preserveBytes` to `true`.\n   */\n  safe: boolean,\n\n  /**\n   * (default: true)\n   * By default, format encoders share a global encoding buffer for performance\n   * and memory management reasons.\n   *\n   * When set to false, each format is allocated an individual encoding buffer.\n   *\n   * Enable to maximise performance and memory re-use, just be cautious of\n   * possible race conditions.\n   */\n  useGlobalEncodingBuffer: boolean,\n\n  /**\n   * (default: 1500)\n   * The maximum bytes that can be allocated to an encoding buffer.\n   *\n   * Default is 1500 bytes, the standard \"Maximum Transmission Unit\".\n   */\n  encodingBufferMaxSize: number,\n\n  /**\n   * (default: 256)\n   * Initial bytes to allocate for an encoding buffer.\n   */\n  encodingBufferInitialSize: number,\n\n  /**\n   * (default: 256)\n   * Additional bytes to allocated when dynamically increasing the size of an encoding buffer.\n   */\n  encodingBufferIncrement: number,\n};\n\n/** @internal */\nexport let cfg: TinybufConfig = {\n  safe: false,\n  useGlobalEncodingBuffer: true,\n  encodingBufferMaxSize: MTU,\n  encodingBufferInitialSize: 256,\n  encodingBufferIncrement: 256,\n};\n","import { cfg } from \"../config\";\nimport { TinybufError } from \"./errors\";\n\n/**\n * Wraps a buffer with a write head pointer.\n *\n * @internal\n */\nexport class BufferWriter {\n  public $byteLength: number = 0;\n  private _$dataView: DataView;\n  private _$bytes: Uint8Array;\n  private _$writeHead: number = 0;\n  private _$resizable: boolean;\n\n  public constructor($0: number | Uint8Array) {\n    this._$resizable = typeof $0 === \"number\";\n    let b = $0 instanceof Uint8Array ? $0 : new Uint8Array($0);\n    this._$bytes = b;\n    this._$dataView = new DataView(b.buffer, b.byteOffset, b.byteLength);\n  }\n\n  public $viewBytes(): Uint8Array {\n    return this._$bytes.subarray(0, this.$byteLength);\n  }\n\n  public $copyBytes(): Uint8Array {\n    const buf = new Uint8Array(this.$byteLength);\n    buf.set(this.$viewBytes());\n    return buf;\n  }\n\n  // ----- Writers: -----\n\n  public $writeInt8(value: number): void {\n    this._$pre(1).setInt8(this._$writeHead, value);\n  }\n\n  public $writeInt16(value: number): void {\n    this._$pre(2).setInt16(this._$writeHead, value, true);\n  }\n\n  public $writeInt32(value: number): void {\n    this._$pre(4).setInt32(this._$writeHead, value, true);\n  }\n\n  public $writeUint8(value: number): void {\n    this._$pre(1).setUint8(this._$writeHead, value);\n  }\n\n  public $writeUint16(value: number): void {\n    this._$pre(2).setUint16(this._$writeHead, value, false); // big-endian for varint\n  }\n\n  public $writeUint32(value: number): void {\n    this._$pre(4).setUint32(this._$writeHead, value, false); // big-endian for varint\n  }\n\n  public $writeFloat32(value: number): void {\n    this._$pre(4).setFloat32(this._$writeHead, value, true);\n  }\n\n  public $writeFloat64(value: number): void {\n    this._$pre(8).setFloat64(this._$writeHead, value, true);\n  }\n\n  public $writeBytes(b: Uint8Array | ArrayBuffer | ArrayBufferView): void {\n    // allocate bytes first\n    this._$pre(b.byteLength);\n\n    let bBytes: Uint8Array = ArrayBuffer.isView(b)\n      ? b instanceof Uint8Array\n        ? b\n        : new Uint8Array(b.buffer, b.byteOffset, b.byteLength)\n      : new Uint8Array(b);\n\n    // copy bytes\n    new Uint8Array(\n      this._$dataView.buffer,\n      this._$dataView.byteOffset + this._$writeHead,\n      b.byteLength\n    ).set(bBytes);\n  }\n\n  // ----- Private methods: -----\n\n  /**\n   * Pre-allocate some bytes on the dataview, moving the write head into\n   * position.\n   *\n   * @throws TinybufError\n   */\n  private _$pre(bytes: number): DataView {\n    if (this.$byteLength + bytes > this._$dataView.byteLength) {\n      this._$malloc(bytes);\n    }\n\n    this._$writeHead = this.$byteLength;\n    this.$byteLength += bytes;\n\n    return this._$dataView;\n  }\n\n  /**\n   * @throws TinybufError\n   */\n  private _$malloc(bytes: number): void {\n    if (!this._$resizable) {\n      throw new TinybufError(\"exceeded buffer length: \" + this._$dataView.byteLength);\n    }\n\n    const currentBytes = this._$dataView.byteLength;\n    const minNewBytes = this.$byteLength + bytes - currentBytes;\n    const availableBytes = cfg.encodingBufferMaxSize - currentBytes;\n\n    if (minNewBytes > availableBytes) {\n      throw new TinybufError(\"exceeded encodingBufferMaxSize: \" + cfg.encodingBufferMaxSize);\n    }\n\n    const increment = cfg.encodingBufferIncrement;\n    const newBytes = Math.ceil(minNewBytes / increment) * increment;\n    const newSize = currentBytes + Math.min(newBytes, availableBytes);\n    const buf = new Uint8Array(newSize);\n\n    // copy bytes\n    buf.set(this._$bytes);\n\n    // update refs\n    this._$dataView = new DataView(buf.buffer);\n    this._$bytes = buf;\n  }\n}\n","/**\n * Wraps a buffer with a read head pointer.\n *\n * @internal\n */\nexport class BufferReader {\n  public i: number;\n  private _$dataView: DataView;\n\n  public constructor(b: Uint8Array | ArrayBufferView | ArrayBuffer, headerBytes?: number) {\n    this._$dataView = ArrayBuffer.isView(b)\n      ? new DataView(b.buffer, b.byteOffset, b.byteLength)\n      : new DataView(b);\n\n    this.i = headerBytes ?? 0; // internal offset (header)\n  }\n\n  /** Read the next byte, without moving the read head pointer. */\n  public $peek(): number {\n    return this._$dataView.getUint8(this.i);\n  }\n\n  /** Skip the next byte without reading it. */\n  public $skip(): void {\n    this.i++;\n  }\n\n  // ----- Readers: -----\n\n  public $readUint8(): number {\n    return this._$dataView.getUint8(this.i++);\n  }\n\n  public $readUint16(): number {\n    const r = this._$dataView.getUint16(this.i); // big-endian\n    this.i += 2;\n    return r;\n  }\n\n  public $readUint32(): number {\n    const r = this._$dataView.getUint32(this.i); // big-endian\n    this.i += 4;\n    return r;\n  }\n\n  public $readInt8(): number {\n    return this._$dataView.getInt8(this.i++);\n  }\n\n  public $readInt16(): number {\n    const r = this._$dataView.getInt16(this.i, true); // little-endian\n    this.i += 2;\n    return r;\n  }\n\n  public $readInt32(): number {\n    const r = this._$dataView.getInt32(this.i, true); // little-endian\n    this.i += 4;\n    return r;\n  }\n\n  public $readFloat32(): number {\n    const r = this._$dataView.getFloat32(this.i, true); // little-endian\n    this.i += 4;\n    return r;\n  }\n\n  public $readFloat64(): number {\n    const r = this._$dataView.getFloat64(this.i, true); // little-endian\n    this.i += 8;\n    return r;\n  }\n\n  /** @throws RangeError if exceeds length */\n  public $readBytes(bytes: number): Uint8Array {\n    if (this._$dataView.byteOffset + this.i + bytes > this._$dataView.byteLength) {\n      throw new RangeError(\"exceeded bytes\");\n    }\n\n    const view = new Uint8Array(this._$dataView.buffer, this._$dataView.byteOffset + this.i, bytes);\n    this.i += bytes;\n\n    return view;\n  }\n}\n","/* eslint-disable @typescript-eslint/unified-signatures */\nimport { writers, readers } from \"./lib/coders\";\nimport * as coders from \"./lib/coders\";\nimport { $hashCode, $strToHashCode } from \"./lib/hashCode\";\nimport { peekHeader, peekHeaderStr } from \"./lib/peek\";\nimport { BufferWriter } from \"./lib/BufferWriter\";\nimport { BufferReader } from \"./lib/BufferReader\";\nimport {\n  DecodedType,\n  EncoderDefinition,\n  FieldDefinition,\n  TransformConfig,\n  ValidationConfig,\n  MaybeType,\n  Transforms,\n  TypeLiteral,\n  ValidationFn,\n  ValidTypes,\n} from \"./Type\";\nimport { cfg } from \"./config\";\n\nexport type FormatHeader = string | number;\n\n/**\n * Utility to get the decoded type of a buffer format\n * @example type Format = Decoded<typeof MyBufferFormat>\n */\nexport type Decoded<TBufferFormat> = TBufferFormat extends BufferFormat<infer Format, any>\n  ? DecodedType<Format>\n  : never;\n\n/**\n * Defines a format for encoding/decoding binary buffers.\n *\n * Optionally customize the identifier, either as a 2-byte string, an unsigned integer (0 -> 65,535), or as `null` to disable entirely.\n *\n * @example\n * const MyFormat = defineFormat({ ... });\n * const MyFormat = defineFormat('ab', { ... });\n * const MyFormat = defineFormat(1234, { ... });\n * const MyFormat = defineFormat(null, { ... });\n */\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends FormatHeader = number>(def: T): BufferFormat<T, HeaderType>;\n/**\n * Defines a format for encoding/decoding binary buffers.\n *\n * Optionally customize the identifier, either as a 2-byte string, an unsigned integer (0 -> 65,535), or as `null` to disable entirely.\n *\n * @example\n * const MyFormat = defineFormat({ ... });\n * const MyFormat = defineFormat('ab', { ... });\n * const MyFormat = defineFormat(1234, { ... });\n * const MyFormat = defineFormat(null, { ... });\n */\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends FormatHeader = number>(h: HeaderType | null, def: T): BufferFormat<T, HeaderType>;\nexport function defineFormat<T extends EncoderDefinition, HeaderType extends FormatHeader = number>(a?: HeaderType | T, b?: T): BufferFormat<T, HeaderType> {\n  return a !== null && typeof a === \"object\"\n    ? new BufferFormat<T, HeaderType>(a as T)\n    : new BufferFormat<T, HeaderType>(b as T, a as HeaderType);\n}\n\nfunction isValidHeader(h: FormatHeader): boolean {\n  if (typeof h === \"number\") return Number.isInteger(h) && h >= 0 && h <= 65_535;\n  if (typeof h === \"string\") return new TextEncoder().encode(h).byteLength === 2;\n  return false;\n}\n\n/**\n * BufferFormat is a utility class for encoding and decoding binary data based\n * on a provided encoding format.\n *\n * @see {header}\n * @see {encode(data)}\n * @see {decode(binary)}\n */\nexport class BufferFormat<EncoderType extends EncoderDefinition, HeaderType extends FormatHeader = number> {\n  /** @internal */\n  private static _$globalWriter?: BufferWriter;\n\n  /**\n   * A unique identifier encoded as the first 2 bytes (or `undefined` if headerless).\n   *\n   * @see {peekHeader(...)}\n   * @see {peekHeaderStr(...)}\n   */\n  public header!: HeaderType;\n\n  /** @internal */\n  private _$header!: number; // always uint16 vesion\n  /** @internal */\n  private _$type!: TypeLiteral;\n  /** @internal */\n  private _$fields!: Field[];\n  /** @internal */\n  private _$fieldsMap!: Map<string, Field>;\n\n  /** @internal */\n  private _$format?: string;\n  /** @internal */\n  private _$transforms?: Transforms<any> | undefined;\n  /** @internal */\n  private _$validate?: ValidationFn<any> | undefined;\n  /** @internal */\n  private _$hasValidationOrTransforms = false;\n  /** @internal */\n  private _$writer?: BufferWriter;\n\n  public constructor(\n    def: EncoderType,\n    header?: HeaderType | null,\n  ) {\n    // set definition\n    if (typeof def === \"string\" && ValidTypes.includes(def)) {\n      this._$type = def;\n    }\n    else if (def instanceof MaybeType) {\n      throw new TypeError(\"Format cannot be optional\");\n    }\n    else if (def instanceof Object) {\n      this._$type = undefined; // object\n      this._$fieldsMap = new Map();\n      this._$fields = Object.keys(def).map((name) => {\n        const f = new Field(name, def[name]);\n        this._$fieldsMap.set(name, f); // also set map entry\n        return f;\n      });\n\n      // set headers\n      if (header === undefined) {\n        this.header = $hashCode(this.f) as HeaderType; // automatic\n        this._$header = this.header as number;\n      }\n      else if (header === null) {\n        this.header = undefined; // headerless\n        this._$header = undefined;\n      }\n      else if (isValidHeader(header)) {\n        this.header = header; // manual\n        this._$header = typeof header === \"number\" ? header : $strToHashCode(header);\n      }\n      else {\n        throw new TypeError(\"Header must be 2-byte string, uint16, or null.\");\n      }\n    }\n    else {\n      throw new TypeError(\"Format must be object or Type\");\n    }\n  }\n\n  // ----- Static methods: -----\n\n  /**\n   * Read the header of a buffer as a number.\n   *\n   * @see {header}\n   * @throws {RangeError} if buffer size < 2\n   */\n  public static peekHeader = peekHeader;\n\n  /**\n   * Read the header of a buffer as a string.\n   *\n   * @see {header}\n   * @throws {RangeError} if buffer size < 2\n   */\n  public static peekHeaderStr = peekHeaderStr;\n\n  // ----- Accessors: -----\n\n  /**\n   * @example \"{uint8,str[]?}\"\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  private get f(): string {\n    if (this._$format === undefined) {\n      this._$format = this._$fields !== undefined\n        ? `{${this._$fields.map(v => v.f).join(\",\")}}`\n        : `${this._$type}`;\n    }\n\n    return this._$format;\n  }\n\n  /** @internal */\n  private static _$initWriter(): BufferWriter {\n    if (cfg.useGlobalEncodingBuffer) {\n      if (!BufferFormat._$globalWriter) {\n        this._$globalWriter = new BufferWriter(cfg.encodingBufferMaxSize);\n      }\n\n      return this._$globalWriter;\n    }\n\n    return new BufferWriter(cfg.encodingBufferInitialSize);\n  }\n\n  /**\n   * Encode an object into an existing byte array.\n   *\n   * **Warning:** Returns an unsafe view into the encoding buffer. Pass this reference to preserve\n   * performance, and to minimize memory allocation and fragmentation.\n   */\n  public encodeInto<TDecodedType extends DecodedType<EncoderType>>(\n    data: TDecodedType,\n    bytes: Uint8Array,\n  ): Uint8Array {\n    const writer = new BufferWriter(bytes);\n\n    if (this._$hasValidationOrTransforms) {\n      data = this._$preprocess(data);\n    }\n\n    this._$write(data, writer);\n\n    return writer.$viewBytes();\n  }\n\n  /**\n   * Encode an object to bytes.\n   *\n   * **Warning:** Returns an unsafe view into the encoding buffer. Pass this reference to preserve\n   * performance, and to minimize memory allocation and fragmentation.\n   *\n   * @param data - data to encode\n   * @param preserveBytes - (default: `setTinybufConfig().safe`) When set to true, copies encoded\n   * bytes to a new buffer. When set to false, returns an unsafe view of bytes but prevents\n   * unnnecessary memory allocation and fragmentation.\n   *\n   * @returns a copy of encoded bytes\n   * @throws if fails to encode value to schema\n   */\n  public encode<TDecodedType extends DecodedType<EncoderType>>(\n    data: TDecodedType,\n    preserveBytes?: boolean,\n  ): Uint8Array {\n    if (!this._$writer) {\n      // lazy init\n      this._$writer = BufferFormat._$initWriter();\n    }\n\n    // reset\n    this._$writer.$byteLength = 0;\n\n    if (this._$hasValidationOrTransforms) {\n      data = this._$preprocess(data);\n    }\n\n    this._$write(data, this._$writer);\n\n    return (preserveBytes ?? cfg.safe)\n      ? this._$writer.$copyBytes()\n      : this._$writer.$viewBytes();\n  }\n\n  /**\n   * Decode binary data into an existing object instance.\n   * @throws if fails to decode bytes to schema.\n   */\n  public decodeInto<TDecodedType = DecodedType<EncoderType>>(\n    bytes: Uint8Array | ArrayBufferView | ArrayBuffer,\n    obj: Partial<TDecodedType>,\n  ): TDecodedType {\n    return this._$read(new BufferReader(bytes, this.header === undefined ? 0 : 2), obj);\n  }\n  /**\n   * Decode binary data to an object.\n   * @throws if fails to decode bytes to schema.\n   */\n  public decode<TDecodedType = DecodedType<EncoderType>>(\n    bytes: Uint8Array | ArrayBufferView | ArrayBuffer\n  ): TDecodedType;\n  /**\n   * @deprecated use decodeInto() instead\n   */\n  public decode<TDecodedType = DecodedType<EncoderType>>(\n    bytes: Uint8Array | ArrayBufferView | ArrayBuffer,\n    decodeInto: Partial<TDecodedType>,\n  ): TDecodedType;\n  /**\n   * Decode binary data to an object.\n   * @throws if fails to decode bytes to schema.\n   */\n  public decode<TDecodedType = DecodedType<EncoderType>>(\n    bytes: Uint8Array | ArrayBufferView | ArrayBuffer,\n    decodeInto?: Partial<TDecodedType> | undefined,\n  ): TDecodedType {\n    return this._$read(new BufferReader(bytes, this.header === undefined ? 0 : 2), decodeInto);\n  }\n\n  /**\n   * Set additional transform functions to apply before encoding and after decoding.\n   */\n  public setTransforms(transforms: TransformConfig<EncoderType> | Transforms<any>): this {\n    this._$hasValidationOrTransforms = true;\n\n    if (typeof transforms === \"function\" || (Array.isArray(transforms) && typeof transforms[0]  === \"function\")) {\n      this._$transforms = transforms;\n    }\n    else {\n      for (const name of Object.keys(transforms)) {\n        const field = this._$fieldsMap.get(name);\n        if (!field) {\n          throw new TypeError(`Failed to set transforms for field '${name}'`);\n        }\n\n        // Set validation for object.\n        field.$coder.setTransforms(transforms[name]);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Set additional validation rules which are applied on encode() and decode().\n   *\n   * - Validation functions should throw an error, return an error, or return boolean false.\n   * - Anything else is treated as successfully passing validation.\n   */\n  public setValidation(validations: ValidationConfig<EncoderType> | ValidationFn<any>): this {\n    this._$hasValidationOrTransforms = true;\n\n    if (typeof validations === \"function\") {\n      this._$validate = validations;\n    }\n    else {\n      for (const name of Object.keys(validations)) {\n        const field = this._$fieldsMap.get(name);\n        if (!field) {\n          throw new TypeError(`Failed to set validation function for field '${name}'`);\n        }\n\n        field.$coder.setValidation(validations[name]);\n      }\n    }\n\n    return this;\n  }\n\n  // ----- Implementation: -----\n\n  /**\n   * @param value\n   * @param bw\n   * @throws if the value is invalid\n   *\n   * @internal\n   */\n  private _$write(value: any, bw: BufferWriter): void {\n    // write header\n    if (this._$header !== undefined) bw.$writeUint16(this._$header);\n\n    // write scalar\n    if (this._$type !== undefined) {\n      const safeValue = (this._$validate || this._$transforms) ? this._$preprocess(value) : value;\n\n      return writers[this._$type](safeValue, bw);\n    }\n\n    // check for object type\n    if (typeof value !== \"object\" || !value) {\n      throw new TypeError(\"expected object type\");\n    }\n\n    // write each field\n    for (const field of this._$fields) {\n      const subValue = value[field.$name];\n\n      if (field.$isOptional) {\n        if (subValue === undefined || subValue === null) {\n          coders.boolCoder.$write(false, bw);\n          continue; // skip\n        }\n        else {\n          coders.boolCoder.$write(true, bw);\n        }\n      }\n      else if (subValue == null) {\n        throw new Error(`missing required value: ${field.$name}`);\n      }\n\n      if (field.$isArray) {\n        // array\n        this._$writeArray(subValue, bw, field.$coder);\n        continue;\n      }\n\n      // scalar/object field\n      field.$coder._$write(subValue, bw);\n    }\n  }\n\n  /**\n   * pre-process: validation and/or transforms\n   * @internal\n   */\n  private _$preprocess<T extends Record<string, any>>(data: T): T {\n    if (this._$validate) this._$processValidation(data);\n\n    if (typeof this._$transforms === \"function\") {\n      return this._$transforms(data);\n    }\n    else if (Array.isArray(this._$transforms) && typeof this._$transforms[0] === \"function\") {\n      return this._$transforms[0](data);\n    }\n\n    return data;\n  }\n\n  /**\n   * post-process: validation and/or transforms\n   * @internal\n   */\n  private _$postprocess<T extends Record<string, any>>(data: T): T {\n    if (Array.isArray(this._$transforms) && typeof this._$transforms[1] === \"function\") {\n      data = this._$transforms[1](data);\n    }\n\n    if (this._$validate) this._$processValidation(data);\n\n    return data;\n  }\n\n  private _$processValidation(data: any): void {\n    if (!this._$validate) return;\n    const res = this._$validate(data);\n    if (res instanceof Error) throw res;\n    if (res === false) throw new Error(\"failed validation\");\n  }\n\n  /**\n   * This function will be executed only the first time\n   * After that, we'll compile the read routine and add it directly to the instance\n   * @param state\n   * @returns\n   * @throws if fails\n   *\n   * @internal\n   */\n  private _$read<TDecodedType = DecodedType<EncoderType>>(state: BufferReader, obj?: Partial<TDecodedType>): TDecodedType {\n    // This function will be executed only the first time to compile the read routine.\n    // After that, we'll compile the read routine and add it directly to the instance\n\n    // Update the read method implementation.\n    this._$read = this._$compileFormatReadFn();\n\n    return this._$read(state, obj);\n  }\n\n  /**\n   * Generate read function code for this coder.\n   *\n   * @example\n   * let v=o??{};\n   * v.prop1=this._$readField(0,s,o);\n   * v.prop2=this._$readField(1,s,o);\n   * return v\n   *\n   * @internal\n   */\n  private _$makeObjectReadFnBody(): string {\n    const fieldsStr: string = this._$fields\n      .map(({ $name: n }, i) => `v.${n}=this.${this._$readField.name}(${i},s,v.${n})`)\n      .join(\";\");\n\n    return `let v=o??{};${fieldsStr};return v;`;\n  }\n\n  /**\n   * Read an individual field.\n   * @internal\n   */\n  private _$readField(fieldIndex: number, state: BufferReader, obj?: any): any {\n    const field = this._$fields[fieldIndex];\n\n    if (field.$isOptional && !coders.boolCoder.$read(state)) {\n      return undefined;\n    }\n\n    if (field.$isArray) {\n      return this._$readArray(field.$coder, state, obj);\n    }\n\n    return field.$coder._$read(state, obj);\n  }\n\n  /**\n   * Compile the decode() method for this object.\n   *\n   * @internal\n   */\n  private _$compileFormatReadFn<TDecodedType = DecodedType<EncoderType>>(): (state: BufferReader, obj: Partial<TDecodedType> | undefined) => TDecodedType {\n    if (this._$type !== undefined) {\n      // scalar type\n      return this._$hasValidationOrTransforms\n        ? (s) => this._$postprocess(readers[this._$type](s))\n        : readers[this._$type];\n    }\n\n    // object type\n    return new Function(\"s\", \"o\",  this._$makeObjectReadFnBody()) as any;\n  }\n\n  /**\n   * @internal\n   */\n  private _$writeArray(value: any[], bw: BufferWriter, type: BufferFormat<any, any>): void {\n    if (!Array.isArray(value)) {\n      throw new TypeError(`expected array, instead got: ${value}`);\n    }\n\n    coders.uintCoder.$write(value.length, bw);\n    for (let i = 0; i < value.length; i++) {\n      type._$write(value[i], bw);\n    }\n  }\n\n  /**\n   * @throws if invalid data\n   * @internal\n   */\n  private _$readArray<T extends EncoderDefinition>(type: BufferFormat<T, any>, state: any, obj?: Array<T>): Array<T> {\n    const len = coders.uintCoder.$read(state);\n    const arr = obj?.length === len ? obj : new Array(len);\n    for (let j = 0; j < arr.length; j++) {\n      arr[j] = type._$read(state, obj?.[j]);\n    }\n    return arr;\n  }\n}\n\n/**\n * Parses and represents an object field.\n *\n * @internal\n */\nclass Field {\n  public $name: string;\n  public $coder: BufferFormat<any>;\n  public $isOptional: boolean;\n  public $isArray: boolean;\n\n  private _$formatString?: string;\n\n  public constructor(name: string, rawType: FieldDefinition) {\n    this.$isOptional = rawType instanceof MaybeType;\n    let type = rawType instanceof MaybeType ? rawType.type : rawType;\n\n    this.$name = name;\n\n    if (Array.isArray(type)) {\n      if (type.length !== 1) {\n        throw new TypeError(\"Array type must contain exactly one format\");\n      }\n\n      type = type[0];\n      this.$isArray = true;\n    }\n    else {\n      this.$isArray = false;\n    }\n\n    this.$coder = new BufferFormat<any>(type, null);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  public get f(): string {\n    if (this._$formatString === undefined) {\n      this._$formatString = `${(this.$coder as any).f}${this.$isArray ? \"[]\" : \"\"}${this.$isOptional ? \"?\" : \"\"}`;\n    }\n\n    return this._$formatString;\n  }\n}\n"],"names":["TinybufError","Error","$hashCode","str","hash","i","length","charCodeAt","$strToHashCode","$hashCodeToStr","hashCode","String","fromCharCode","Math","floor","peekHeader","b","ArrayBuffer","isView","DataView","buffer","byteOffset","getUint16","peekHeaderStr","BufferParser","constructor","this","_$formats","Map","_$data","processBuffer","f","data","cb","r","header","has","get","_a","decode","set","e","err","stack","on","format","callback","decodeInPlace","ignore","forEach","clear","$floor","$ceil","ceil","$clamp","value","min","max","$roundTowardZero","x","$roundAwayFromZero","$touscal8","$toscal8","$fromuscal8","$fromscal8","Type","UInt","UInt8","UInt16","UInt32","Int","Int8","Int16","Int32","Float64","Float32","Float16","BFloat16","Scalar8","UScalar8","Bool","Bools","Buffer","JSON","RegExp","Date","ValidTypes","Object","values","MaybeType","type","mask","padBit","reduce","n","unmask","l","len","undefined","clz32","Array","isArray","val","$utf8encode","encoder","TextEncoder","encode","$utf8decode","decoder","TextDecoder","y","$tof16","Float32Array","Int32Array","s","z","$fromf16","pow","d","m","Infinity","NaN","Uint32Array","MAX_VARUINT32","MAX_VARINT32","POW_32","uintCoder","$write","writer","Number","$writeUint8","$writeUint16","$writeUint32","$read","reader","firstByte","$peek","$readUint32","$readUint16","$skip","uint8Coder","$readUint8","uint16Coder","uint32Coder","intCoder","int8Coder","$writeInt8","$readInt8","int16Coder","$writeInt16","$readInt16","int32Coder","$writeInt32","$readInt32","bfloat16Coder","$tobf16","$frombf16","float16Coder","float32Coder","$writeFloat32","$readFloat32","float64Coder","$writeFloat64","$readFloat64","uscalar8Coder","scalar8Coder","dateCoder","getTime","bufferCoder","byteLength","$writeBytes","$readBytes","stringCoder","boolCoder","boolsCoder","slice","p","jsonCoder","stringify","parse","regexCoder","global","ignoreCase","multiline","source","g","writers","readers","cfg","safe","useGlobalEncodingBuffer","encodingBufferMaxSize","encodingBufferInitialSize","encodingBufferIncrement","BufferWriter","$0","$byteLength","_$writeHead","_$resizable","Uint8Array","_$bytes","_$dataView","$viewBytes","subarray","$copyBytes","buf","_$pre","setInt8","setInt16","setInt32","setUint8","setUint16","setUint32","setFloat32","setFloat64","bBytes","bytes","_$malloc","currentBytes","minNewBytes","availableBytes","increment","newBytes","newSize","BufferReader","headerBytes","getUint8","getUint32","getInt8","getInt16","getInt32","getFloat32","getFloat64","RangeError","view","BufferFormat","def","_$hasValidationOrTransforms","includes","_$type","TypeError","_$fieldsMap","_$fields","keys","map","name","Field","_$header","isValidHeader","h","isInteger","_$format","v","join","_$initWriter","_$globalWriter","encodeInto","_$preprocess","_$write","preserveBytes","_$writer","decodeInto","obj","_$read","setTransforms","transforms","_$transforms","field","$coder","setValidation","validations","_$validate","bw","safeValue","subValue","$name","$isOptional","coders.boolCoder","$isArray","_$writeArray","_$processValidation","_$postprocess","res","state","_$compileFormatReadFn","_$makeObjectReadFnBody","fieldsStr","_$readField","fieldIndex","_$readArray","Function","coders.uintCoder","arr","j","rawType","_$formatString","bf16round","defineFormat","a","f16round","optional","t","scalround","c","assign","uscalround"],"mappings":"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"}