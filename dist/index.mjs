class TinyBufError extends Error{}class UnrecognizedFormatError extends TinyBufError{}class FormatHeaderCollisionError extends TinyBufError{}class BufferDecodingError extends TinyBufError{constructor(t,e){super(`${t}: ${e.message}`),this.underlying=e,this.stack=e.stack}}class WriteTypeError extends TinyBufError{constructor(t,e,r){super(`Expected '${t}', instead received: ${e} (type: ${typeof e}) (at path: '${r||"<root>"}')`)}}class BufferEncodingError extends TinyBufError{}function djb2HashUInt16(t){let e=5381;for(let r=0;r<t.length;r++)e=33*e^t.charCodeAt(r);return 65535&e}const t=djb2HashUInt16;function strToHashCode(t){return 2===t.length?256*t.charCodeAt(0)+t.charCodeAt(1):djb2HashUInt16(t)}function hashCodeToStr(t){return String.fromCharCode(Math.floor(t/256))+String.fromCharCode(t%256)}function peekHeader(t){return new DataView(t instanceof ArrayBuffer?t:t.buffer).getUint16(0,!1)}function peekHeaderStr(t){return hashCodeToStr(peekHeader(t))}const bufferParser=()=>new BufferParserInstance;class BufferParserInstance{constructor(){this.formats=new Map}get availableFormats(){return new Set([...this.formats.values()].map((t=>t[0])))}processBuffer(t){let e;try{e=peekHeader(t)}catch(t){throw new BufferDecodingError("Failed to process buffer",t)}if(!this.formats.has(e))throw new UnrecognizedFormatError(`Unrecognized format (uint16: ${e}, str: '${hashCodeToStr(e)}')`);const[r,n]=this.formats.get(e);let i;try{i=r.decode(t)}catch(t){throw new BufferDecodingError(`Failed to decode data to format '${r.header}'`,t)}n(i)}on(t,e,r=!1){if(null==t.header)throw new TypeError("Cannot register a headerless encoding format.");const n="string"==typeof t.header?strToHashCode(t.header):t.header;if(this.formats.has(n)&&!r)throw new FormatHeaderCollisionError(`Format with identical header was already registered: ${t.header}`);return this.formats.set(n,[t,e]),this}ignore(...t){return t.forEach((t=>this.on(t,(()=>{}),!0))),this}clear(){this.formats.clear()}}function isBooleanArray(t){return Array.isArray(t)&&t.every((t=>"boolean"==typeof t))}function fixedLengthBooleanArrayToBitmask(t,e){let r="";for(let n=0;n<e;n++)r+=+!!t[n];return parseInt(r,2)}function bools2Mask(t){let e="";for(let r=0;r<t.length;r++)e+=+!!t[r];return parseInt(e,2)}function mask2Bools(t,e){return[...(t>>>0).toString(2).padStart(e,"0")].map((t=>"0"!=t))}function clamp(t,e,r){return Math.min(Math.max(t,e),r)}function r2z(t){return t<0?Math.ceil(t):Math.floor(t)}function raz(t){return t<0?Math.floor(t):Math.ceil(t)}function toUScalar8(t){return Number.isNaN(t)?255:clamp(127+r2z(254*t-127),0,254)}function toScalar8(t){return Number.isNaN(t)?255:clamp(r2z(127*t),-127,127)+127}function fromUScalar8(t){return 255===t?NaN:clamp(.01*(raz(.3937007874015748*(t-127))+50),0,1)}function fromScalar8(t){return 255===t?NaN:clamp(.01*raz(.787401574803149*(t-127)),-1,1)}function uScalarRound(t){return fromUScalar8(toUScalar8(t))}function scalarRound(t){return fromScalar8(toScalar8(t))}const e=268435456,r=2147483647,n=4294967296,i=new TextDecoder("utf-8"),o={write:function(t,e,r){if("number"!=typeof t||t>Number.MAX_SAFE_INTEGER||t<0)throw new WriteTypeError("uint",t,r);const i=r2z(t);i<128?e.writeUInt8(i):i<16384?e.writeUInt16(i+32768):i<536870912?e.writeUInt32(i+3221225472):(e.writeUInt32(Math.floor(i/n)+3758096384),e.writeUInt32(i>>>0))},read:function(t){const e=t.peekUInt8();return 128&e?64&e?32&e?(t.readUint32()-3758096384)*n+t.readUint32():t.readUint32()-3221225472:t.readUint16()-32768:(t.skipByte(),e)}},a={write:function(t,e,r){if("number"!=typeof t||t<0||t>255)throw new WriteTypeError("uint8",t,r);e.writeUInt8(r2z(t))},read:function(t){return t.readUint8()}},s={write:function(t,e,r){if("number"!=typeof t||t<0||t>65535)throw new WriteTypeError("uint16",t,r);e.writeUInt16(r2z(t))},read:function(t){return t.readUint16()}},f={write:function(t,e,r){if("number"!=typeof t||t<0||t>4294967295)throw new WriteTypeError("uint32",t,r);e.writeUInt32(r2z(t))},read:function(t){return t.readUint32()}},u={write:function(t,r,i){if("number"!=typeof t||t>Number.MAX_SAFE_INTEGER||t<-Number.MAX_SAFE_INTEGER)throw new WriteTypeError("int",t,i);const o=r2z(t);o>=-64&&o<64?r.writeUInt8(127&o):o>=-8192&&o<8192?r.writeUInt16(32768+(16383&o)):o>=-268435456&&o<e?r.writeUInt32(3221225472+(536870911&o)):(r.writeUInt32(3758096384+(536870911&Math.floor(o/n))),r.writeUInt32(o>>>0))},read:function(t){let e,r=t.peekUInt8();return 128&r?64&r?32&r?(e=t.readUint32()-3758096384,e=268435456&e?3758096384|e:e,e*n+t.readUint32()):(e=t.readUint32()-3221225472,268435456&e?3758096384|e:e):(e=t.readUint16()-32768,8192&e?4294950912|e:e):(t.skipByte(),64&r?4294967168|r:r)}},c={write:function(t,e,r){if("number"!=typeof t||t<-127||t>127)throw new WriteTypeError("int8",t,r);e.writeInt8(r2z(t))},read:function(t){return t.readInt8()}},h={write:function(t,e,r){if("number"!=typeof t||t<-32767||t>32767)throw new WriteTypeError("int16",t,r);e.writeInt16(r2z(t))},read:function(t){return t.readInt16()}},d={write:function(t,e,n){if("number"!=typeof t||t<-r||t>r)throw new WriteTypeError("int32",t,n);e.writeInt32(r2z(t))},read:function(t){return t.readInt32()}},l={write:function(t,e,r){if("number"!=typeof t)throw new WriteTypeError("number",t,r);e.writeFloat16(t)},read:function(t){return t.readFloat16()}},w={write:function(t,e,r){if("number"!=typeof t)throw new WriteTypeError("number",t,r);e.writeFloat32(t)},read:function(t){return t.readFloat32()}},y={write:function(t,e,r){if("number"!=typeof t)throw new WriteTypeError("number",t,r);e.writeFloat64(t)},read:function(t){return t.readFloat64()}},p={write:function(t,e,r){if("number"!=typeof t)throw new WriteTypeError("number",t,r);e.writeUInt8(toUScalar8(t))},read:function(t){return fromUScalar8(t.readUint8())}},m={write:function(t,e,r){if("number"!=typeof t)throw new WriteTypeError("number",t,r);e.writeUInt8(toScalar8(t))},read:function(t){return fromScalar8(t.readUint8())}},b={write:function(t,e,r){g.write((new TextEncoder).encode(null!=t?t:""),e,r)},read:function(t){return i.decode(g.read(t))}},g={write:function(t,e,r){o.write(t.byteLength,e,r),e.writeBuffer(t)},read:function(t){return t.readBuffer(o.read(t))}},E={write:function(t,e,r){if("boolean"!=typeof t)throw new WriteTypeError("boolean",t,r);e.writeUInt8(t?1:0)},read:function(t){const e=t.readUint8();return Boolean(0!==e)}},U={write:function(t,e,r){if(!isBooleanArray(t))throw new WriteTypeError("boolean[]",t,r);for(let r=0;r<Math.max(1,t.length);r+=6){const n=bools2Mask([!0,r+6>=t.length,...t.slice(r,r+6)]);e.writeUInt8(n)}},read:function(t){const e=[];let r=!1;for(;!r;){const n=t.readUint8(),i=[...(n>>>0).toString(2)].map((t=>"0"!=t));i.shift(),r=i.shift(),e.push(...i)}return e}},B={write:function(t,e,r){if(!isBooleanArray(t))throw new WriteTypeError("boolean[]",t,r);const n=fixedLengthBooleanArrayToBitmask(t,8);e.writeUInt8(n)},read:function(t){return mask2Bools(t.readUint8(),8)}},T={write:function(t,e,r){if(!isBooleanArray(t))throw new WriteTypeError("boolean[]",t,r);const n=fixedLengthBooleanArrayToBitmask(t,16);e.writeUInt16(n)},read:function(t){return mask2Bools(t.readUint16(),16)}},I={write:function(t,e,r){if(!isBooleanArray(t))throw new WriteTypeError("boolean[]",t,r);const n=fixedLengthBooleanArrayToBitmask(t,32);e.writeUInt32(n)},read:function(t){return mask2Bools(t.readUint32(),32)}},_={write:function(t,e,r){let n;try{n=JSON.stringify(t)}catch(t){throw new WriteTypeError("JSON",t,r)}b.write(n,e,r)},read:function(t){const e=b.read(t);return JSON.parse(e)}},A={write:function(t,e,r){if(!(t instanceof RegExp))throw new WriteTypeError("RegExp",t,r);let n,i,o;b.write(t.source,e,r),n=t.global?1:0,i=t.ignoreCase?2:0,o=t.multiline?4:0,e.writeUInt8(n+i+o)},read:function(t){const e=b.read(t),r=t.readUint8();return new RegExp(e,(1&r?"g":"")+(2&r?"i":"")+(4&r?"m":""))}},F={write:function(t,e,r){if(!(t instanceof Date))throw new WriteTypeError("Date",t,r);{const n=t.getTime();if(isNaN(n))throw new WriteTypeError("Date","NaN",r);u.write(n,e,r)}},read:function(t){return new Date(u.read(t))}},setTinybufConfig=t=>{v=Object.assign(Object.assign({},v),t)};let v={useGlobalEncodingBuffer:!1,encodingBufferMaxSize:1500,encodingBufferInitialSize:256,encodingBufferIncrement:256,debug:!1};var S;const k=Math.pow(2,-24),x=function(){const t=new Float32Array(1),e=new Int32Array(t.buffer);return function toHalf(r){t[0]=r;const n=e[0];let i=n>>16&32768,o=n>>12&2047;const a=n>>23&255;return a<103?i:a>142?isNaN(r)?31745:(i|=31744,i|=(255==a?0:1)&&8388607&n,i):a<113?(o|=2048,i|=(o>>114-a)+(o>>113-a&1),i):(i|=a-112<<10|o>>1,i+=1&o,i)}}();function f16unmask(t){return 32768&t?-f16.t[((t>>10&31)<<10)+(1023&t)]:f16.t[((t>>10&31)<<10)+(1023&t)]}function fround16(t){return f16unmask(x(t))}class f16{static _initFloat16LookupTable(){const t=[];for(let e=0;e<32;e++)for(let r=0;r<1024;r++){const n=f16.precalc(e,r);t[(e<<10)+r]=n}return t}static precalc(t,e){return 0===t?0===e?0:k*(e/1024):31===t?0===e?1/0:NaN:(t-=15,Math.pow(2,t)*(1+e/1024))}}S=f16,f16.t=S._initFloat16LookupTable();class BufferWriter{constructor(t){this.o=0,this.resize=!0,t instanceof ArrayBuffer?(this.buf=t,this.resize=!1,v.debug&&console.debug("[tinybuf] assigning buffer writer to global encoding buffer")):(v.debug&&console.debug(`[tinybuf] allocating new buffer (${t} bytes)`),this.buf=new ArrayBuffer(t)),this.view=new DataView(this.buf,0,this.buf.byteLength)}asView(){return new Uint8Array(this.view.buffer,0,this.o)}asCopy(){return new Uint8Array(this.view.buffer.slice(0,this.o))}writeInt8(t){this.view.setInt8(this.alloc(1),t)}writeInt16(t){this.view.setInt16(this.alloc(2),t,!0)}writeInt32(t){this.view.setInt32(this.alloc(4),t,!0)}writeUInt8(t){this.view.setUint8(this.alloc(1),t)}writeUInt16(t){this.view.setUint16(this.alloc(2),t)}writeUInt32(t){this.view.setUint32(this.alloc(4),t)}writeFloat16(t){this.view.setUint16(this.alloc(2),x(t))}writeFloat32(t){this.view.setFloat32(this.alloc(4),t)}writeFloat64(t){this.view.setFloat64(this.alloc(8),t)}writeBuffer(t){const e=this.alloc(t.byteLength),r=t instanceof Uint8Array?t:t instanceof ArrayBuffer?new Uint8Array(t):new Uint8Array(t.buffer,t.byteOffset,t.byteLength);new Uint8Array(this.view.buffer,e,t.byteLength).set(r)}alloc(t){const e=this.o;if(this.o+t<=this.view.byteLength)return this.o+=t,e;if(!this.resize)throw new BufferEncodingError("Write buffer exceeded maximum size of global buffer.");const r=this.view.byteLength,n=r+t;if(n>v.encodingBufferMaxSize)throw new BufferEncodingError(`Write buffer exceeded maximum size. Bytes requested: ${n}. Max size: ${v.encodingBufferMaxSize}.`);let i=this.view.byteLength;do{i=Math.min(i+v.encodingBufferIncrement,v.encodingBufferMaxSize)}while(i<this.o+t);v.debug&&console.debug(`[tinybuf] resizing buffer ${r} -> ${i}`);const o=new ArrayBuffer(i),a=new Uint8Array(this.view.buffer,this.view.byteOffset,r);return new Uint8Array(o).set(a),this.buf=o,this.view=new DataView(o),this.o+=t,e}}class BufferReader{constructor(t,e){this.data=t instanceof ArrayBuffer?new DataView(t):new DataView(t.buffer,t.byteOffset,t.byteLength),this.i=null!=e?e:0}get hasEnded(){return this.i===this.data.byteLength}peekUInt8(){return this.data.getUint8(this.i)}skipByte(){this.i++}readUint8(){return this.data.getUint8(this.i++)}readUint16(){const t=this.data.getUint16(this.i);return this.i+=2,t}readUint32(){const t=this.data.getUint32(this.i);return this.i+=4,t}readInt8(){return this.data.getInt8(this.i++)}readInt16(){const t=this.data.getInt16(this.i,!0);return this.i+=2,t}readInt32(){const t=this.data.getInt32(this.i,!0);return this.i+=4,t}readFloat16(){const t=this.data.getUint16(this.i);return this.i+=2,f16unmask(t)}readFloat32(){const t=this.data.getFloat32(this.i);return this.i+=4,t}readFloat64(){const t=this.data.getFloat64(this.i);return this.i+=8,t}readBuffer(t){if(this.i+t>this.data.byteLength)throw new RangeError("Trying to access beyond byte length");const e=new Uint8Array(this.data.buffer,this.i,t);return this.i+=t,e}}const z=["float16","float32","float64","int","int8","int16","int32","uint","uint8","uint16","uint32","uscalar","scalar","bool","booltuple","bitmask8","bitmask16","bitmask32","str","date","regex","json","buf"];class OptionalType{constructor(t){this.type=t}}function optional(t){return new OptionalType(t)}function defineFormat(t,e){return null!==t&&"object"==typeof t?new BufferFormat(t):new BufferFormat(e,t)}class BufferFormat{constructor(t,e){if(this._vt=!1,t instanceof OptionalType)throw new TypeError("Invalid encoding format: Root object cannot be optionals.");if(void 0!==t&&"string"==typeof t&&z.includes(t))this.type=t;else{if(!(t instanceof Object))throw new TypeError("Invalid encoding format: Must be an object, or a known coder type.");this.type="{object}",this.fieldsMap=new Map,this.fields=Object.keys(t).map((e=>{const r=new Field(e,t[e]);return this.fieldsMap.set(e,r),r}))}if(void 0===e&&"{object}"===this.type)this.header=this.hashCode,this._header=this.header;else if(null===e)this.header=void 0,this._header=void 0;else{if(!function isValidHeader(t){return"number"==typeof t?Number.isInteger(t)&&t>=0&&t<=65535:"string"==typeof t&&2===(new TextEncoder).encode(t).byteLength}(e))throw new TypeError(`Header should be an integer between 0 and 65535, a 2-byte string, or null. Received: ${e}`);this.header=e,this._header="number"==typeof e?e:strToHashCode(e)}}get hashCode(){return void 0===this._hash&&(this._hash=t(this.format)),this._hash}get format(){return void 0===this._format&&(this._format="{object}"===this.type?`{${this.fields.map((t=>t.format)).join(",")}}`:`${this.type}`),this._format}encode(t,e){return this._vt&&(t=this._preEncode(t)),v.useGlobalEncodingBuffer&&void 0===BufferFormat.globalBuffer&&(BufferFormat.globalBuffer=new ArrayBuffer(v.encodingBufferMaxSize),v.debug&&console.debug(`[tinybuf] init global encoding buffer (${v.encodingBufferMaxSize} bytes)`)),void 0===this._w?this._w=new BufferWriter(v.useGlobalEncodingBuffer?BufferFormat.globalBuffer:v.encodingBufferInitialSize):this._w.o=0,this.write(t,this._w,""),(null==e?void 0:e.safe)?this._w.asCopy():this._w.asView()}decode(t){return this.read(new BufferReader(t,void 0===this.header?0:2))}setTransforms(t){if(this._vt=!0,t instanceof Function||Array.isArray(t)&&t[0]instanceof Function)this._transforms=t;else for(const e of Object.keys(t)){const r=this.fieldsMap.get(e);if(!r)throw new TypeError(`Failed to set transforms for field '${e}'`);r.coder.setTransforms(t[e])}return this}setValidation(t){if(this._vt=!0,t instanceof Function)this._validate=t;else for(const e of Object.keys(t)){const r=this.fieldsMap.get(e);if(!r)throw new TypeError(`Failed to set validation function for field '${e}'`);r.coder.setValidation(t[e])}return this}write(t,e,r){if(void 0!==this._header&&this._w.writeUInt16(this._header),"{object}"!==this.type){const n=this._validate||this._transforms?this._preEncode(t):t;return this.getCoder(this.type).write(n,e,r)}if(!t||"object"!=typeof t)throw new TypeError(`Expected an object at ${r}`);for(const n of this.fields){const i=r?`${r}.${n.name}`:n.name,o=t[n.name];if(n.isOptional){if(null==o){E.write(!1,e);continue}E.write(!0,e)}n.isArray?this._writeArray(o,e,i,n.coder):n.coder.write(o,e,i)}}getCoder(t){switch(t){case"bool":return E;case"booltuple":return U;case"bitmask16":return T;case"bitmask32":return I;case"bitmask8":return B;case"buf":return g;case"date":return F;case"float16":return l;case"float32":return w;case"float64":return y;case"int":return u;case"int16":return h;case"int32":return d;case"int8":return c;case"json":return _;case"regex":return A;case"scalar":return m;case"str":return b;case"uint":return o;case"uint16":return s;case"uint32":return f;case"uint8":return a;case"uscalar":return p}}_preEncode(t){if(this._validate&&!1===this._validate(t))throw new Error("custom validation failed");return this._transforms instanceof Function?this._transforms(t):Array.isArray(this._transforms)&&this._transforms[0]instanceof Function?this._transforms[0](t):t}_postDecode(t){return Array.isArray(this._transforms)&&this._transforms[1]instanceof Function&&(t=this._transforms[1](t)),this._validate instanceof Function&&this._validate(t),t}read(t){return this.read=this.compileRead(),this.read(t)}generateObjectReadCode(){return`return{${this.fields.map((({name:t},e)=>`${t}:this.${this._readField.name}(${e},state)`)).join(",")}}`}_readField(t,e){const r=this.fields[t];if(!r.isOptional||this._readOptional(e))return r.isArray?this._readArray(r.coder,e):r.coder.read(e)}readValueType(t){return this._postDecode(this.getCoder(this.type).read(t))}compileRead(){if("{object}"!==this.type&&"[array]"!==this.type)return void 0!==this._validate||void 0!==this._transforms?this.readValueType:this.getCoder(this.type).read;const t=this.generateObjectReadCode();return new Function("state",t)}_writeArray(t,e,r,n){let i,a;if(!Array.isArray(t))throw new WriteTypeError(`Array<${n.type}>`,e,r);for(a=t.length,o.write(a,e),i=0;i<a;i++)n.write(t[i],e,r+"."+i)}_readArray(t,e){const r=new Array(o.read(e));for(let n=0;n<r.length;n++)r[n]=t.read(e);return r}_readOptional(t){return E.read(t)}}BufferFormat.peekHeader=peekHeader,BufferFormat.peekHeaderStr=peekHeaderStr;class Field{constructor(t,e){this.isOptional=e instanceof OptionalType;let r=e instanceof OptionalType?e.type:e;if(this.name=t,Array.isArray(r)){if(1!==r.length)throw new TypeError("Invalid array definition, it must have exactly one element");r=r[0],this.isArray=!0}else this.isArray=!1;this.coder=new BufferFormat(r,null)}get format(){return void 0===this._format&&(this._format=`${this.coder.format}${this.isArray?"[]":""}${this.isOptional?"?":""}`),this._format}}export{BufferDecodingError,BufferEncodingError,BufferFormat,BufferParserInstance,FormatHeaderCollisionError,TinyBufError,UnrecognizedFormatError,WriteTypeError,bufferParser,defineFormat,x as f16mask,f16unmask,fromScalar8,fromUScalar8,fround16,optional,peekHeader,peekHeaderStr,scalarRound,setTinybufConfig,toScalar8,toUScalar8,uScalarRound};
//# sourceMappingURL=index.mjs.map
